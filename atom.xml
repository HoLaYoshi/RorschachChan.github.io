<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-07T13:20:27.509Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十六年，九个队伍，一份爱</title>
    <link href="http://yoursite.com/2018/02/07/%E5%8D%81%E5%85%AD%E5%B9%B4%EF%BC%8C%E4%B9%9D%E4%B8%AA%E9%98%9F%E4%BC%8D%EF%BC%8C%E4%B8%80%E4%BB%BD%E7%88%B1/"/>
    <id>http://yoursite.com/2018/02/07/十六年，九个队伍，一份爱/</id>
    <published>2018-02-07T03:21:27.000Z</published>
    <updated>2018-02-07T13:20:27.509Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>原文地址：<a href="https://www.theplayerstribune.com/caron-butler-retiring/" target="_blank" rel="noopener">https://www.theplayerstribune.com/caron-butler-retiring/</a></p><p>我妈第一次坐飞机的时候可真心把她吓得不行，我想她那时候肯定对Pat Riley有一些悄悄的不满。</p><p>那是2002年NBA选秀后的一天，我们乘Pat Riley派来的球队机飞翔在30000英尺的高空，从威斯康辛出发到佛罗里达的迈阿密热火队报到。我现在一闭上眼也能想起当时我妈妈Mattie坐在一个宽敞的椅子里，时而看看我时而看看窗外，前后张望的样子。她的脸上交织出坐飞机的恐惧，但又很自豪的复杂表情。</p><p>“这整个飞机只为我们几个服务的么?”她简直难以置信，要知道整个飞机上的乘客只有我、我的家人和两个热火队的工作代表。</p><p>我其实也是觉得如此的不可思议，但是我要管理好自己的神态，让自己显得比较酷。我坐在的位置上，平复自己的心情，保持正常的呼吸。球队代表给我展示了属于Alonzo Mourning和LaPhonso Ellis的专位，这看上去太梦幻了。</p><p>我对我母亲说“这一切太梦幻了”。</p><p>我一直在告诉我自己，现在我已经是热火队的一份子了。不是我吹牛，我也曾经在康大的时候也坐过飞机去打比赛，但是从来没做过头等舱，这在那个时刻我就坐在这架专机比头等舱还要牛逼的地方。那是Pat Riley级别的仓位。我一直让自己尝试冷静，“Caron，冷静，你很棒，你是个爷们，你要表现的就像以前那样从容。”</p><p>当我回忆起来当时的情景，觉得实在太滑稽了。我一直试图去安抚我那位紧张的老妈，而其实我内心的紧张不比她少多少。</p><p>这就是16年前我去迈阿密热火队报到的情景，从此开始了我的NBA生涯。如果那时候你跟我说我要在十多年的职业生涯里为9个队伍打球，我想我的表情会跟当时飞机上我的老妈一样。</p><p>但是事情就这么发生了，顺其自然，这16年真是一段棒极了的旅行。而今天，我宣布正式从NBA退役。</p><p>你知道，我其实很想写一封信给年轻时候的自己，不过我想12岁的我应该压根不会理会这封穿越时空的信。如果他发现信封里没有钞票，可能就会直接把它扔进垃圾桶里。然后会嘲笑我现在的光头并且补上一刀“哥们，你真老”。</p><p>但我现在就想告诉你那些让我NBA梦成真的人和故事。而这一切的一切都要从当时热火队总裁Pat Riley开始。</p><p>我出生在威斯康星州的拉辛，在18岁之前我没有踏出过那里半步，不过我有听说过芝加哥，也见过有人在迈阿密的海滩上放风筝。除了康涅狄格州那两年，拉辛就是我的全部。大城市？我只有在电影和电视里看到他们的样子。</p><p>然后就是参加NBA选秀，不久我就接到Pat Riley总裁的电话，然后我成了迈阿密的一份子，那一切的一切彷佛是发生在我身体之外的。我觉得我可牛逼了，你知道么？我那时候简直是全世界最幸福的人，我准备把人生最好的青春时光投身于职业篮球，我要让家族骄傲，要让整个拉辛骄傲。</p><p>但我第一天踏进热火队训练馆的时候迎接我的不是雪茄和派对，迎接我的是“你的更衣间在这里，你迟到了，你应该早来一个小时的，明天开始训练，对了，你叫啥来着？”</p><p>这就是我到训练馆听到的第一句话，这就是热火给我的第一感觉。它让我停止了“从专机到专车，全家在迈阿密的豪华旅行，每个人都以我为豪”的感觉，开始了真刀真枪的训练—-我看到Pat Riley就站在训练场场边，他手上带着总冠军戒指，他很正经的跟你说，马上去好好训练或者从训练馆出去。</p><p>迈阿密的纸醉金迷让很多年轻人迷失，不过那种夜生活对我没有什么侵蚀力。我十四岁的时候就有了我第一个儿子，我年少的时候可没少蹲过号子，记得我16岁的时候，警察曾经在我学校的储物柜里搜出来了毒品和手枪，我也被拘留了一段时间。我出自黑人街头，小时候经历了很多哥们朋友死掉。所以我没有期待过什么幸福温暖的日子，那时候，篮球是我唯一守护的东西。我尽力的不让那些声色犬马去分散我的注意力。</p><p>不过那时候我毕竟还是一个小孩，虽然我心态还算端正，但是我却不知道如何百分百的把精力都投入到训练里去。</p><p>最开始的几个月对于我整个职业生涯来说是非常重要的，热火队从一开始培养我的比赛观和胜负观，你把它想像成是一个称之为愿望也好，意志力也好，反正就是一个坚定的信念，我想正是这个信念让我能在NBA待这么久。我们为热火队打球，为Pat Riley总裁和Stan Van教练卖命。他俩教会了我如何正确的身体训练，正确的战术训练，叮嘱我们正确的去准备比赛，告诫我们细节决定成败。</p><p>幸运的是，我很早就领悟到“天赋并没有你想象的那么重要”这个道理，当然，有天赋肯定很赞，但是如果你在比赛里倾尽所有、全力以赴，哪怕你的对手比你能跳能跑，但是你也有很大的几率赢球。钻研，不断地打磨技术，这才是赢球的不二法则。如果有人说“在NBA这么高水平的比赛里，基本功并不是重要”，这话简直就是痴人说梦。</p><p>Pat Riley教练会以各种不同的方式教我事情，我永远不会忘记他会在我的更衣柜上留下字条，我会在训练前看到这些字条，上面有些写的是我技术上缺陷和需要进步的地方，有些写的是励志的话语。那可不是简单的一两句话的便条，每一个字条都对我有着绝大的影响，这就是我跟我篮球教父之前所建的秘密联系通道—用我们自己的语言去彼此沟通，正是这每一张字条让我成为了一个更好的篮球选手。多年之后，我转会去了雷霆队。我开始效仿当年Pat Riley给我留字条那样的给Kevin Durant留字条，KD是我的小兄弟。我很惊讶和感激在他的MVP的获奖演讲里他特别提到了这个事儿。但是我看来，我只是做了我的篮球恩师Pat Riley做的事情。</p><p>第二年，当我得知被交易去湖人队的时候，我很受伤，我想Pat Riley跟我之间的特殊关系仅仅是在篮球层面的。我的意思是说，如果我当时在Pat Riley的位置上也会把自己拿去交易Shaq的。如果你看着镜子中自己，然后说你比Shaq对这个队伍更有价值，那我无话可说，因为我实在不想打击你的自尊心。</p><p>不过那种失落并没有持续很久啦，这就是在联盟里生存的学费。就像我前面说的，我在拉辛住了十多年，我也希望终老迈阿密。我还记得跟D-Wade、Brian Grant、Eddie Jones、Alonzo这些家伙一起打球的日子，那是一段令人难以置信的学习经历，我会永远记得和那些家伙一起玩的开心时光。但是这就是生意，不久后我就动身出发去洛杉矶报到，身边的人从Dwyane Wade变成了Kobe Bryant，Dwyane Wade是我的铁哥们，但是这个世界也没几个人会拒绝跟Kobe联手。当我到了洛杉矶也就大约一周的时间吧，当初到迈阿密的紧张感觉被我忘个干净。</p><p>我仅仅在湖人效力了一个球季就被交易去了华盛顿奇才，有趣的是，那个交易对我来说没什么伤害。我认为那是一个很好的决定，当时的奇才队有很多年轻的充满天赋的选手，我很高兴有机会成为他们的一员。</p><p>华盛顿的六年是我一生中最棒的时光，在奇才队我两次入选全明星赛。我和Antawn Jamison、Brendan Haywood、以及当时还没有称呼自己是“Hibachi”的Gilbert Arenas在东部打出了一片天,我永远记得华盛顿人民是多么的热爱那支奇才队。纵然迈阿密和洛杉矶都是超级大城市，但是华盛顿却是我职业生涯效力时间最长的地方，那是我第二个篮球之家。<br><img src="/images/caron1.jpg" alt="paradin"></p><p>交易帮助我学习到了篮球生意的真相，我不论到哪个球队，都试图在训练里做一个榜样，就用当初在迈阿密学到的那套。我在健身房里专注训练，总是要求自己做的更好，总是要求自己记住细节。在每一支队伍里我都与队友们打成一片，我的意思是，换做是你整天跟这帮队友们泡在一起，如果你不是太拘谨的话，会很容易融入这个集体的。</p><p>不过我毕竟辗转了九个城市，这漂泊的生活对我的家庭来说是很困难的。要知道，我那时仅仅在菲尼克斯就待了一个月左右的时间，我的妻子Andrea又不得不收拾行李搬家去下一站，所以我的孩子们总是在不停的转学转学。我妈–她一直以我为荣，即使我不是比赛中的MVP，但是只要我命中一记投篮她都会在场边兴奋不已（谢谢你，老妈）。但我也深知，为了我的篮球生涯，其实我的家庭牺牲了很多。</p><p>我现在感谢上苍，我依旧活着。上周，我回拉辛去参加一个葬礼，那是一个26岁的小伙子，从他的车上逃离的时候被警察连开数枪。我本人不认识他，但是我理解那种感觉。因为我和那些在拉辛长大的朋友，我们都知道死亡随时都降临的恐惧感。我深深地理解被困在那里是一种什么滋味，我很幸运。我知道那些被杀或者误入歧途的人没有做到过。我参加了很多个葬礼，那很难受。不过很奇怪，在生活中你像我一样已经达到了一定的高度，当周围人告诉你你已经满足了，你也会想“我真的做到了”，就是这样，但是并不容易。所以我回继续前进，永不回头。</p><p>对于我来说我现在跟那些拉辛的孩子一样，我也出生在这里，我也曾经是拉辛的孩子，我也做过各式各样的蠢事。但是我从中学习到了，要知道从教训里学习的确不是一个容易的事儿，但是我最终还收获了经验。一旦我有一个目标，就要付出全部，我不想让那些相信我的人失望。我能拥有如此多的东西，我已经很知足了。</p><p>文章的最后我想说几个人，这可能会像是一连串名单，毕竟我在联盟里摸爬滚打了这么多年，肯定有很多人要去感谢，如果我忘记了提到某人，那请准许我提前道歉。</p><p>在我开始第一场NBA比赛之前，我的妻子就对我说无论我去哪里她都会跟着，这么些年，她一直信守当初的承诺。这辈子讨到她做老婆真是我的福气，无论是现在还是将来她都会是我生命里最棒的那部分。</p><p>感谢BJ Evans、Rob Wilson、Tim Donovan、Andy Elisberg、Jay Sabol、Marjie Kates、Shivani Desai、Tim Grover 和整个Arison家族在我职业生涯初期给我的帮助。</p><p>我要感谢Buss 家族、Mitch Kupchak、Magic Johnson、Alison Bogli和Eugenia Chow在洛杉矶给我的支持。</p><p>感谢Ernie Grunfeld、Milt Newton、Tommy Amaker、Sashia Jones、Candace、Susan O’Malley在华盛顿给我的帮助。</p><p>感谢老板Mark Cuban和主教练Rick Carlisle在达拉斯给我的帮助。</p><p>还有我在快船队的队友们：Blake Griffin、DeAndre Jordan、CP3–正是你们让我从重伤中走出来，重获新生。<br><img src="/images/caron2.jpg" alt="paradin"></p><p>Matt Barnes、Lamar Odom、Chauncey Billups还有我的偶像Grant Hill，我不会忘记跟你们一起的那段日子。</p><p>我一直都梦想能穿着雄鹿队的队服打球，感谢John Hammond和Senator Kohl，你们圆了我的梦，说实话在家乡打球的感觉真好！谢谢你们。</p><p>在雷霆队，我要感谢总经理Sam Presti、KD和Russell Westbrook。</p><p>在活塞队，我要感谢Tom Gores，而且在底特律能跟Stan Van重聚，并且与我的哥们Andre Drummond、Reggie Jackson和KCP一起打球。</p><p>Vlade Divac，是你在2016年给我打电话，让我再去国王队跟Rajon Rondo和DeMarcus Cousins打了一年球。</p><p>还有一个需要特别说的，那就是刚刚去世的我永远的哥们Rasual Butler，我俩同一年进入联盟。像我一样，Rasual Butler也是一个辗转多队的浪人，但他身上有我敬佩的一切特征—勤奋、专业、积极、体育精神。他是一个人民交口称赞的好队友。哥们，NBA的家人们会想你的。</p><p>我的粉丝们，你永远不会知道你们曾经带给我的快乐。谢谢你们的支持!我希望每当你想到Caron Butler这个名字的时候，你会记得我曾经是多么的热爱和尊重比赛。我希望你们能记住这个男人付出所有的形象。我知道这是一个陈词滥调，但这个形象对我来说要比比赛还要重要。</p><p>我现在仍然会深深地回想起2002年那次飞往迈阿密的情景，当时我和我的家人在热火队的飞机上—不是因为昂贵或奢侈，也不是因为我第一次去海边。而是因为那是我一生中第一次真的感觉要去某个地方。</p><p>在NBA打球是我的梦想，我和所有这些伟大的教练和队友们一起度过了这16年，那是一段比我想象的要好的时光。我虽然身体已经不适合打NBA的比赛，但是篮球依旧在我的生活里，我会以另外的一种形式继续跟它在一起。</p><p>我只想让你们都知道我拥有我自己的生命，但正是有了你们的帮助，这个生命才活的如此多姿多彩。<br><img src="/images/caron3.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      再见，Caron Butler，祝你退役快乐！
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="NBA" scheme="http://yoursite.com/tags/NBA/"/>
    
  </entry>
  
  <entry>
    <title>记录Uwsgi与Django成功勾搭的始末</title>
    <link href="http://yoursite.com/2018/02/07/%E8%AE%B0%E5%BD%95Uwsgi%E4%B8%8EDjango%E6%88%90%E5%8A%9F%E5%8B%BE%E6%90%AD%E7%9A%84%E5%A7%8B%E6%9C%AB/"/>
    <id>http://yoursite.com/2018/02/07/记录Uwsgi与Django成功勾搭的始末/</id>
    <published>2018-02-07T02:15:09.000Z</published>
    <updated>2018-02-07T02:37:09.169Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="环境说明">环境说明</span></h2><p>Uwsgi版本：<code>2.0.14</code>(yum install安装）<br>django版本：<code>1.10.6</code>（pip install安装）<br>python版本：<code>2.7.5</code>(阿里云 centos 7自带）<br>nginx版本：<code>1.10.2</code>（yum install安装）</p><h2><span id="正文">正文</span></h2><p>在<code>https://rorschachchan.github.io/2018/02/02/Uwsgi的安装和简单使用/</code>里面，我们已经实现了网页打开出现”good bye,logan”的效果，可见<code>Web Client &lt;===&gt; uWSGI &lt;===&gt; Python</code>是通畅的，现在我们要调整看看django与uwsgi是否是通畅的。</p><p>首先，我们在/django这个目录下，<code>django-admin.py startproject logan</code>，建立了一个叫logan的project，然后在/django/logan/logan里会有一个自动生成的<code>wsgi.py</code>，打开一看，里面的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">WSGI config for logan project.</span></span><br><span class="line"><span class="string">It exposes the WSGI callable as a module-level variable named ``application``.</span></span><br><span class="line"><span class="string">For more information on this file, see</span></span><br><span class="line"><span class="string">https://docs.djangoproject.com/en/1.10/howto/deployment/wsgi/</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application</span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"logan.settings"</span>)</span><br><span class="line">application = get_wsgi_application()</span><br></pre></td></tr></table></figure></p><p>我们原来的目标就是测试django跟uwsgi的链接是否正常，那么返回到/django/logan，使用<code>python manage.py runserver 0.0.0.0:8000</code>启动django，然后打开浏览器，在地址栏里输入<code>外网ip:8000</code>，看到了如下的界面：<br><img src="/images/ud1.png" alt="paradin"></p><p>可见django已经启动成功，但是前面说过了，这种方法只能测试环境里小规模的玩玩，完全不推荐拿去生产化境里。所以现在我们用uwsgi在8000来启动一下django。</p><p>首先，先停止了原来我们启动的django。</p><p>然后，使用命令<code>uwsgi --http :8000 --wsgi-file logan.py</code>,反馈错误信息如下：<br><img src="/images/ud2.png" alt="paradin"></p><p>出现这个错误，那就<code>yum install uwsgi-plugin-python</code>，同时使用<code>uwsgi --plugin python --http-socket :8001 --wsgi-file /django/logan/logan/wsgi.py</code>，这样却又出了一个新错误：<br><img src="/images/ud3.png" alt="paradin"></p><p>提示说：<code>ImportError: No module named logan.settings</code>。可是当我使用python客户端单独测试的时候，这个语句是可以使用的，如图：<br><img src="/images/ud4.png" alt="paradin"></p><p>很多人都卡在了这种情况，这个时候我们需要换一个命令：<code>uwsgi --plugin python --http-socket :8001 --chdir /django/logan/ --wsgi-file /django/logan/logan/wsgi.py</code>。然后我们在浏览器地址栏里输入<code>外网地址：8001</code>就可以看到如下网页：<br><img src="/images/ud5.png" alt="paradin"></p><p>可见，我们已经通过uwsgi启动了原本已经关闭了的django，这样就达到了<code>Web Client &lt;===&gt; uWSGI &lt;===&gt; Django</code>的目的。</p><p>如果过程中出现了端口被占用的情况，比如8002端口已经被使用了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probably another instance <span class="keyword">of</span> uWSGI is running on the same address (:<span class="number">8002</span>).</span><br><span class="line">bind(): Address already <span class="keyword">in</span> use [core/socket.c line <span class="number">764</span>]</span><br></pre></td></tr></table></figure></p><p>那么就可以使用<code>lsof -i:8002</code>，然后把对应的进程干掉就好了。</p><p>最后附赠python脚本一个，这个脚本可以显示python的path，内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print <span class="string">'===== sys.path / PYTHONPATH ====='</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> sorted(os.environ.keys()):</span><br><span class="line">    v = os.environ[k]</span><br><span class="line">    print (<span class="string">'%-30s %s'</span> % (k,v[:<span class="number">70</span>]))</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.python88.com/topic/101/" target="_blank" rel="noopener">http://www.python88.com/topic/101/</a><br><a href="http://www.nowamagic.net/academy/detail/1330334" target="_blank" rel="noopener">http://www.nowamagic.net/academy/detail/1330334</a></p>]]></content>
    
    <summary type="html">
    
      这一步是搭建框架的import key，在这里面你能感受到python版本的恶心...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="uwsgi" scheme="http://yoursite.com/tags/uwsgi/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins与钉钉机器人实现手机端获取当前服务日志</title>
    <link href="http://yoursite.com/2018/02/06/Jenkins%E4%B8%8E%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AD%E9%85%8D%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2018/02/06/Jenkins与钉钉机器人搭配手机端获取当前服务日志/</id>
    <published>2018-02-06T12:56:33.000Z</published>
    <updated>2018-02-06T15:10:43.721Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>马上要过年了，各位运维们除了因为买不到回家的火车票而嚎嚎大哭之外也开始扩容服务器和提前调整监控值，目的就是为了过一个消停的春节。可是这毕竟十天左右不在公司，要是模块真出了什么意外肯定没法第一找到日志分析问题，毕竟这几天都在串门拜年和醉生梦死中度过，走到哪都要再背一个笔记本实在太不方便了。</p><p>那么这个时候，我就琢磨使用手机端来启动服务器里脚本，让这个脚本可以去获取当前的日志，然后再把结果返回到手机端。这样就不用到哪里都带那个一看就很扫兴的公司笔记本电脑了。</p><p>使用手机端启动服务器里脚本？我又不会开发android和ios，那么肯定就要使用第三方工具，我条件反射的想到了jenkins，因为jenkins是用手机可以登录的，那么在手机端得到结果用什么呢？在微信公众号和钉钉机器人里，我选择了钉钉机器人。</p><h2><span id="创造钉钉机器人">创造钉钉机器人</span></h2><p>我的钉钉版本是4.2.6.37，首先在左上角头像的三角菜单有一个<code>机器人管理</code>，如图：<br><img src="/images/dingding1.png" alt="paradin"></p><p>然后选择自定义机器人，给它起个名又换一个图标之后，添加到一个群聊里，如图：<br><img src="/images/dingding2.png" alt="paradin"></p><p>添加的时候，这个机器人会生成一个<code>webhook</code>，它的结构应该是：<code>https://oapi.dingtalk.com/robot/send?access_token=XXX</code>，后面的XXX是标识符，不同的标识符代表不同的机器人，这个标识符如果丢了，可以在机器人头像点击一下然后选择<code>机器人设置</code>重新看到。</p><h2><span id="编写机器人脚本">编写机器人脚本</span></h2><p>机器人的官方说明网址就是<code>https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.zZIvnt&amp;treeId=257&amp;articleId=105735&amp;docType=1</code>，这里面已经把使用方法写的够清楚了。我这里的这个python脚本是用json的格式，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/python</span></span><br><span class="line">#coding: utf-8</span><br><span class="line"><span class="keyword">import</span> json,urllib2</span><br><span class="line"></span><br><span class="line">#这里是机器人对应的Webhook地址</span><br><span class="line">url = <span class="string">"https://oapi.dingtalk.com/robot/send?access_token=这里输入你机器人的标识符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#这里是头，原样复制就好</span></span><br><span class="line"><span class="string">header = &#123;</span></span><br><span class="line"><span class="string">    "</span>Content-Type<span class="string">": "</span>application/json<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>charset<span class="string">": "</span>utf<span class="number">-8</span><span class="string">"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#这里是传送的消息</span></span><br><span class="line"><span class="string">data = &#123;</span></span><br><span class="line"><span class="string">    "</span>msgtype<span class="string">": "</span>text<span class="string">",</span></span><br><span class="line"><span class="string">       "</span>text<span class="string">": &#123;</span></span><br><span class="line"><span class="string">           "</span>content<span class="string">": "</span>这里是消息正文！<span class="string">"</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">   "</span>at<span class="string">": &#123;</span></span><br><span class="line"><span class="string"> "</span>atMobiles<span class="string">": [</span></span><br><span class="line"><span class="string">           "</span>A的手机号<span class="string">",</span></span><br><span class="line"><span class="string">"</span>B的手机号<span class="string">"</span></span><br><span class="line"><span class="string">]， </span></span><br><span class="line"><span class="string">           "</span>isAtAll<span class="string">":False   #这里True代表要发给所有人，False的话，要代表消息只发给A和B这两个人</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sendData = json.dumps(data)</span></span><br><span class="line"><span class="string">request = urllib2.Request(url,data = sendData,headers = header)</span></span><br><span class="line"><span class="string">urlopen = urllib2.urlopen(request)</span></span><br><span class="line"><span class="string">print urlopen.read()</span></span><br></pre></td></tr></table></figure></p><p>直接执行这个脚本，就会看到我刚新建的钉钉机器人在群聊里说话了。<br><img src="/images/dingding3.png" alt="paradin"></p><h2><span id="机器人搭配nginx">机器人搭配nginx</span></h2><p>上面那个脚本已经可以初步实现我们的目的，但是有一个缺点，就是正文内容不能过长。但是我想多打印一点日志，至少50行，怎么办？我想了想，可以把日志放进nginx的一个网页里，然后用钉钉机器人反馈这个网页地址啊，这样内容想写多少就可以写多少了。</p><p>假设我现在获取到的日志的文件写进一个叫<code>chairmanmao.html</code>里，在浏览器打开看是这样的：<br><img src="/images/dingding4.png" alt="paradin"></p><p>那么上面那个机器人的python脚本就要改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/python</span></span><br><span class="line">#coding: utf-8</span><br><span class="line"><span class="keyword">import</span> json,urllib2,commands</span><br><span class="line"></span><br><span class="line">commands.getstatusoutput('echo -e "THIS IS TEST MESSAGE！ \n" &gt; /路径/chairmantail.html')#这里可以给网页加一个标题</span><br><span class="line">commands.getstatusoutput('cat /路径/chairmanmao.txt &gt;&gt;  /路径/chairmanmao.html')#这里就是把诗词写进html文件里</span><br><span class="line"></span><br><span class="line">#这里是机器人的webhook地址</span><br><span class="line">url = <span class="string">"https://oapi.dingtalk.com/robot/send?access_token=这里输入你机器人的标识符"</span></span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">    <span class="string">"charset"</span>: <span class="string">"utf-8"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">     <span class="string">"msgtype"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="string">"link"</span>: &#123;</span><br><span class="line">                <span class="string">"text"</span>: <span class="string">"点击网址就可获取到本次日志查询的结果"</span>,</span><br><span class="line">                <span class="string">"title"</span>: <span class="string">"日志查询结果已经生成！"</span>,</span><br><span class="line">                "picUrl": "http://p1x3hd2at.bkt.clouddn.com/nanshen.jpg",#这里可以加一个缩略图片</span><br><span class="line">                <span class="string">"messageUrl"</span>: <span class="string">"http://服务器外网IP地址/chairmanmao.html"</span></span><br><span class="line">    &#125;,</span><br><span class="line">     <span class="string">"at"</span>: &#123;</span><br><span class="line">            "isAtAll":True   # at为非必须</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">sendData = json.dumps(data)</span><br><span class="line">request = urllib2.Request(url,data = sendData,headers = header)</span><br><span class="line">urlopen = urllib2.urlopen(request)</span><br><span class="line">print urlopen.read()</span><br></pre></td></tr></table></figure></p><p>执行这个脚本可以看到机器人发送的信息如下：<br><img src="/images/dingding5.png" alt="paradin"></p><p>然后打开这个网址，就看到完整的网页信息：<br><img src="/images/dingding6.png" alt="paradin"></p><p>到时候把毛主席诗词换成实际的日志文件就好了，不用一口气打印所有的日志出来，<code>tail -n 50 日志文件名</code>，50行足够用了。</p><h2><span id="配置jenkins">配置Jenkins</span></h2><p>脚本写完了，机器人也写完了，这个时候就要添加“启动端”。安装Jenkins的步骤我这里就不写了，直接可以去看<code>https://rorschachchan.github.io/2018/02/05/Jenkins安装与创建简单任务/</code>。现在去登录Jenkins的网页，去添加一个新的Job，比如我这个Job就叫“获取模块日志”，如图：<br><img src="/images/dingding7.png" alt="paradin"></p><p>如果是要在Jenkins上去读取其他服务器的日志，就可以在<code>构建project</code>的时候选择<code>参数化构建过程</code>，然后配置参数ip，到时候把这些ip传递给目标脚本。如果觉得这样hold不住，可以不用jenkins的这个功能，把ip写到脚本里去，一了百了：<br><img src="/images/dingding8.png" alt="paradin"></p><p>在<code>构建</code>那一步，选择<code>Execute Shell</code>，然后里面写上具体的shell命令，如果在上面使用了参数，那么参数就可以在这里使用，我的脚本里是没有ip这个参数的，在图里写<code>$ip</code>就是做一个例子讲解一下用法而已：<br><img src="/images/dingding9.png" alt="paradin"></p><p>在<code>构建后操作</code>这一步可以选择<code>E-mail Notification</code>，这样如果失败了会发送邮件通知。如果用不着就什么都不用选。然后就是保存好这个project，点击左侧菜单栏的<code>立即构建</code>，就会看到下面<code>Build History</code>会多一个<code>#1</code>出来，同时钉钉机器人也在群里发消息，这个<code>#1</code>就是构建的记录，这个纪录多了的话，新纪录会覆盖掉老的记录。<br><img src="/images/dingding10.png" alt="paradin"></p><p>点击这个<code>#1</code>，选择<code>控制台输出</code>，就能看到具体的操作结果了，跟在shell界面里执行的效果差不多的。可见操作成功，目的已经达到了！<br><img src="/images/dingding11.png" alt="paradin"></p><p>以后需要调用脚本，就在手机端浏览器里登陆jenkins，然后构建一下这个project，同时就可以看到钉钉里机器人有反馈了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://xu3352.github.io/linux/2017/05/01/jenkins-restart-remote-server-tomcat" target="_blank" rel="noopener">https://xu3352.github.io/linux/2017/05/01/jenkins-restart-remote-server-tomcat</a><br><a href="https://github.com/typ431127/zabbix_dingding" target="_blank" rel="noopener">https://github.com/typ431127/zabbix_dingding</a></p>]]></content>
    
    <summary type="html">
    
      钉钉机器人要是能发送参数到服务器里然后执行脚本就太好了！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jenkins" scheme="http://yoursite.com/tags/jenkins/"/>
    
      <category term="钉钉" scheme="http://yoursite.com/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>一次官网打不开的经历</title>
    <link href="http://yoursite.com/2018/02/06/%E4%B8%80%E6%AC%A1%E5%AE%98%E7%BD%91%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2018/02/06/一次官网打不开的经历/</id>
    <published>2018-02-06T06:10:12.000Z</published>
    <updated>2018-02-06T06:32:46.175Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天有人反映官网在登陆的时候，chrome浏览器不能正常打开页面，反而会出现一个下载框。我使用IE浏览器尝试登录官网，页面也不是正常的页面，而是下面的内容：<br><img src="/images/guanwang1.png" alt="paradin"></p><p>由于官网的域名跳转是在阿里云的域名解析的地方配置的，于是就登陆到阿里云的域名解析地方，查看了一下发现，这里的配置是<code>www.lechange.com</code>会302跳转到<code>home.lechange.com</code>，而ping一下<code>home.lechange.com</code>得到的ip地址是一个负载均衡的地址，然后在阿里云的控制台查询这个负载均衡的情况，发现这个负载均衡后面挂载的是两台服务器A和B。</p><p>于是我在浏览器里面直接输入负载均衡的ip地址，发现还是像上面那样错误的php界面，而浏览器地址栏使用两个服务器的外网ip却是正常可以打开的。这个时候初步怀疑是SLB的问题，而我当时就觉得就凭上面这一点就去跟阿里撕逼不太妥当，但是事实告诉我们事情不是那么简单的。</p><p>我检查一下slb的端口配置情况，分别是<code>http 80转8080</code>和<code>https 443转80</code>，可见这个网站有两个协议，一个是http的而一个是https的，我们刚才虽然在浏览器里直接使用A和B的外网ip访问是可以正常打开页面，只能说明http协议是OK的，我们还要测试一下https协议访问的效果。</p><p>我就在浏览器地址栏里进一步尝试，发现使用<code>A外网ip：8080</code>访问是OK的，而使用<code>B外网ip：8080</code>访问就是PHP的文字界面。于是基本问题定位到B服务器里有文件的配置错误。</p><p>登陆到B服务器里，在nginx的conf文件夹里发现一个多余的文件，打开内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server </span><br><span class="line">&#123; </span><br><span class="line">       listen       <span class="number">8080</span>; </span><br><span class="line">       server_name  www.lechange.com (file:<span class="comment">//www.lechange.com/) www.lechangebuy.com (file://www.lechangebuy.com/); </span></span><br><span class="line">       index index.html index.htm index.php; </span><br><span class="line">       root  /data/www/ecstore; </span><br><span class="line">       add_header  pos <span class="string">'web2'</span>; </span><br><span class="line">#       location / &#123; </span><br><span class="line">#               rewrite ^/(.*)$ https://www.lechangebuy.com/$1; </span><br><span class="line">#       &#125; </span><br><span class="line">       location /public &#123; </span><br><span class="line">               root  /data/www/ecstore; </span><br><span class="line">       &#125; </span><br><span class="line">       access_log /data/logs/nginx/access.log; </span><br><span class="line">#access_log off; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而原来nginx是有正常的conf文件，现在又多余了一个这个文件，可见是因为没有无法正常解析.php的文件，两个文件都在占用8080端口时出现了冲突，所以就导致这样php download界面的情况。删除这个多余的文件后，重启nginx，清除浏览器缓存，再重新尝试就正常打开页面了。</p><p>为什么会多一个这样的文件，后来把各位运维人员严刑拷打一顿才知道，原来有一次某运维小弟在B服务器里面做跳转的测试，测试完毕之后忘记了把这个多余的文件删除，原本这一切是没有问题的，但是可能服务器nginx经历了重启，于是就加载了这两个conf文件，就把这个隐藏的问题暴露了。</p>]]></content>
    
    <summary type="html">
    
      想要说平时工作千万别留坑，不然害的就是自己啊
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>往github里上传代码</title>
    <link href="http://yoursite.com/2018/02/05/%E5%BE%80github%E9%87%8C%E4%B8%8A%E4%BC%A0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2018/02/05/往github里上传一个代码/</id>
    <published>2018-02-05T14:40:22.000Z</published>
    <updated>2018-02-06T02:14:59.815Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>说来惭愧，使用hexo博客这么久了，但是真正使用github保存代码却是第一次。因为要打算自己搞一个jenkins试试自动化部署，所以就打算把我那些不堪入目的代码放在github上，然后用jenkins去执行。今天这篇文章就是来记录如何把本地的代码文件上传到github上的过程，本次过程是在windows下操作的。</p><h2><span id="建立远端仓库">建立远端仓库</span></h2><p>首先登录github的界面，然后建立一个新的仓库（repository），如图：<br><img src="/images/github3.png" alt="paradin"></p><p>在建立仓库的时候，要注意最好选择一下<code>Initialize this repository with a README</code>这个选项，这样可以省去一些麻烦，如图：<br><img src="/images/github4.png" alt="paradin"></p><p>在这里就用我刚建立的仓库—<code>chentest</code>。</p><h2><span id="建立本地仓库">建立本地仓库</span></h2><p>首先我们先去<code>http://windows.github.com/</code>上下载git工具，在安装的时候你还可以顺便登陆，如果没有github账号的话这一步可以跳过的。<br><img src="/images/github1.png" alt="paradin"></p><p>安装完毕你的鼠标右键应该多了一个功能<code>Git Bash Here</code>，此时，可以在电脑找一个文件夹，这个文件夹不推荐安装在C盘，假设我就在E盘根目录下叫<code>chentest</code>的文件夹，这个文件夹名称应该与我们刚刚建立的github仓库名称相同。不然的话，可能在git pull的时候爆<code>fatal: refusing to merge unrelated histories</code>这个错误。</p><p>在这个chentest的空文件夹空白处，右键鼠标，然后选择<code>Git Bash Here</code>，就会出现一个类似dos的命令行窗口，此时需要输入<code>git init</code>，这个时候发现chentest文件夹里多一个隐藏文件叫<code>.git</code>，这就代表本地仓库已经创建成功了。</p><h2><span id="配置公私钥">配置公私钥</span></h2><p>然后就是建立一个SSH key，以后你上传任何东西到远端仓库的时候都要输入这个key，那么在命令窗口输入<code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code>，此时会让你输入一个文件路径，这个路径就是存放SSH key公钥和私钥的地方，由于我这个电脑已经在默认的<code>/c/user/33664/.git/id_rsa</code>已经存放了hexo博客的上传密钥了，于是我就手动把路径改成了<code>/c/user/33664/.git/id_rsa-github</code>，如图：<br><img src="/images/github2.png" alt="paradin"></p><p>这里注意！<font color="red">如果你也之前有一个git id_rsa密钥的话，我个人强烈推荐这个密钥跟之前的id_rsa密钥是一样的。</font></p><p>在浏览器里返回到github的<code>settings</code>主页，在<code>SSH and GPG keys</code>里点击<code>New SSH key</code>，然后就把刚刚生成密钥的pub版输入进去，这个公钥是可以告诉别人的，但是私钥要保密好。如图：<br><img src="/images/github5.png" alt="paradin"></p><p>再命令行里输入<code>ssh -T git@github.com</code>，这时候会让你输入一下<code>/c/user/33664/.git/id_rsa</code>的密钥，由于我刚刚把id_rsa-github密钥和id_rsa密钥内容是一样的，所以就输入正确了。如图：<br><img src="/images/github6.png" alt="paradin"></p><h2><span id="进一步配置">进一步配置</span></h2><p>此时，再在命令行里输入如下的语句：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"your name"</span></span><br><span class="line">git config --global user.email <span class="string">"your_email@youremail.com"</span></span><br><span class="line">git remote add origin git@github.com:用户名/Git仓库名称.git#我这个例子里就是chentest.git</span><br><span class="line">git config branch.master.remote origin  </span><br><span class="line">git config branch.master.merge refs/heads/master</span><br></pre></td></tr></table></figure></p><p>一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。</p><p>加完之后进入<code>.git</code>，打开<code>config</code>，这里会多出一个<code>remote “origin”</code>内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。如图：<br><img src="/images/github7.png" alt="paradin"></p><h2><span id="下载与上传">下载与上传</span></h2><p>由于这次是我们第一次上传，那么按照惯例，我们需要先下载一下，使用<code>git pull origin master --allow-unrelated-histories</code>，然后输入<code>id_rsa密钥</code>，看见chentest就多了那个<code>README.md</code>文件了。把这个<code>README.md</code>文件改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chentest</span><br><span class="line">这是一个做测试的仓库，做好了之后，就先尝试把代码传上去，然后结合Jenkins来搞！</span><br></pre></td></tr></table></figure></p><p>同时也写一个新的代码，比如这个文件就叫<code>test1.md</code>，里面内容是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">echo <span class="string">"hello,chrisChan!"</span></span><br><span class="line">echo <span class="string">"this is your first git"</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure></p><p>这个shell脚本内容就是输出两个废话，然后打印ip地址。保存<code>test1.md</code>，然后在命令行里输入如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br><span class="line">git commit -m "提交注释"#这个注释内容是会在网站上体现出来的</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p><code>git push</code>命令会将本地仓库推送到远程服务器，而之前说过的<code>git pull</code>命令则相反。同样的输入<code>id_rsa密钥</code>，然后就会看到文件成功上传了！如图：<br><img src="/images/github8.png" alt="paradin"></p><p>来到github网站里一看，果然刚刚写的那个<code>test1.md</code>出现了，如图：<br><img src="/images/github9.png" alt="paradin"></p><h2><span id="结语">结语</span></h2><p>通过刚才的操作，我想各位应该对github操作有一点初步的了解。其实Git命令行是一个版本控制工具，Github是一个用Git做版本控制的项目托管平台。形象解释的话Git相当于是弓，GitHub是靶，你的代码是箭，弓把箭射到靶上。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.jianshu.com/p/0fce531dba31" target="_blank" rel="noopener">https://www.jianshu.com/p/0fce531dba31</a><br><a href="http://blog.csdn.net/zhangmingbao2016/article/details/73478899" target="_blank" rel="noopener">http://blog.csdn.net/zhangmingbao2016/article/details/73478899</a><br><a href="http://www.cnblogs.com/findingsea/archive/2012/08/27/2654549.html" target="_blank" rel="noopener">http://www.cnblogs.com/findingsea/archive/2012/08/27/2654549.html</a></p>]]></content>
    
    <summary type="html">
    
      学习了github就更像一个程序员了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins与Github组合成持续集合环境</title>
    <link href="http://yoursite.com/2018/02/05/Jenkins%E4%B8%8EGithub%E7%BB%84%E5%90%88%E6%88%90%E6%8C%81%E7%BB%AD%E9%9B%86%E5%90%88%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/02/05/Jenkins与Github组合成持续集合环境/</id>
    <published>2018-02-05T09:12:22.000Z</published>
    <updated>2018-02-05T13:55:52.766Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="生成token码">生成Token码</span></h2><p>首先登录github，在首页选择<code>settings</code>，如图：<br><img src="/images/jenkins12.png" alt="paradin"></p><p>然后点击最下面的<code>Developer settings</code>，点击<code>Personal access tokens</code>，最后点击<code>Generate new token</code>，如图：<br><img src="/images/jenkins13.png" alt="paradin"></p><p>输入名称和权限，权限选择<code>repo</code>和<code>admin:repo_hook</code>这俩，如图：<br><img src="/images/jenkins14.png" alt="paradin"></p><p>然后就会生成一个<code>token密码</code>，这个<code>token密码</code>请妥善保存，丢失或者删除就GG了。<br><img src="/images/jenkins15.png" alt="paradin"></p><h2><span id="将token码配置到jenkins">将Token码配置到Jenkins</span></h2><p>浏览器返回到Jenkins界面，在首页里点击<code>系统管理</code>，然后选择<code>系统配置</code>，在系统配置里面添加一个<code>GitHub Servers</code>，在<code>Add Credentials</code>这一步的时候，要把<code>kind</code>改成<code>Secret text</code>，如图：<br><img src="/images/jenkins17.png" alt="paradin"></p><p>这里<code>Secret</code>的地方就是填写刚刚生成的Token码。</p><p>保存之后，点击一下<code>test connection</code>，如果出现<code>Credentials verified for user xxx, rate limit: xxx</code>的字样就是成功了，如图：<br><img src="/images/jenkins19.png" alt="paradin"></p><h2><span id="设置webhooks">设置webhooks</span></h2><p>在github里找一个源码库，选择<code>settings</code>，然后点击小菜单栏里的<code>Webhooks</code>，再点击右边的<code>Add Webhook</code>即可，如图：<br><img src="/images/jenkins16.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这样就与Github紧密相连了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins的安装与创建简单任务</title>
    <link href="http://yoursite.com/2018/02/05/Jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/02/05/Jenkins安装与创建简单任务/</id>
    <published>2018-02-05T03:23:04.000Z</published>
    <updated>2018-02-05T09:31:07.519Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装与启动">安装与启动</span></h2><p>环境：<code>CentOS 7.0</code> + <code>java 1.8</code></p><p>安装方式：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-fastestmirror -y  #安装自动选择最快源的插件</span><br><span class="line">#添加Jenkins源:</span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo http:<span class="comment">//jenkins-ci.org/redhat/jenkins.repo</span></span><br><span class="line">sudo rpm --<span class="keyword">import</span> http:<span class="comment">//pkg.jenkins-ci.org/redhat/jenkins-ci.org.key</span></span><br><span class="line">yum install jenkins               #安装jenkins</span><br></pre></td></tr></table></figure></p><p>启动方式：<code>sudo service jenkins start</code>，如果没有java是无法启动的。</p><p>Jenkins默认端口是<code>8080</code>，如果要更改端口，需要先<code>vim /etc/sysconfig/jenkins</code>，然后修改<code>JENKINS_PORT=&quot;8080&quot;</code>为自己想要的端口号即可。</p><p>访问方式：浏览器输入<code>http://your server ip:8080/</code>，然后会看到这样的一个界面，打开这个文件，输入里面的key就可以访问jenkins了。<br><img src="/images/jenkins1.png" alt="paradin"></p><p>然后就是让你安装插件，如果是新手的话，可以安装系统推荐的插件，如果插件安装失败不要怕，可以日后手动补上。<br><img src="/images/jenkins2.png" alt="paradin"></p><p>插件安装完毕之后，就是自己创建一个管理员账号和密码，输入之后，点击右下角<code>保存并完成</code>。<br><img src="/images/jenkins3.png" alt="paradin"></p><p>然后就可以看到Jenkins初始化的首页。<br><img src="/images/jenkins4.png" alt="paradin"></p><h2><span id="创建任务">创建任务</span></h2><p>假设现在要创建一个Job(任务)，这个任务就是输出当前服务器的外网IP地址，那么就点击首页里的<code>新建任务</code>，然后输入任务名，补充一句，生产环境里的Job名最好不用中文，不做死就不会死，然后选择<code>构建一个自由风格的软件项目</code>，如图：<br><img src="/images/jenkins5.png" alt="paradin"></p><p>在<code>源码管理</code>的地方，我们暂时选择<code>None</code>，待日后把jenkins与github相关联之后，就可以通过github来配置源码了。在<code>构建触发器</code>的地方，我们选择<code>Poll SCM</code>，这里说一下这几个触发器选项的意思：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Build after other projects are built：</span><br><span class="line">Build periodically ： 周期进行项目构建（它不关心源码是否发生变化），可以配置如下：<span class="number">0</span> <span class="number">2</span> * * *（每天<span class="number">2</span>:<span class="number">00</span> 必须build一次源码）</span><br><span class="line">Build when a change is pushed to GitHub： 只要github上有提交了，jenkins没有自动检测到并构建，这设置之后在github中也需要设置才能生效</span><br><span class="line">Poll SCM：定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作。可以配置如下：*<span class="regexp">/10 * * * *  （每5分钟检查一次源码变化）</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/jenkins6.png" alt="paradin"></p><p><code>构建步骤</code>这里有很多的选项，我们选择<code>Execute Shell</code>，里面可以写shell命令也可以写shell脚本，这里我就写入一个很简单的ifconfig命令去查看一下IP地址，如图：<br><img src="/images/jenkins7.png" alt="paradin"></p><p><code>构建后操作</code>这里也有很多的选项，这里我选择<code>E-mail Notification</code>，然后输入自己的邮箱地址，这样如果构建失败了，就可以发邮件提醒。如图：<br><img src="/images/jenkins8.png" alt="paradin"></p><p>配置完毕之后，点击左下角<code>保存</code>即可。</p><h2><span id="查看任务效果">查看任务效果</span></h2><p>返回到Jenkins的首页，我们看到多了那个刚才新建的任务，然后点击任务名旁边的小三角，选择<code>立即构建</code>，如图：<br><img src="/images/jenkins9.png" alt="paradin"></p><p>然后就会看到构建的历史，点击任意历史记录的<code>控制台输出</code>，就会看到效果，的确是操作了<code>ifconfig</code>命令的效果：<br><img src="/images/jenkins10.png" alt="paradin"><br><img src="/images/jenkins11.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      为了自动化部署和持续集成
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper集群的搭建与配置</title>
    <link href="http://yoursite.com/2018/02/05/Zookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/02/05/Zookeeper集群的搭建与配置/</id>
    <published>2018-02-05T02:15:21.000Z</published>
    <updated>2018-02-05T02:59:42.207Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Zookeeper的下载地址：<code>https://github.com/apache/zookeeper/archive/master.zip</code><br>zkclient的下载地址：<code>https://github.com/sgroschupf/zkclient</code></p><p>至于zookeeper的作用和原理我这里就不多赘述了，大家有兴趣可以去查查，这里主要就是动手操作。</p><h2><span id="搭建集群">搭建集群</span></h2><p>首先先看一下本次zk实验服务器的名称和IP情况，这里我们选择了三台服务器作zkserver，因为三台是标配，一台的话就只有leader没有follower，不是很稳定的结构，当然啦如果你的公司土豪的话是可以玩三十台：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dvl-mrszk<span class="number">-001</span><span class="number">10.117</span><span class="number">.0</span><span class="number">.125</span></span><br><span class="line">dvl-mrszk<span class="number">-002</span><span class="number">10.117</span><span class="number">.1</span><span class="number">.158</span></span><br><span class="line">dvl-mrszk<span class="number">-003</span><span class="number">10.168</span><span class="number">.152</span><span class="number">.227</span></span><br></pre></td></tr></table></figure></p><p>对这三台服务器都要进行如下的步骤:</p><p>1)先把zookeeper.zip传到linux里，然后解压到<code>/usr</code>文件夹下；</p><p>2)进入<code>/usr/zookeeper/conf</code>文件夹，<code>vim zoo.cfg</code>，在最下面补充上面的三个zkserver，见图：<br><img src="/images/zook1.png" alt="paradin"></p><p>3)再来到<code>/usr/zookeeper/data</code>文件夹，如果里面有文件就清空所有文件，如果是1号zkserver就<code>echo 1 &gt; myid</code>，如果当前机器是2号zkserver就<code>echo 2 &gt; myid</code>，依次类推，这里一定要注意，不可以都写一样。</p><p>4)<code>vim /etc/hosts</code>，还要把这三台机器的ip地址和名字都写进去，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line">::<span class="number">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"><span class="number">10.117</span><span class="number">.0</span><span class="number">.125</span> dvl-mrszk<span class="number">-001</span></span><br><span class="line"><span class="number">10.117</span><span class="number">.1</span><span class="number">.158</span> dvl-mrszk<span class="number">-002</span></span><br><span class="line"><span class="number">10.168</span><span class="number">.152</span><span class="number">.227</span> dvl-mrszk<span class="number">-003</span></span><br></pre></td></tr></table></figure></p><p>5)再来<code>/usr/zookeeper/bin</code>文件夹，<code>./zkServer.sh start</code>启动zk，然后再<code>./zkServer.sh status</code>查看进程情况，如图看见第一台和第三台zkserver的身份是<code>follower</code>，第二台是<code>leader</code>：<br><img src="/images/zook2.png" alt="paradin"></p><p><img src="/images/zook3.png" alt="paradin"></p><p><img src="/images/zook4.png" alt="paradin"></p><p>至此整个zk集群就搭建并且启动完成了。</p><font color="red">注意：zookeeper集群时，zookeeper要求半数以上的机器可用，zookeeper才能提供服务。</font><p>如果这里有启动失败的情况，比如<code>Error contacting service. It is probably not running.</code>这样的字样，那么有这么几种可能：</p><p>1）data文件夹下的<code>myid</code>有数字重复或者是数字漏写的情况；</p><p>2）<code>zoo.cfg</code>里的指定日志文件夹没有手动创建；</p><p>3）<code>/etc/hosts</code>下的名字与zoo.cfg里的server字段不相符，注意一下，/etc/hosts里的127.0.0.1的名字不要与本ip后面的名字一模一样，不然zk也无法识别！</p><p>4）<code>/etc/hosts</code>名字使用了中文，java系对中文是很不友好的。</p><h2><span id="配置文件详解">配置文件详解</span></h2><p>1.<code>tickTime</code>：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。<br>2.<code>dataDir</code>：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。<br>3.<code>clientPort</code>：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。<br>4.<code>initLimit</code>：这个配置项是用来配置 Zookeeper 接受 客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5<em>2000=10秒。<br>5.<code>syncLimit</code>：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是2</em>2000=4秒。<br>6.<code>server.A=B：C：D</code>：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p><h2><span id="验证成果">验证成果</span></h2><p>Zookeeper的配置工具叫<code>Zooinspector</code>，下载地址是：<code>https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</code>，下载完直接解压缩就可以在windows里使用。</p><p>我们实验的这三台服务器只有内网，但是如果要连接zooinspector，还是需要通过外网权限连接的，这里可以配一个iptables转发规则，配iptables的步骤在这里：<a href="http://chenx1242.blog.51cto.com/10430133/1875950" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1875950</a> ，照葫芦画瓢即可，但是要注意，zk的端口是<code>2181</code>。</p><p>当然，如果不想费事的话，就直接给zkserver配一个外网IP，直接连接。</p><p>成功连接到<code>zooinspector</code>，就会看到这样的内容，这里的lcconfig是手动添加的，右击鼠标，选择<code>add node</code>，然后直接写上<code>lcconfig</code>就行，这个名字是根据实际需要填写的：</p><p><img src="/images/zook5.png" alt="paradin"></p><p>上面我们已经配置了zkserver集群而且还启动zkserver进程，现在还需要zkclient，zkclient就是请求发起的一方，然后我们可以在各个的模块服务器上部署zkclient服务，通过启动zkclient服务，来让这些模块统一从zooinspector里取值，这样就达到了批量配置，同时保证一致性的效果。</p><p>zk的模板文件是<code>_tpl.properties</code>为结尾的文件，我这里模块的名字叫mrs，那么在实验里这个模板文件就是<code>mrs_tpl.properties</code>，这个<code>mrs_tpl.properties</code>里有这样的一个字段，如图：</p><p><img src="/images/zook6.png" alt="paradin"></p><p>而我们在zooinspector里对应就这么填写：</p><p><img src="/images/zook7.png" alt="paradin"></p><p>保存zooinspector，然后从windows返回到linux，启动zkclient服务和对应的模块进程，如果配置都正常的话，那么程序就会正常启动，<code>ps -ef|grep java</code>就会看到一个叫<code>lczk.AppServerDaemon</code>的进程。这个时候在去看一下mrs的配置文件：</p><p><img src="/images/zook8.png" alt="paradin"></p><p>可以看到areaAk取得值就是zk里面<code>data_center</code>里面<code>access_key</code>里面的ak的值，其他的几个值也是同理。可见整个zk已经配置成功，模块都进行了统一配置，而且这些配置既然能被一个接受，同时也会被其他相同的模块服务器所接受。这样就达到了批量配置的效果。</p><h2><span id="拓展阅读">拓展阅读</span></h2><p><a href="http://ibruce.info/2014/10/23/zookeeper/" target="_blank" rel="noopener">http://ibruce.info/2014/10/23/zookeeper/</a></p>]]></content>
    
    <summary type="html">
    
      纵然你的身子骨是铁打的，我想你也需要了解一款“实现同步服务，配置维护和命名服务”的东西吧。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Uwsgi的安装和简单使用</title>
    <link href="http://yoursite.com/2018/02/02/Uwsgi%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/02/Uwsgi的安装和简单使用/</id>
    <published>2018-02-02T10:41:29.000Z</published>
    <updated>2018-02-02T10:50:19.673Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>运维平台的搭建已经提上日程，而我选用了大家比较常用的<code>Uwsgi+nginx+django</code>的架构，这里先记录一下安装Uwsgi的过程。</p><p>这里解释一下<code>Uwsgi+nginx+django</code>，我们整个流程如下图：<br><img src="/images/uwsgi1.png" alt="paradin"></p><p>这里我们可以看出，web server是无法与我们的app（django等等）进行直接对话，他需要通过uwsgi这个桥梁，这个桥梁很重要，虽然我们使用django的<code>runserver</code>功能也会打开一个页面，但是这个页面是很脆弱的，小规模使用还好，要是放在网络上供很多人点击的话，根本就是脆不经风。</p><p>uwsgi是啥，请查看文末的参考资料，写的已经非常好了。我这里就简单说下：</p><blockquote><p>uwsgi 实际上也是一个http服务器，只不过它只面向python网络应用程序。虽然uwsgi也是http服务器，但是却不能直接使用它部署python web应用程序，否则会出错。</p><p>在本文中，uwsgi所扮演的的角色是后端http服务器，nginx扮演的角色是前端http服务器，<code>hello.py</code>是客户端应用程序。用户从网页浏览器中发出请求，nginx服务器收到请求后，会通过它的uwsgi模块将用户的请求转发给uwsgi服务器，uwsgi服务器处理完毕后将结果返回给 nginx，浏览器将最终的结果展现给用户。</p></blockquote><p>Uwsgi的安装比较简单，推荐使用<code>yum install Uwsgi</code>直接下载使用，而不推荐用<code>pip install uwsgi</code>，因为pip安装的话，虽然也能成功（如下图红框），是没有<code>uwsgi.ini</code>文件的，其实没有这个<code>uwsgi.ini</code>是无足轻重的，因为这个文件可以自己写，但是对于生手来说，没有这个文件可能会心里发毛，就无法按照攻略继续下去，所以我更推荐用yum安装，如图：<br><img src="/images/uwsgi2.png" alt="paradin"></p><p>为了纪念我们的金刚狼同志，我们就写一个叫<code>logan.py</code>，里面的内容是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def application(env, start_response):</span><br><span class="line">       start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"good bye,Logan..."</span></span><br></pre></td></tr></table></figure></p><p>然后我们就可以启动这个<code>uwsgi</code>看看效果，使用<code>uwsgi --http :8001 --wsgi-file logan.py</code>，把端口设定为<code>8001</code>，同时指定协议是<code>http</code>，然后加载的文件就是<code>logan.py</code>，启动之后，如图：<br><img src="/images/uwsgi3.png" alt="paradin"></p><p>遇到这种情况，你就<code>yum install uwsgi-plugin-python</code>，然后把命令做一点点修改，改成：<code>uwsgi --plugin python --http-socket :8001 --wsgi-file logan.py</code>。</p><p>屏幕会出现一大堆文字，然后提示，uwsgi已经启动成功了。在浏览器输入<code>服务器外网地址:8001</code>看一下效果，如图：<br><img src="/images/uwsgi4.png" alt="paradin"></p><p>我们在root目录下再写一个测试的文件，这次我们写一个比较老实的python脚本来测试，这个脚本就叫<code>test.py</code>，里面的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">def application(environ, start_response):</span><br><span class="line">       status = <span class="string">'200'</span></span><br><span class="line">       output = <span class="string">'this is a test for uwsgi,HOHO~'</span></span><br><span class="line">       response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>),(<span class="string">'Content-Length'</span>, str(len(output)))]</span><br><span class="line">       start_response(status, response_headers)</span><br><span class="line">       <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></p><p>还是用刚才的方法，依旧可以打开网页，其实上面这个简单的<code>uWSGI</code>程序更好理解整个套路，只需要实现一个名为<code>application</code>的函数就可以了，该函数有两个参数，<code>environ</code>为包含有<code>http</code>请求的环境变量，<code>start_response</code>为一个函数，用来设置http头。在这个函数里，我们只需要调用一次<code>start_response</code>函数，设置一下<code>HTTP</code>返回头，再<code>return</code>一个<code>HTTP body</code>即可。</p><p>至此，整个uwsgi就安装成功了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://xiaorui.cc/2017/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3uwsgi%E5%92%8Cgunicorn%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8A/" target="_blank" rel="noopener">http://xiaorui.cc/2017/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3uwsgi%E5%92%8Cgunicorn%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8A/</a><br><a href="http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html" target="_blank" rel="noopener">http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html</a></p>]]></content>
    
    <summary type="html">
    
      Uwsgi+nginx+django，光搭建一个框架就要了我的老命...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="uwsgi" scheme="http://yoursite.com/tags/uwsgi/"/>
    
  </entry>
  
  <entry>
    <title>从excel的大单元格里快速提取内容</title>
    <link href="http://yoursite.com/2018/02/01/%E4%BB%8Eexcel%E7%9A%84%E5%A4%A7%E5%8D%95%E5%85%83%E6%A0%BC%E9%87%8C%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2018/02/01/从excel的大单元格里快速提取内容/</id>
    <published>2018-02-01T02:42:54.000Z</published>
    <updated>2018-02-05T04:24:46.685Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我公司的服务器信息会保存在一份高加密的excel里，由于历史遗留问题，里面的格式节选一部分出来是这样的：<br><img src="/images/excel1.png" alt="抱光妹"></p><p>注意看，ip地址不分内网外网是放在一个大的单元格里，中间是用空格隔开的，造成了这样的视觉效果。</p><p>现在公司需要把所有的服务器重新更换到新的zookeeper，那么使用ansible在批量处理的时候，就需要提取这些服务器的内网ip地址录入到<code>/etc/hosts</code>文件里，但是由于服务器实在太多不可能一个一个手动从excel的单元格挑选出“内网IP地址”复制粘贴，那么就需要进行一下批量挑选内网IP地址的操作。</p><p>首先我们先把整个IP的单元列里的”（公）””（内）”的字样去掉，然后把整列全部拷贝，粘贴到<code>notepad</code>里，看到它们变成了这样的样子：<br><img src="/images/excel2.png" alt="抱光妹"></p><p>在<code>notepad</code>里，双引号之间的内容会被认为同一行，所以这里我们需要使用“替换”功能把所有的双引号去掉，让它变成下面这样：<br><img src="/images/excel3.png" alt="抱光妹"></p><p>这样就可以把上面的内容复制到一个新的excel去，发现每一个内容对应了一行，即一个小单元格：<br><img src="/images/excel4.png" alt="抱光妹"></p><p>然后我们把第一行染成黄色，第二行染成绿色，当然颜色你可以选择自己的口味，然后使用excel的“格式刷”功能，一拉到底，让他们变成条纹状：<br><img src="/images/excel5.png" alt="抱光妹"></p><p>然后在excel里找到“筛选”功能，先选择住这一条纹块，然后选择“按颜色筛选“，由于我们需要内网IP，那么我们就留下绿色内容即可，如图：<br><img src="/images/excel6.png" alt="抱光妹"></p><p>得到效果如下：<br><img src="/images/excel7.png" alt="抱光妹"></p><p>这样就可以把整个内容拷贝进ansible的hosts文件里，然后搭配ansible批处理这些内网IP，双管齐下，大大的提升了提取数据的效率。</p><p>如果遇到偶尔三行（即中间有空格行）的情况，那么就在notepad那一步的时候，把空格行干掉，不如下图的情况里，第五行和第八行是空格行，可能是当初记录人员复制的时候自带了空格：<br><img src="/images/excel8.png" alt="抱光妹"></p><p>如果是空格很多的情况，那么就需要批处理一次性的把所有空格都干掉。干掉的方法，还是使用notepad的“替换功能”，选择“正则表达式”，然后把<code>\n[\s|]*\r</code>替换成空值就可以了。<br><img src="/images/excel9.png" alt="抱光妹"></p>]]></content>
    
    <summary type="html">
    
      没想到我的这个博客里还需要写office的操作小技巧，真是太惊喜太意外了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
      <category term="excel" scheme="http://yoursite.com/tags/excel/"/>
    
  </entry>
  
  <entry>
    <title>再见，魔兽世界</title>
    <link href="http://yoursite.com/2018/02/01/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2018/02/01/再见，魔兽世界/</id>
    <published>2018-02-01T01:56:20.000Z</published>
    <updated>2018-02-02T10:35:31.158Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"></div><script>var ap = new APlayer({element: document.getElementById("aplayer0"),narrow: false,autoplay: false,showlrc: 0,music: {title: "暴风城主题音乐",author: "World of Warcaft",url: "http://p1x3hd2at.bkt.clouddn.com/stormwind.mp3",pic: "http://p1x3hd2at.bkt.clouddn.com/wow.jpg",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><p>这张月卡马上就要用完了，我想我的《魔兽世界》生涯也要到头了。</p><h2><span id="地球时代">地球时代</span></h2><p>我是从大学的时候就开始接触《魔兽世界》，当时是在同寝的xur同学的推荐下，注册账号买了CDKey，然后跟着他在六区黑翼之巢创建了角色，那是一个留着武士头和山羊胡的暗夜精灵德鲁伊，起了个带有劲舞团性质的ID叫“删除过去”。记得德鲁伊刚出生是人形态，泰达希尔里背着一个木棒棒，靠着“愤怒”这个技能打人。于是乎，我就搓出了一个又一个原谅色的冲击波，波遍了泰达希尔的每一个角落，波倒了一个又一个萨特和野熊。当时我作为一个萌新，什么都不懂，后来在一个另外的德鲁伊的帮助下，开始做任务升级，顺便粗略的了解了魔兽最基本的操作。这个德鲁伊是我在游戏里认识的第一个朋友，是一个萌妹子，ID叫什么我忘了，不过后来她游戏上的很少了，依稀记得后来某一个半夜我在西瘟疫之地变成小豹子一个一个挠亡灵的时候，她上过一次线，等级好像是20~30级的样子，我俩说了一会话，具体说的是什么我已经记不清了，那就是我俩最后一次说话。</p><p>从泰达希尔港出来，我就开始了艾泽拉斯的冒险之路：去月光林地学变熊变豹子，拖尸到血色修道院，打过那么一两次诺莫瑞根，在荆棘谷的森林里穿梭，长期蹲在塔纳利斯刷“XD求组祖尔法拉克”。</p><p>当时寝室里没有电脑装wow，总去学府三和学府四那两条街的网吧玩，就这样我成了被盗号的重灾户。记得最过分的那次上号发现角色干脆消失了，还有一回上号发现，角色被扒的就剩下一个裤衩、一个披风和一个狼头样子的皮甲头，还别说，这造型跑出去比较拉风。后来九城推出了密保卡，就是充值卡后面的8x8的数字卡，虽然有一小段时间遏制了盗号，不过缺点就是要随身带着密保卡。在网吧开机坐下了发现没带密保卡，又跑回寝室取卡的事情，我当初可没少干。</p><p>这个德鲁伊就这样摸爬滚打到了六十级满级的时候，开始刷三大本（前后斯坦索姆，通灵学院，黑石塔上层），那时候的黑下是一个冷门本，黑石深渊更不要说了，打一次就花费了几乎一下午的时光。那段反复的刷斯坦索姆和通灵学院的日子给银色十字军捐过不少亡灵印记。后来加入了工会跟工会开始打熔火之心，记得公会团长叫火枪队长，一个男人类战士，其他的一团的队员我现在还能记住名字的有：京乐春水（德鲁伊）、Hater（女人类牧师），魂之血杀（暗夜大元帅战士）。那时候的MC已经没有DOT限制了，但是还要做水元素任务，带着圣水去灭火。接触的第一个G团是祖尔格拉布，当时德鲁伊是一个稀缺职业，我就开始去打工兼消费挣俩小钱，用那点G去买拍爪子的材料。在祖格G团认识了同大学的一个哥们，叫阿尔萨斯之心，是一个女人类圣骑士，他那个时候就有祖格龙了，但是没玩太久，60级没完事就把号给卖了…MC通了后，公会团开始打黑翼之巢，我记得当时的BWL老1还有BUG，远程和治疗可以跳在窗户上。到了老2就卡的死去活来，好不容易过了老2，接下来的三个就一片通途。然后又花了一个晚上打掉了克洛玛古斯。我那时候奈法利安和克洛玛古斯打得不多，仅有的几次击杀也没有掉落怒风胸和怒风肩，这成了我60级的一个怨念。</p><p>在打BWL的时候，安其拉版本已经开始了。G团也开始做安其拉废墟的生意，我也在其中一次无疤者奥斯利安的身上得到了废墟法杖，换掉了之前埃克索图斯的挖掘锤，为了这个废墟法杖我还卖了一张卡，那时候一张卡是300G，那次好像是我唯一的一次卖卡。说到卖卡我想起来，我人生的第一只千金虎是一个暗夜盗贼赞助的，ID好像叫小什么哥，当时的G真的很值钱，非常非常感谢他。</p><p>我在地球时代RAID的最高纪录就是安其拉神殿到公主、NAXX打了蜘蛛区前二、DK区到了老1、憎恶区的帕奇维克好像是没过，反正就是一个很一般的进度啦。然后公会团就有了一些动荡，我个人总觉得德鲁伊打人不爽，还是拿起大刀砍人过瘾，于是就开始了玩战士小号的生涯，ID叫燕小鱼。战士满级后不久就开了“远征前夕”，也就是那个全民刷战场换大元帅的时代。我那时候也在YY里加入了联盟军校，开始了没日没夜刷大奥的日子，先换了猪头锤，又换了雷矛羊，最后拿着一堆牌子去换一身漂亮的大元帅，直到现在我的YY名称依旧是以“联盟军校”开头。</p><p>我玩战士的时候还认识了一个男矮人牧师，叫赤红丹朱，这个哥们手法很骚，以前是玩部落的，记得有一次我俩要去荒芜之地，在莫高雷的高原上，他说这里曾经是他玩部落开始的地方，然后看着脚下这片大草原心潮澎湃，我俩一起战斗过不少副本，从斯坦索姆到祖尔格拉布，他没有坚持到70级就不玩了，账号也给我了…我后来去他的新浪博客看过，背景音乐是王若琳的《有你的快乐》，后来的某一天，发现他的新浪博客内容就被全删光了。</p><h2><span id="燃烧的远征">燃烧的远征</span></h2><p>记得那是7月份，大二刚开学没多久，我就穿过黑暗之门开始了燃烧的远征。那时候我先升的是战士，在地狱火堡垒里面拿大砍刀砍来砍去。七十级的raid就是先从卡拉赞开始，当时我的小战士就当主t，当时跟的团团长ID是叫小豆宝宝，一个侏儒术士。那时候卡拉赞的bug很多，埃兰可以卡门，马克扎尔王子也可以卡地点。我个人对于卡拉赞比较有印象的是虚空龙，那是这个十人小团队一个比较有成就感的boss。</p><p>往后就是打格鲁尔，那个时候我记得隔壁寝室的老朱已经开始练他的女暗夜盗贼了，那个时候我俩开始比较频繁的厮混在一起，肩并肩的不上课跑去网吧打魔兽，我印象最深的一次就是他当时为了刷一个午夜护腿在沙塔斯找了一个猎人，但是这个猎人不是很靠谱，在奴里围栏一个人忙乎从早上八点到晚上八点，结果还没出，给老朱气得牙痒痒。</p><p>TBC的时候，就有了日常任务的概念，每天早上要做奥格瑞拉和虚空龙任务，后来又有了奎岛日常，日复一日的刷声望。玛瑟里顿这个副本公会团当时没有正经打，直接就开始打风暴要塞，当时打掉了凤凰和奥术师和机器人。而毒蛇神殿我跟公会打得不多，记得有打过瞎子外加鱼斯拉。这个时候，邪神禁地祖阿曼上线了，开始了有事没事冲箱子的新征程。我印象里整个70级就是一个很多bug的版本，祖阿曼体现的尤为明显，里面BUG有术士副本拉人以及祖尔金跳柱子。但是即使这样我也只冲成功过一次四箱，那一次是t6级别队伍带队，完全没用bug。除了那一次剩下的基本就是两箱，三箱屈指可数。</p><p>然后我现实的一个的哥们由于学业的问题不能继续跟团队RAID无奈只能把账号暂给我打理，于是我改玩了他的暗夜女精灵牧师，ID叫外面下雨了（后面简称下雨）。我开始跟《荣耀》公会活动，会长就是鼎鼎有名的震撼。荣耀公会最早是桑德兰服务器的，后来由于想当联通区的第一工会，就集体转服到泰拉尔。当时我也是第一次接触牧师，完全是抱大腿的姿势跟他们一团打掉阿克和伊利丹。他们打阿克因为要录视频所以是不用bug的，真真的要考验跑火的功力。第一次打伊利丹我印象很深，当时寝室里有电脑了，由于很多人当时进度很慢，所以打伊利丹的时候，全楼道的wower都来看，然后啧啧惊叹。</p><p>跟着震撼一边打进度团也一边打公会的G团，记得当时t5一套是五万金，t6一套是十五万金。再加上卖武器饰品，一趟下来也分到不少，而且还能直接跟老板换卡，据说公会当时用的付费ts语音也是用老板的钱买的。</p><p>那时候打进度团主要就是开荒太阳井，我用那个牧师号拿了全服第一个t6鞋，首down双子的战报也上了nga，地址在：<a href="http://nga.178.com/read.php?tid=1644774" target="_blank" rel="noopener">http://nga.178.com/read.php?tid=1644774</a> ，视频也被传上了优酷，但是现在那个视频找不到了，不过记得BGM还是很好听的。当时进度团活动时间是晚上七点到早上五点，真的很累人，最后击杀基尔加丹我并没有参与。但是震撼的指挥和语音口头禅给我留下了很深的记忆，他的确是一个很赞的指挥。</p><p>燃烧的远征也是我寝室山哥沉迷魔兽并且活跃的日子，当时山哥投奔了部落玩德鲁伊。我记得他们团第一次过血沸很惊险，当时血沸还有大约5%的血，T都躺光了，就在BOSS准备大肆屠杀的时候，结果血沸那时候点名，好巧不巧的点名了一个盗贼，那贼开着闪避上去顶掉了最后5%的血。其实FD就是这样，需要实力的同时也需要那么一点运气。</p><h2><span id="巫妖王之怒">巫妖王之怒</span></h2><p>当时由于大陆魔兽推迟开巫妖王，那时候我跟老朱、涛哥、永森、老刘、阿俊、小勇几个寝室的哥们还有那个下雨一起转战去了台服，改玩部落。当时我是防骑，老朱改玩牧师，涛哥是法师，老刘是盗贼兼指挥，小勇是术士、阿俊是德鲁伊、永森是萨满，下雨依旧是牧师，不过老朱主要玩的是神牧，下雨主要是暗牧，必要的时候会切奶。</p><p>老朱的魔兽之路开始于60级，当时他第一个职业是法师，最开始的时候他跟xur打赌会尽快的把等级练到骑小马的等级，话说老朱练号的速度是很快的，他也是我们几个人里玩职业好象最多的。从法师到萨满，然后还有盗贼，但是直到这次玩上了牧师，他终于找到了灵魂的归属，发现原来牧师才是他的本命。</p><p>除了老朱我多说说老刘，老刘原名刘义超，是我们年级的一个牛人，很瘦，戴个眼镜，走路有点发飘。用他话说从小身体就不好，所以不是很喜欢运动，除了打魔兽打dota就是看漫画再不然就是用psp打麻将，老刘的经典语录就是“对于我来说，每一把DOTA都是一把新的DOTA”。老刘是一个很聪明的人，打游戏思路很清晰，很少反重复的错误。他为了游戏也肯砸钱，那时候都是老刘给我们搞代理。老刘巅峰的时候在第七天堂打主力牧师，我也亲眼见过他那时候打便当二十五人英雄十字军，后来由于要带我们几个就放弃了第七天堂，转来跟我们一起组团队。当时我们几个人一边小团队打十人icc，一边也跟个工会活动。 不过后来老刘觉得公会团打得不爽，揭竿而起，自立门户开起了25人H ICC金团。每周四，都会看到一个叫德意忘形的德鲁伊在达拉然喊人刷屏，喊满了就向冰冠堡垒浩浩荡荡的出发，由老刘带队指挥，当然我们也会偷偷摸摸的黑下几件装备和一点金。老刘指挥虽然不如震撼激情，但是思路很有条理，基本上战斗力不算很差的团一个下午就打掉2到3个区。当时我已经大四下半学期了，由于有驾校考试，所以当时老刘的金团我参与了也就一半，不过在金团里我得到了大盾冰冠冰川之墙，当时好像是花了4万金。最可惜的一次就是他们有一次开出了英雄的异物逐除，卖了17万金，按当时的物价换算是二千多块人民币!那次的金团真是赚翻了。</p><p>我们十人团的进度是“十人十字军试炼最高差两次就大十字军”、“ICC普通全通”、“h我记得没过冰龙”，因为不久就要毕业了，就没有很全力的去开荒。毕业后从此我们几个战友就四散天涯：老刘回齐齐哈尔，永森和阿俊回佳木斯，涛哥留在哈尔滨，我、小勇和老朱回大庆上班，而下雨就一直在国外，直到现在也没有回来。</p><p>现在除了涛哥和老朱，我还有联系之外，其他人我已经联系不上了，也不知道他们过得好不好。</p><p>魔兽的八十级之前的版本可以说陪伴了我在大学的大多数时光，那也是我魔兽生涯唯一玩部落的时光。</p><h2><span id="大地的裂变">大地的裂变</span></h2><p>到了八十五级我又回归国服了，重返联盟命。由于大学里各位同学都开始了新的生活，我也开始直到现在的魔兽独行侠之路，独自练级独自打战场。 也从此之后，我就再也没有正经的跟过公会团，要么是打随机本看看剧情，要么就是打金团。其实我对八十五级的印象不多了。不过要说一下，八十五刚开始的5h真的很难，经常小怪的治疗一个打断不到就满血了，记得那时候打一个影牙城堡就累的死去活来。硬要说大裂变里印象比较深的，也就是打托尔巴拉德和打巨龙之魂，比如很多战士一起开剑刃风暴一起命令怒吼，场面非常壮观。那个时候我也把战士的种族转成了狼人，也背上了触手剑爬在地上跑来跑去。最后没事干，就趁此机会又练起来一个牧师和一个女人类圣骑士，开始了我的圣光追寻之旅。</p><h2><span id="熊猫人之谜">熊猫人之谜</span></h2><p>到了九十级，朋友也多了起来。主要是跟单位里的磊哥、建哥、亮哥和迪哥一起在奥拉基尔服务器玩。磊哥原先是亡灵贼，后来投奔了联盟转了女人类，但是一直都纠结女人类的动作不如男亡灵飘逸。磊哥自封外号“阿拉希小王子”，长期在农场神出鬼没，也善于在战歌抗旗。迪哥是男德莱尼萨满，满地插柱子，他是一个个性男人，死活不去网吧，坚持就在家里玩。不过迪哥玩魔兽的时间并不长，也就几个月的时间他就投奔去三国杀和单机游戏了。健哥是一个猎人，单刷无敌，他那时候是我们几个里最有G的，输出也最为残暴，不过后来他由于工作原因也忍痛割爱了。亮哥是血DK，号称“通信公司第一DK”，不过我们四个很少玩在一起，毕竟上线时间其实是错开的。</p><p>熊猫人的本我印象比较深的就是“攻打奥格瑞玛”，至于之前的恐惧之心、永春台神马的我压根就没参与过。当时我的小牧师也算练的不错了，主要得益于我下班没事经常混迹在NGA看帖子，再加上那个版本对戒律牧也特别的友好，偶尔在金团也能拿到治疗第一的补助。而磊哥一直想要箱子BOSS的马刀，最后他也算圆梦了。至于建哥一直眼馋的火鹰，好像一直都是没有达成。</p><p>这里我要感谢磊哥，当时我俩在祖尔格拉布翻新之前去刷过祖格虎，结果出虎的时候，磊哥高风亮节让给我了，满足了我开上“红色法拉利”的梦想。</p><h2><span id="德拉诺之王">德拉诺之王</span></h2><p>一百级给我的游戏感觉就是高开低走，尤其是要塞，从最开始新鲜成了后期的累赘。虽然它给了我很多战火装备，但是也让我越来越少出去。整个德拉诺之王我最喜欢的副本就是黑石铸造厂，很有六十级副本的味道，容错率很低。那个时候也认识了以骄傲纹身为首的几个朋友，也打了金团攒了不少钱，这些钱后来也都被我换成了点卡。</p><p>至于地狱火堡垒这个副本我印象不多，翻来覆去就打了两三遍h，还都是跟G团，最后过了h的阿克蒙德，m难度我压根没尝试，后来由于公司里各个朋友们由于现实各种情况AFK，我也开始改玩单机游戏，上号就是刷刷阿什兰和四本刷金，消磨时间休闲娱乐。</p><h2><span id="军团再临">军团再临</span></h2><p>到了一百一十级，几乎整个一百级都没玩的老朱重返魔兽，一口气练了牧师、死骑和恶魔猎手三个职业，我俩也配合打了几个高层大秘境，没有老朱的日子就是我自己慢慢肝神器，每周争取打一次低保，再混一次世界BOSS。也就是这张点卡玩完，我觉得魔兽已经对于我来说没有什么留恋的了，该体验的我差不多都体验过了，没体验到了我也不在乎了。我把牧师停在暴风大教堂，把战士停在暴风要塞，把圣骑士停在激流堡，下线。</p><p>至此，我整个魔兽的生涯就算总结完了。</p><h2><span id="pvp有关">PVP有关</span></h2><p>地球时代的野德不算很强，除了战歌抗旗好像就是补刀了。那时候我看过一个叫dazeroth的暗夜德鲁伊Unstoppable系列视频，觉得很吊，他的视频不算很多，但是打得很棒，然后再看德鲁伊就是一个中国风很浓的暗夜德鲁伊视频，但是我忘了他的名字了。改玩了战士之后，就看Swifty的视频和苹果牛的视频，看直播就看太极龙。牧师的话，看Hydra是最多的。</p><p>我个人认为PVP是魔兽的一个重要的玩法，不过这种玩法随着玩家属性暴涨而变得不再公平（不过有几个乱斗还是挺好玩的）。我竞技场打得不算多，从70年代组织55战队去每周去混10场到现在，加起来不超过200场的JJC实战经验。不过战场混得经验丰富，打一些战场也有自己的心得，比如征服之岛要上来抢车间，大奥如果速推不成功就要抢冰雪墓地耐心打平推，打战歌中场压制住了等于赢了8成，风暴之眼先抢墓地再抢骑，控制了地盘后第一时间去墓地堵人等等等等。但是战场毕竟各位玩家PK水平参差不齐，打战场其实更多就是一个图个乐。</p><p>至于搏击俱乐部，我没玩太多，不过金牌挑战我还是很喜欢的。</p><h2><span id="结束语">结束语</span></h2><p>魔兽世界陪伴了我12年的时光，现在回首来看，我个人最喜欢的是WLK，因为那个版本装备比较好看，其次相对来说各个职业的能力都比较平均，最重要的就是身边有一堆战友并肩作战；其次就是TBC，他在一定程度上弥补了很多60级的缺陷，而且极大地提升了惩戒骑、野德、元素萨等混合职业的存在感，不过TBC的BUG实在太多（我重复几次了？），光一个阿克我就见识过不下4种BUG打法，这一点是TBC的败笔；再其次就是90级和地球时代；大灾变和军团再临他们俩并列再后面一点。</p><p>我爱魔兽，他是我的另一个世界，因为我觉得在现实世界里能做的事情，在魔兽世界能做的更多。不可否认，我曾经在魔兽世界上投入了大量的时间，这耽误了我很多现实中的事儿，不过我还是认可它给我带来了不少的快乐。我还记得在06年的路边书摊会买魔兽世界带副本地图和掉落的攻略的那个宅男；我也记得当初那个小德鲁伊在灰谷，一边看着新浪魔兽任务详解，一边在地图上费劲的查找线索；我也记得当初圣骑士到了查索拉盆地的时候，被那种仙剑风的音乐陶醉；我也记得在阿什兰和奥特兰克山谷，战士那一身部落血的豪爽。但是一切缘分都有到头的时候（或许我将来会有机会到网易的魔兽世界部门上班，不过这个暂且不提），虽然我不能亲眼看见联盟一统艾泽拉斯，但是我还是要说，谢谢暴雪做的这款精良的游戏，感谢你陪我走过的这12年，谢谢跟我并肩作战过的战友，没有你们，我也无法享受这段丰富而美好的时光。</p><p>最后，我要用《军团再临》里面伊利丹的那个口信内容作为我整个魔兽世界生涯的结尾：</p><blockquote><p>我留下的水晶里其实有三条口信</p><p>最后一条是给你的，勇士</p><p>你证明了你对艾泽拉斯的忠诚</p><p>你的奉献和牺牲都足以与我媲美</p><p>但你还得付出许多，更多!</p><p>此刻敌人正在集结，阴云正在汇聚</p><p>从今天起，守护我们的世界和亲人的重任</p><p>就交给你了</p></blockquote><p>再见了，那些一路陪伴我的NPC们，我要离开你们了，去开始新的征程。<br><img src="/images/wowsq.jpg" alt="paradin" title="See you..."></p>]]></content>
    
    <summary type="html">
    
      12年了，到了说离开的时候了。
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="魔兽世界" scheme="http://yoursite.com/tags/%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈raid0,raid1,raid10,raid01等等硬盘阵列搭配</title>
    <link href="http://yoursite.com/2018/01/31/%E7%AE%80%E6%9E%90raid0-raid1-raid10-raid01%E7%AD%89%E7%AD%89%E7%A1%AC%E7%9B%98%E6%90%AD%E9%85%8D/"/>
    <id>http://yoursite.com/2018/01/31/简析raid0-raid1-raid10-raid01等等硬盘搭配/</id>
    <published>2018-01-31T06:43:03.000Z</published>
    <updated>2018-01-31T13:14:11.632Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="raid-0">RAID 0</span></h2><p>RAID 0可用于两个或更多硬盘或SSD。目标是提高读的性能。</p><p>数据以特定大小（通常为64KB）的块写入，并在可用驱动器中平均分配。下图显示了带有三个硬盘的RAID 0阵列的示意图。RAID控制器将第一个数据块写入硬盘1，第二个数据块写入硬盘2，第三个数据块写入硬盘3，第四个数据块再次写入硬盘1,以此类推，RAID 0中的三个1TB硬盘提供3TB的存储空间。<br><img src="/images/raid1.png" alt="paradin"></p><p>由于数据分布均匀，所以在访问的时候会从硬盘1~硬盘3提取数据，然后拼接在一起就是一个完整的数据。理论上从3个硬盘的RAID 0阵列读取数据比从一个硬盘读取要快3倍，换言之，使用RAID 0读数据的能力跟磁盘数量成正比。</p><p>RAID 0也有缺点：如果其中一个磁盘出现故障，从其他磁盘上的数据拼起来就不再是一个完整的数据了。另外，磁盘越多，则发生磁盘故障的可能性也越高。所以如果磁盘阵列里包含着对您来说很重要的数据，则最好创建频繁的备份。</p><h2><span id="raid-1">RAID 1</span></h2><p>RAID 1用于创建数据的自动副本。RAID 1会将同一份数据写入两个单独的磁盘，如果A盘出现故障，仍然可以在B磁盘上读取所有数据，当然这是比较壕的，毕竟做一件事用了两块盘。这里要注意！<font color="red">镜像和备份可不是一样！！！如果你不小心从一个磁盘A上删除了一个文件，或者某个文件被病毒侵蚀了，那它再另一个磁盘B上也是一样的待遇。只有真正的备份才能使所有文件保持其保存状态。</font>因此，如果想不让宝贵数据陷入灾难，创建频繁的备份是必须的。</p><p>RAID 1中的读性能通常与单独的硬盘差不多—-从A和B里一起读数据，谁出数据快就采用谁的，写的话就是要同时写到两个盘里去。因此，使用RAID 1来获得额外更多的读写性能是不太可能的。以下是RAID 1的工作原理图，如果HDD1坏了，那么HDD2直接上任，若HDD1里的东西被删除了，那么HDD2也会被删除，即使它上任了也是坏的。<br><img src="/images/raid2.png" alt="paradin"></p><h2><span id="raid-10和raid-01">RAID 10和RAID 01</span></h2><p>所谓RAID 10,其实就是磁盘阵列<code>先RAID 1,后RAID 0</code>,同理，RAID 01也是先<code>RAID 0,后RAID 1</code>。无论是1+0还是0+1，都至少需要4个硬盘。</p><p>这里先看一下RAID 10和RAID 01的效果图：<br><img src="/images/raid3.png" alt="paradin"></p><p>就像图里说的“在六个硬盘列里，RAID 10比RAID 01更安全”。的确，RAID 10也凭借很棒的容错能力和恢复能力当选了大多数的RAID配置，为什么不要RAID 01呢？那就是如果在RAID 0那一步磁盘就坏了，那RAID 1那步就没有意义了，因为生成的镜像全是坏镜像。</p><h2><span id="raid-3">RAID 3</span></h2><p>RAID 3是这样的：若有n块盘，其中拿出1块盘作为校验盘，剩余n-1块盘相当于作RAID 0同时读写，当n-1那里的其中一块盘坏掉时，可以通过校验码还原出坏掉盘的原始数据。这个校验方式比较特别，事奇偶检验，1 XOR 0 XOR 1=0，0 XOR 1 XOR 0=1，最后的数据是校验数据，当中间缺了一个数据时，可以通过其他盘的数据和校验数据推算出来。但是这存在了问题，由于n-1块盘做了RAID 0，每一次读写都要牵动所有盘来服务，而且万一校验盘坏掉就完蛋了。</p><h2><span id="raid-5-and-6">RAID 5 and 6</span></h2><p>上面说了RAID 10是一个很棒的方案，但是它的实现至少需要4个硬盘，这一点太伤钱了，于是就出现了RAID 5。与RAID 0一样，数据被分成块并执行写入处理，同时把RAID 3的“校验盘”也分成块分散到所有的盘里。同时，产生并写入称为“奇偶校验”的冗余代码。因此，即使其中的一个硬盘出现故障，也可以根据剩余的数据和奇偶校验来计算出丢失的数据，然后生成完整的状态数据。由于无论需要配置多少个硬盘，保存校验只使用一台设备的容量，容量效率随着待配置硬盘数量的增加而提高。<font color="red">RAID 5模式下硬盘读取数据的速度很快，因为它是从多个驱动器同时处理的</font>。预计速度将与要配置的驱动器的数量成比例地增加。但是，数据的写入/更新涉及奇偶校验的创建/更新，所以<font color="red">写入性能不高</font>。</p><p>RAID 5已经提供了一定程度的可靠性,然而也牺牲了一定的读取速度。RAID 5的局限性还表现在RAID 5仅能在一块硬盘发生故障的情况下修复数据,如果2块硬盘同时发生故障,RAID 5则无能为力。于是RAID 6应需诞生了，RAID 6同RAID 5最大的区别就是在RAID 5的基础上除了具有P校验位以外,还加入了第2个校验位Q位。当一块磁盘出现数据错误或者丢失的时候,恢复方法同RAID 5,无须使用Q校验位。当两块磁盘上的数据出现错误或者丢失的时候,恢复方法为:利用上边给出的P,Q的生成公式,联立方程组,无论受损的数据是否包括P或者Q,总是能够解出损失的两位的数据。</p><h2><span id="raid-50-and-60">RAID 50 and 60</span></h2><p>在硬盘数量较少的情况下，RAID 5是极好的选择，如7-8块硬盘组成的RAID。但是，当硬盘的数量更多的时候，如10块、20块甚至100块，那么RAID 5就无法胜任了。RAID 50是在RAID 5的基础上，将多个RAID 5组以RAID 0的形式组成在一起。可以这么认为，一个RAID 5组在这里就是一个“大硬盘”，再把这些“大硬盘”以RAID 0的形式组成在一起。而RAID 60的组成就是在RAID 6组的上面组成一个RAID 0。理论上说在写入性能方面，RAID 50相比RAID 5要好太多，而RAID 50相比性能冠军RAID 10要差一点，考虑到RAID 5在一些负载面前的平庸性能，RAID 50是个不错的中间选择。和RAID 5和RAID 10一样，RAID 50也提供极好的读性能，同时RAID 50即使使用最低配置，也需要六个硬盘，所以安装成本很高。</p><p>如果担心一个RAID组里面同时有2块硬盘发生故障，导致数据丢失，那么可以选择使用RAID 60。RAID 60提供更高的安全性，相应的其可用容量会比RAID 50少点，RAID 60即使使用最少的配置，也需要8个硬盘，所以安装成本相当高。</p><h2><span id="结语">结语</span></h2><p>以上几个磁盘阵列，从读的能力来说：RAID 5 ≈ RAID 6 ≈ RAID 60 &gt; RAID 0 ≈ RAID 10 &gt; RAID 3 ≈ RAID 1<br>从写的能力来说:RAID 10 &gt; RAID 50 &gt; RAID 1 &gt; RAID 3 &gt; RAID 5 ≈ RAID 6 ≈ RAID 60<br>如果将来有一天你对这篇文章记得不是很清晰了，那么但愿你可以记住下面这张图，这几幅图虽然对于RAID 上不是完全的准确，但是已经很大的表达清楚了各种RAID的特点了。<br><img src="/images/raid4.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://us.hardware.info/reviews/4123/raid-0-raid-1-raid-10-and-raid-5-how-do-they-actually-work" target="_blank" rel="noopener">https://us.hardware.info/reviews/4123/raid-0-raid-1-raid-10-and-raid-5-how-do-they-actually-work</a><br><a href="http://support.huawei.com/enterprise/zh/knowledge/KB1000149118/" target="_blank" rel="noopener">http://support.huawei.com/enterprise/zh/knowledge/KB1000149118/</a><br><a href="https://zh.wikipedia.org/wiki/RAID" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/RAID</a><br><a href="http://www.hpc.co.jp/raid_kaisetsu.html" target="_blank" rel="noopener">http://www.hpc.co.jp/raid_kaisetsu.html</a></p>]]></content>
    
    <summary type="html">
    
      磁盘阵列这个东西，有钱就有安全
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="raid" scheme="http://yoursite.com/tags/raid/"/>
    
      <category term="磁盘阵列" scheme="http://yoursite.com/tags/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Ansible-playbook如何获取ip</title>
    <link href="http://yoursite.com/2018/01/31/Ansible-playbook%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96ip/"/>
    <id>http://yoursite.com/2018/01/31/Ansible-playbook如何获取ip/</id>
    <published>2018-01-31T05:54:08.000Z</published>
    <updated>2018-01-31T06:21:34.530Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>公司的模块都新加了加密算法，现在就是需要把约100台机器的<code>/etc/hosts</code>文件里的zookeeper server的ip调整成新的ip 地址，目前在ansible控制机上已经写好了带有新的zookeeper server的ip的<code>/etc/hosts</code>文件，然后计划是把这个新文件下发到大约100台具体模块的服务器里，然后这100台机器的文件中把他们各自的ip和hostname添加到这个新的<code>/etc/hosts</code>文件上。</p><p>于是就写了一个ansible-playbook:<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: all</span><br><span class="line">  tasks:</span><br><span class="line">        - name: 将原有的hosts文件备份</span><br><span class="line">          shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">        - name: 将ansible端的hosts复制到各自机器上</span><br><span class="line">          copy: src=<span class="regexp">/root/</span>hosts dest=<span class="regexp">/etc/</span> owner=root group=root mode=<span class="number">0544</span></span><br><span class="line"></span><br><span class="line">        - name: 在新的hosts文件后面追加各自机器内网ip和hostname</span><br><span class="line">          lineinfile: dest=<span class="regexp">/etc/</span>hosts line=<span class="string">"`ansible_all_ipv4_addresses`  `ansible_hostname`"</span></span><br></pre></td></tr></table></figure></p><p>但是写完之后执行出来，却是这样的效果：<br><img src="/images/ansibleip.png" alt="akb48"></p><p>而我想要的是这样的效果：<br><img src="/images/ansibleip2.png" alt="akb48"></p><p>遇到这种情况怎么办？</p><p>后来调整了一下，变量用<code>IP</code>: ““，而不是<code>ansible_all_ipv4_addresses</code>。</p><p>修改了之后的playbook 如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: all</span><br><span class="line">  vars:</span><br><span class="line">        IP: <span class="string">"&#123;&#123; ansible_eth0['ipv4']['address'] &#125;&#125;"</span></span><br><span class="line">  tasks:</span><br><span class="line">        - name: 将原有的hosts文件备份</span><br><span class="line">          shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">       - name: 将ansible端的hosts复制到各自机器上</span><br><span class="line">         copy: src=<span class="regexp">/root/</span>hosts dest=<span class="regexp">/etc/</span> owner=root group=root mode=<span class="number">0644</span></span><br><span class="line"></span><br><span class="line">        - name: 在新的hosts文件后面追加各自机器内网ip和hostname</span><br><span class="line">          lineinfile: dest=<span class="regexp">/etc/</span>hosts line=<span class="string">"`IP`  `ansible_hostname`"</span></span><br></pre></td></tr></table></figure></p><p>这样就达到目的了。</p>]]></content>
    
    <summary type="html">
    
      把每一项累手的任务都转换成累心
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>mysql查看实时语句和慢sql</title>
    <link href="http://yoursite.com/2018/01/30/mysql%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%85%A2sql/"/>
    <id>http://yoursite.com/2018/01/30/mysql查看实时语句和慢sql/</id>
    <published>2018-01-30T12:50:14.000Z</published>
    <updated>2018-01-30T13:40:03.228Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="查看实时语句">查看实时语句</span></h2><p>Mysql除了手动执行的语句，还有很多在后台由其他模块执行的语句，按理来说，那些由其他模块执行的语句是不能实时查看的，因为这个资源消耗特别的大，但是当我们实在需要查看实时sql语句的时候也不是做不到，需要手动开启一个日志开关<code>general_log</code>。</p><p>首先登陆mysql，然后执行<code>show variables like &quot;general_log%&quot;;</code>，看一下反馈的结果，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"general_log%"</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| general_log      | OFF   |</span><br><span class="line">| general_log_file |       |</span><br><span class="line">+------------------+-------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure></p><p>发现这个Value是<code>off</code>，那么就说明实时记录<code>general_log</code>没有开启，如果我们要开启它很简单，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global log_output = file;</span><br><span class="line">mysql&gt; set global general_log = <span class="string">'ON'</span>;</span><br><span class="line">mysql&gt; set global general_log_file = <span class="string">'/tmp/mysql/general_log.log'</span>;</span><br></pre></td></tr></table></figure></p><p>可见我们不仅打开了<code>general_log</code>的开关，而且设置日志输出方式为文件（如果设置<code>log_output=table</code>的话，则日志结果会记录到名为<code>gengera_log</code>的表中，这表的默认引擎都是<code>CSV</code>）。同时规定它的保存位置是<code>/tmp/mysql/general_log.log</code>。</p><p>但是这个是临时方法，如果mysql重启了那么就会失效，如果想要永久有效的话，就要编辑<code>my.cnf</code>，添加下面两句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">general_log = <span class="number">1</span></span><br><span class="line">general_log_file = <span class="regexp">/tmp/my</span>sql/general_sql.log</span><br></pre></td></tr></table></figure></p><p>这里要注意！<font color="red">开启general_log会影响性能，谨慎使用!正式系统用完要关闭!!!</font>关闭的语句<code>SET GLOBAL general_log = &#39;OFF&#39;;</code>。</p><h2><span id="查看慢sql">查看慢sql</span></h2><p>慢sql的意思就是那些执行很慢的sql，这些sql拖慢进程的执行效率而且有很大的优化空间。默认的来说，执行时间超过1秒就算慢sql了，在mysql里输入<code>show variables like &#39;long%&#39;</code>，就会看到如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'long%'</span>;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | <span class="number">1.000000</span> |</span><br><span class="line">+-----------------+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>这个<code>long_query_time</code>是可以更改的，这里是1，那就是代表查询时间大于(不是大于等于)1秒的都是记录到日志，最大值是10。如果写的是0，那么就是输出所有的语句。</p><p>这里多说一句，使用命令<code>set global long_query_time=4</code>修改慢查询阈值为4秒后，需要重新连接或新开一个会话才能看到修改值。你用<code>show variables like &#39;long_query_time&#39;</code>查看是当前会话的变量值，你也可以不用重新连接会话，而是用<code>show global variables like &#39;long_query_time&#39;;</code>。</p><p>那么记录这些慢日志的地方在哪呢？使用<code>show variables  like &#39;%slow_query_log%&#39;;</code>看看：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like <span class="string">'%slow_query_log%'</span>;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                           |</span><br><span class="line">| slow_query_log_file | <span class="regexp">/tmp/my</span>sql/DB-Server-slow.log   |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>这里说明慢日志的地址是<code>/tmp/mysql/DB-Server-slow.log</code>，但是慢日志记录的功能没有启动。如果要启动，语句是：<code>set global slow_query_log=1;</code>，跟上面开启实时日志<code>general_log</code>一样，这个方法仅仅是一个临时方法，重启了mysql就会失效，如果要长期生效，还是在<code>my.cnf</code>文件里添加如下两句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log =<span class="number">1</span></span><br><span class="line">slow_query_log_file=<span class="regexp">/tmp/my</span>sql/DB-Server-slow.log</span><br></pre></td></tr></table></figure></p><p>慢日志还有一个系统变量叫<code>log-queries-not-using-indexes</code>，它的意思是未使用索引的查询也被记录到慢查询日志中，哪怕他可能执行的非常快（可选项）。如果调优的话，建议开启这个选项。另外，开启了这个参数，其实使用<code>full index scan</code>的sql也会被记录到慢查询日志。如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'log_queries_not_using_indexes'</span>;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| log_queries_not_using_indexes | OFF   |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global log_queries_not_using_indexes=<span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>如果你想自己试试慢sql是否被记录，那么可以使用<code>select sleep(5);</code>这样的语句，执行效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(<span class="number">5</span>) ;</span><br><span class="line">+----------+</span><br><span class="line">| sleep(<span class="number">5</span>) |</span><br><span class="line">+----------+</span><br><span class="line">|        <span class="number">0</span> |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">5.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> mysql.slow_log;</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| start_time          | user_host                 | query_time | lock_time | rows_sent | rows_examined | db | last_insert_id | insert_id | server_id | sql_text        | thread_id |</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| <span class="number">2018</span><span class="number">-01</span><span class="number">-30</span> <span class="number">21</span>:<span class="number">45</span>:<span class="number">23</span> | root[root] @ localhost [] | <span class="number">00</span>:<span class="number">00</span>:<span class="number">05</span>   | <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  |         <span class="number">1</span> |             <span class="number">0</span> |    |              <span class="number">0</span> |         <span class="number">0</span> |         <span class="number">1</span> | select sleep(<span class="number">5</span>) |         <span class="number">2</span> |</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line"><span class="number">1</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.cnblogs.com/kerrycode/p/5593204.html" target="_blank" rel="noopener">http://www.cnblogs.com/kerrycode/p/5593204.html</a><br><a href="https://www.cnblogs.com/qmfsun/p/4844472.html" target="_blank" rel="noopener">https://www.cnblogs.com/qmfsun/p/4844472.html</a><br><a href="http://www.cnblogs.com/jasondan/p/3491258.html" target="_blank" rel="noopener">http://www.cnblogs.com/jasondan/p/3491258.html</a></p><p><img src="/images/curry3p.gif" alt="库里三分" title="神射手萌库"></p>]]></content>
    
    <summary type="html">
    
      这些都是在自己的mysql上使用的，云厂家的数据库就不要想了，需要在控制台查看。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Goaccess---良心nginx日志分析工具</title>
    <link href="http://yoursite.com/2018/01/30/Goaccess-%E8%89%AF%E5%BF%83nginx%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/01/30/Goaccess-良心nginx日志分析工具/</id>
    <published>2018-01-30T07:42:33.000Z</published>
    <updated>2018-01-30T07:53:27.531Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Goaccess是一个非常良心的开源软件，它的良心之处体现在如下方面：</p><ul><li>安装简单；</li><li>操作容易；</li><li>界面酷炫；</li></ul><h2><span id="安装">安装</span></h2><p>安装<code>Goaccess</code>十分的简单，在centos里直接<code>yum install goaccess</code>，如果yum源里没有<code>goaccess</code>，可以先安装<code>epel</code>。安装<code>epel</code>的方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></span><br><span class="line">wget http:<span class="comment">//rpms.famillecollet.com/enterprise/remi-release-6.rpm</span></span><br><span class="line">rpm -Uvh remi-release<span class="number">-6</span>*.rpm epel-release<span class="number">-6</span>*.rpm</span><br></pre></td></tr></table></figure></p><h2><span id="配置和使用">配置和使用</span></h2><p>安装完<code>goaccess</code>之后，我们需要在<code>/etc/goaccess.conf</code>里添加如下几句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time-format %T</span><br><span class="line">date-format %d/%b/%Y</span><br><span class="line">log-format %h %^[%d:%t %^] “%r” %s %b “%R” “%u”</span><br></pre></td></tr></table></figure></p><p>保存退出之后，我们就可以通过<code>goaccess</code>来分析<code>nginx</code>日志了，语句格式也很简单：<code>goaccess -f nginx日志的绝对路径</code>。比如我的nginx日志是<code>access-chen.log</code>，查看一下里面的内容：<br><img src="/images/goaccess1.png" alt="goaccess"></p><p>虽然有规律，但是看上去很乱，需要在分析日志之前喝两瓶静心口服液。</p><p>然后我就<code>goaccess -f access-chen.log</code>，就会看到如下的界面：<br><img src="/images/goaccess2.png" alt="goaccess"></p><p>这一下，整个日志看起来更加友好，更加直白，更加高大上。足以吸引周围人的羡慕目光。</p><p>但是这里面还是有一个注意点：<code>goaccess</code>默认支持的日志格式是<code>nginx</code>默认的日志格式，也就是nginx.conf里的如下格式：<br><img src="/images/goaccess3.png" alt="goaccess"></p><p>如果你的日志格式是有过更改的，而且还不想改回来，那么就需要去<code>/etc/goaccess.conf</code>里对应的<code>log-format</code>进行更改。</p><p>这还没有完，goaccess还可以生成html，这里<code>goaccess -f access-chen.log  -a &gt; /nginx安装路径/html/chen.html</code>。然后在浏览器里登陆到这个服务器的chen.html，就会看到整个日志情况的网页排版，如图：<br><img src="/images/goaccess4.png" alt="goaccess"></p><p>这样的话，我们可以每一天都发一份当天的日志html去运维人员的信箱里，这样更加方便我们分析日志。</p><h2><span id="缺点">缺点</span></h2><p>虽然前面说了那么多goaccess的优点，但是缺点也是有的，比如<code>goaccess</code>的粒度太粗，只能按天分割，如果要按小时分割，需要先<code>grep</code>出来，这个做法比较挫我懂…</p><p>还有一个缺点，就是访问人的来源只能定位到国家，无法具体定位到省市县村屯…<br><img src="/images/goaccess5.png" alt="goaccess"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.maxhemby.se/determine-the-apache-traffic-load/#respond" target="_blank" rel="noopener">http://blog.maxhemby.se/determine-the-apache-traffic-load/#respond</a></p>]]></content>
    
    <summary type="html">
    
      面试的时候一定会被面到的问题是：给出web服务器的访问日志，请写一个脚本来统计访问前10的IP有哪些？访问前10的请求有哪些？当你领略过goaccess之后，你就明白，这些问题，除了考验你的脚本背诵记忆能力以外，唯一的作用只有装A或者装C了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="日志统计" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>处理掉积压过多的activemq持久化消息</title>
    <link href="http://yoursite.com/2018/01/29/%E5%A4%84%E7%90%86%E6%8E%89%E7%A7%AF%E5%8E%8B%E8%BF%87%E5%A4%9A%E7%9A%84activemq%E6%8C%81%E4%B9%85%E5%8C%96%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/01/29/处理掉积压过多的activemq持久化消息/</id>
    <published>2018-01-29T06:27:26.000Z</published>
    <updated>2018-01-31T06:03:32.033Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="问题描述">问题描述</span></h2><p>在项目使用<code>activemq 5.14</code>时，客户端发送消息而没有得到回复（在不考虑消费者是什么问题的情况下），导致持久化消息不断积压而得不到释放，最后造成队列堵塞而嗝屁。</p><p>一般来说遇到这样的情况，可以在配置文件中配置消息的过期时间和死信处理来防止消息的积压，配置如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">       &lt;!-- <span class="number">86</span>,<span class="number">400</span>,<span class="number">000</span>ms = <span class="number">1</span> day --&gt;</span><br><span class="line">         &lt;timeStampingBrokerPlugin ttlCeiling=<span class="string">"10000"</span> zeroExpirationOverride=<span class="string">"10000"</span>/&gt;</span><br><span class="line">     &lt;<span class="regexp">/plugins&gt;</span></span><br></pre></td></tr></table></figure></p><p>配置消息过期时间使用<code>timeStampingBrokerPlugin</code>插件,<code>ttlCeiling</code>：表示过期时间上限（模块程序写的过期时间不能超过此时间，超过则以此时间为准），<code>zeroExpirationOverride</code>：表示过期时间（给未分配过期时间的消息分配过期时间），一般来说这两个值是一样的。执行之后，message过期则客户端不能接收，那些已经过期的message将会保存在<code>data/kahadb</code>目录下。</p><p>但是最近发现了一个问题，就是<code>data/kahadb</code>这个目录最近越来越大，越积越多。但是这个topic和quere又依旧是“持续订阅”的，它的消费者还在。遇到这样的情况，如何在activemq里配置呢？</p><h2><span id="解决办法">解决办法</span></h2><ul><li><p>配置message过期自动丢弃策略</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;borker&gt;</span><br><span class="line">   &lt;destinationPolicy&gt;</span><br><span class="line">       &lt;policyMap&gt;</span><br><span class="line">           &lt;policyEntries&gt;</span><br><span class="line">               &lt;policyEntry topic=<span class="string">"&gt;"</span> expireMessagesPeriod=<span class="string">"60000"</span>&gt;</span><br><span class="line">                   &lt;deadLetterStrategy&gt;</span><br><span class="line">                        &lt;sharedDeadLetterStrategy processExpired=<span class="string">"false"</span> /&gt;</span><br><span class="line">                   &lt;<span class="regexp">/deadLetterStrategy&gt;</span></span><br><span class="line"><span class="regexp">               &lt;/</span>policyEntry&gt;</span><br><span class="line">           &lt;<span class="regexp">/policyEntries&gt;</span></span><br><span class="line"><span class="regexp">       &lt;/</span>policyMap&gt;</span><br><span class="line">   &lt;<span class="regexp">/destinationPolicy&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>borker&gt;</span><br></pre></td></tr></table></figure></li></ul><p>标签<code>processExpired=&quot;false&quot;</code>表示<font color="red">不保存过期消息到死信队列，处理手段为删除</font>，为<code>true</code>则是保留。<br>标签<code>expireMessagesPeriod=&quot;60000&quot;</code>属性表示每隔60秒钟检查message是否过期。<br><code>topic=&quot;&gt;&quot;</code>表示该策略对所有topic都生效。而<code>topic=&quot;active.&gt;&quot;</code>就表示该策略对以<code>active.</code>开头的所有<code>topic</code>生效，注意有个点号<code>.</code>。</p><ul><li>message过期时间设置<br>上面那步搞定了之后，再修改<code>timeStampingBrokerPlugin</code>标签里<code>ttlCeiling=&quot;360000&quot; zeroExpirationOverride=&quot;360000&quot;</code>表示过期时间为360000ms（1小时）。  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;borker&gt;</span><br><span class="line">   &lt;plugins&gt;</span><br><span class="line">       &lt;!-- <span class="number">86</span>,<span class="number">400</span>,<span class="number">000</span>ms = <span class="number">1</span> day --&gt;</span><br><span class="line">       &lt;timeStampingBrokerPlugin ttlCeiling=<span class="string">"360000"</span> zeroExpirationOverride=<span class="string">"360000"</span> /&gt;</span><br><span class="line">   &lt;<span class="regexp">/plugins&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>borker&gt;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="解决空队列的方法">解决“空队列”的方法</span></h2><p>如果不是那种“持续订阅”的topic，那就简单了，配置如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> schedulePeriodForDestinationPurge=<span class="string">"10000"</span>&gt;</span><br><span class="line">   &lt;destinationPolicy&gt;</span><br><span class="line">      &lt;policyMap&gt;</span><br><span class="line">         &lt;policyEntries&gt;</span><br><span class="line">            &lt;policyEntry queue=<span class="string">"&gt;"</span> gcInactiveDestinations=<span class="string">"true"</span> inactiveTimoutBeforeGC=<span class="string">"30000"</span>/&gt;</span><br><span class="line">         &lt;<span class="regexp">/policyEntries&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>policyMap&gt;</span><br><span class="line">   &lt;<span class="regexp">/destinationPolicy&gt;     </span></span><br><span class="line"><span class="regexp"> &lt;/</span>broker&gt;</span><br></pre></td></tr></table></figure></p><p><code>schedulePeriodForDestinationPurge</code>执行清理任务的周期，<code>gcInactiveDestinations=&quot;true&quot;</code>表示启用清理功能，<code>inactiveTimoutBeforeGC=&quot;30000&quot;</code>这个是Topic或Queue超时时间,在规定的时间内，无有效订阅，没有入队记录，超时后就会被清理。<br><img src="/images/大帝扣威少.gif" alt="" title="大帝扣威少！"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://activemq.apache.org/timestampplugin.html" target="_blank" rel="noopener">http://activemq.apache.org/timestampplugin.html</a></p>]]></content>
    
    <summary type="html">
    
      “不活动的空队列”和“过期队列”可不是一个意思！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="activemq" scheme="http://yoursite.com/tags/activemq/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python里调用redis的方法</title>
    <link href="http://yoursite.com/2018/01/29/Python%E9%87%8C%E8%B0%83%E7%94%A8redis%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/29/Python里调用redis的方法/</id>
    <published>2018-01-29T04:38:39.000Z</published>
    <updated>2018-01-29T04:48:40.333Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>Python 2.7里不是自带<code>redis</code>模块的，那么在调用redis的时候自然也会报错，比如：<br><img src="/images/pyredis1.png" alt=""></p><p>遇到这种情况怎么办？</p><p>第一种方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure></p><p>第二种方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install redis</span><br></pre></td></tr></table></figure></p><p>第三种方法：<br>去登录<code>https://github.com/andymccurdy/redis-py</code>，下载包上传到linux里之后，<code>python setup.py install</code>。<br><img src="/images/pyredis2.png" alt=""></p><p>flask模块的安装也是同理。</p><p>注意！这里只有<code>Redis</code>，如果使用<code>StrictRedis</code>会报错：<code>AttributeError: &#39;Redis&#39; object has no attribute &#39;StrictRedis&#39;</code>。这个是版本的问题。见<br><a href="https://github.com/andymccurdy/redis-py/issues/188" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py/issues/188</a></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://debugo.com/python-redis/" target="_blank" rel="noopener">http://debugo.com/python-redis/</a></p><p><img src="/images/欧文骚脚步.gif" alt="" title="这脚步把我看高潮了..."></p>]]></content>
    
    <summary type="html">
    
      本文的写作来源于《第一本 docker书》的第189页。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Ssh连接port 22: Connection refused</title>
    <link href="http://yoursite.com/2018/01/29/Ssh%E8%BF%9E%E6%8E%A5port-22-Connection-refused/"/>
    <id>http://yoursite.com/2018/01/29/Ssh连接port-22-Connection-refused/</id>
    <published>2018-01-29T03:30:18.000Z</published>
    <updated>2018-01-29T03:38:54.116Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>金山云有一个服务器需要连接到数据库但是总是失败，检查之后发现它的VPC配错了，更改VPC之后，这台服务器也会更换一个新的内网IP地址，但是问题来了，更换了内网IP之后，从跳板机连接，提示<code>port 22: Connection refused</code>。</p><p><code>ssh -v 新的ip地址</code>发现根本没有到<code>Connection established</code>。直接就提示<code>port 22: Connection refused</code>。这基本可以断定不是跳板机的问题了，那么就需要在远程机器里看配置。</p><p>但是远程机器是无法连接的啊，怎么办？从金山控制台“连接实例”。<br><img src="/images/ksssh1.png" alt=""></p><p>然后键盘随便按一下，就会看到linux界面，输入账号名和密码，这里密码不支持复制粘贴，需要手动输入。然后就会看到如下界面。<br><img src="/images/ksssh2.png" alt=""></p><p>这样，我们就可以登陆这台机器了，然后<code>vim /etc/ssh/sshd_config</code>，看到最上面有这样的内容。<br><img src="/images/ksssh3.png" alt=""></p><p>这个<code>listenaddress</code>后面就是跳板机ssh的地址，但是这个地址还是老的，而不是更改过后的内网ip地址，所以ssh的连接自然就是<code>refuse</code>。所以我们只需要手动更改成新的内网ip地址就好了。</p><p>更改完之后，重启一下服务器或者<code>/etc/init.d/sshd restart</code>就可以从跳板机上正常连接了。</p><p>如果在<code>/etc/init.d/sshd restart</code>的时候爆出“address family must be specified before ListenAddress”的错误，那么就把<code>AddressFamily</code>移到<code>ListenAddress</code>上面就可以了，如图：<br><img src="/images/ksssh4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      调换了内网IP之后，来了这么一出
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>SFTP不能连接服务器怎么办？</title>
    <link href="http://yoursite.com/2018/01/27/SFTP%E4%B8%8D%E8%83%BD%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/01/27/SFTP不能连接服务器怎么办？/</id>
    <published>2018-01-27T08:19:55.000Z</published>
    <updated>2018-01-29T04:35:52.647Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在跳板机上传送文件，发现使用<code>SFTP</code>连接的时候，出现了这样的一个拒绝情况：<br><img src="/images/sftp1.png" alt=""></p><p>登陆到这个跳板机里，使用<code>tail /var/log/secure</code>，看到了拒绝的具体信息，如下：<br><img src="/images/sftp2.png" alt=""></p><p>这个时候，我就需要<code>locate sftp-server</code>，用<code>locate</code>定位一下<code>sftp</code>文件，但是发现服务器竟然回答我<code>-bash: locate: command not found</code>。</p><p>于是就<code>yum -y install mlocate</code>，安装<code>mlocate</code>之后执行<code>updatedb</code>，需要等待一小会，然后再次执行<code>locate sftp-server</code>，就可以得到sftp-server的文件路径了，如下图：<br><img src="/images/sftp3.png" alt=""></p><p>打开sshd的配置文件，<code>vi /etc/ssh/sshd_config</code>，把<code>Subsystem</code>这一行前面的<code>#</code>去掉：<br><img src="/images/sftp4.png" alt=""></p><p>然后重启启动ssh服务，语句是<code>/etc/init.d/sshd reload</code>，重新连接一下，发现就恢复正常了。</p>]]></content>
    
    <summary type="html">
    
      总有意向不到的插曲
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="sftp" scheme="http://yoursite.com/tags/sftp/"/>
    
  </entry>
  
  <entry>
    <title>Ansible部署模块的时候出现中文乱码的问题</title>
    <link href="http://yoursite.com/2018/01/27/Ansible%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/27/Ansible部署模块的时候出现中文乱码的问题/</id>
    <published>2018-01-27T05:58:49.000Z</published>
    <updated>2018-01-27T06:02:16.658Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在部署服务的时候遇到了一个很罕见的现象，线上有15台服务器是手机推送消息的服务，新来的小运维使用ansible批量跑部署脚本的时候，发现手机端接收到来的消息全是乱码，然后登陆到服务器，查看日志发现，日志里面就是乱码，如图：<br><img src="/images/luanma1.png" alt=""></p><p>由于这个问题用户是有感知的，所以属于“事故”级别了，于是小boss大怒，叫运维赶快回滚，然后让开发赶紧重新检查代码，然后开骂测试都是吃屎的么这么大的一个问题都看不出来真是一群猪伤不起啊。</p><p>开发看了半天自己的代码，发现没有任何问题，战战兢兢跑来跟新来的小运维窃窃私语，结果我发现这个模块用手动单独部署，日志却是正常的，中文显示十分OK。<br><img src="/images/luanma2.png" alt=""></p><p>这一下开发就腰杆硬了，说这不是我的锅啊我是无辜的啊老子天天辛苦加班没有功劳也有苦劳没有苦劳也有疲劳老子的代码经得住考验这一切就是部署的问题。</p><p>于是我就查看了一下ansible的配置文件，<code>vim /etc/ansible/ansible.cfg</code>，发现了问题所在：<br><img src="/images/luanma3.png" alt=""></p><p>这里最后三行需要改成下面的样子，这样就解决了乱码问题。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#module_lang    = C</span><br><span class="line">#module_set_locale = False</span><br><span class="line">module_lang    = zh_CN.UTF<span class="number">-8</span></span><br><span class="line">module_set_locale = True</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这个情况纯属意外...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
      <category term="自动化部署" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-16T07:27:57.512Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gitlab的配置备份</title>
    <link href="http://yoursite.com/2018/05/16/Gitlab%E9%85%8D%E7%BD%AE%E5%A4%87%E4%BB%BD/"/>
    <id>http://yoursite.com/2018/05/16/Gitlab配置备份/</id>
    <published>2018-05-16T07:02:50.000Z</published>
    <updated>2018-05-16T07:27:57.512Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我这个gitlab是容器安装的，直接使用最新的gitlab镜像，gitlab版本是10.7.3，要备份数据的话，就要进入容器里，执行<code>gitlab-rake gitlab:backup:create</code>，效果如下：<br><img src="/images/gitlab19.png" alt="paradin"></p><p>执行完毕之后，在<code>/var/opt/gitlab/backups</code>文件夹里就会生成一个备份文件，我这里生成的文件叫：1526454102_2018_05_16_10.7.3_gitlab_backup.tar，这个就是备份的文件。如果要还原的话，命令是<code>docker-compose run –rm gitlab app:rake gitlab:backup:restore BACKUP=1526454102</code>，BACKUP后面的是备份文件开头的那串数字。</p><p>如果要设置这个备份文件的生命周期和备份文件存储的位置，编辑<code>/etc/gitlab/gitlab.rb</code>，修改如下的地方：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&apos;backup_path&apos;] = &quot;/var/opt/gitlab/backups&quot;#这里改新路径</span><br><span class="line">gitlab_rails[&apos;backup_archive_permissions&apos;] = 0644#这里可以设定文件的权限</span><br><span class="line"># limit backup lifetime to 7 days - 604800 seconds</span><br><span class="line">gitlab_rails[&apos;backup_keep_time&apos;] = 604800#文件存储时间一周</span><br></pre></td></tr></table></figure></p><p>然后重启一下gitlab即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;我这个gitlab是容器安装的，直接使用最新的gitlab镜像，gitlab版本是10.7.3，要备份数据的话，就要进入容器里，执行&lt;code&gt;gitlab-rake git
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gitlab的简单应用</title>
    <link href="http://yoursite.com/2018/05/16/Gitlab%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/16/Gitlab的简单实用/</id>
    <published>2018-05-16T01:30:52.000Z</published>
    <updated>2018-05-16T06:43:50.805Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>gitlab跟svn的区别我就不多说了，这里直接说具体应用。</p><h2><span id="建立一个project">建立一个project</span></h2><p>先登陆到gitlab的网页，我这里使用了root用户，选择<code>create a project</code>，然后就是填写project的名称以及它所属的用户，这里由于只有root用户，所以这个叫<code>jjfjj</code>的project就是root自己的，如果建立了一个组的话，那么这里就填写那个组，如下：<br><img src="/images/gitlab14.png" alt="paradin"></p><p>下面这个<code>Visibility Level</code> ，就是权限等级，它分三种：</p><ol><li>Private：私有的，只有你自己或者组内的成员能访问</li><li>Internal：所有登录的用户</li><li>Public：公开的，所有人都可以访问</li></ol><p>这个东西和project的名称都是可以后期更改的。</p><p>然后就是<code>create project</code>，就创建了这个jjfjj。如图:<br><img src="/images/gitlab15.png" alt="paradin"></p><h2><span id="将本地代码上传">将本地代码上传</span></h2><p>建立好了gitlab，就要把开发的代码传进去，我在另外一个机器里，创建一个目录code，这个目录就是专门用来放置代码的，假设现在里面有一个文件叫<code>testcode.py</code>，如图：<br><img src="/images/gitlab16.png" alt="paradin"></p><p>具体操作如下：<br><img src="/images/gitlab17.png" alt="paradin"></p><p>如果在两个不同的文件夹里执行上面的过程，会传输到两个不同的project里。说明一下上面几个命令的意思：<br><code>git init</code>：初始化git仓库<br><code>git add .</code>：添加整个目录里的所有文件到仓库<br><code>git rm --cached 某个文件名</code>：将某个文件从gitlab上撤除，如果想当前文件夹恢复成一个普通的文件夹，那就把文件夹路径下的.git文件删除掉即可<br><code>git commit -m &#39;这里是要写的注释&#39;</code>：提交代码到仓库<br><code>git remote add origin +gitlab的地址(上上图里红色框的内容)</code>：链接到gitlab服务器<br><code>git push origin master</code>：push代码到服务器<br><code>git remote -v</code>：查看当前文件夹的目标project</p><p>此时刷新一下gitlab的project页面，就看到刚刚的那个<code>testcode.py</code>已经传上来了。如图：<br><img src="/images/gitlab18.png" alt="paradin"></p><p>如果代码有所更改或者出现<code>Everything up-to-date</code>，那么就按顺序执行<code>git add .</code>，<code>git commit -m &#39;这里是要写的注释&#39;</code>，<code>git push origin master</code>即可。</p><h2><span id="免密码push代码">免密码push代码</span></h2><p>在上面的<code>git push origin master</code>的时候需要输入gitlab的用户密码，如要需要免密码push，有两种方法。</p><p>第一种方法是ssh，请看 <a href="https://blog.whsir.com/post-1749.html/comment-page-1#comment-3425" target="_blank" rel="noopener">https://blog.whsir.com/post-1749.html/comment-page-1#comment-3425</a> 。</p><p>第二种方法还是用http的方式传送，但是将密码写进配置文件里：<br>执行<code>git config --global credential.helper store</code>，然后<code>cat ~/.gitconfig</code>，就会看到如下结果：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = chen_shuo@dahuatech.com</span><br><span class="line">name = root</span><br><span class="line">[credential]</span><br><span class="line">helper = store</span><br></pre></td></tr></table></figure></p><p>重新去执行<code>git add .</code>，<code>git commit -m &#39;这里是要写的注释&#39;</code>，<code>git push origin master</code>，就不再需要输入密码了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.cnbluebox.com/blog/2014/04/15/gitlabde-shi-yong/" target="_blank" rel="noopener">https://blog.cnbluebox.com/blog/2014/04/15/gitlabde-shi-yong/</a><br><a href="https://zhang759740844.github.io/2016/08/27/git%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">https://zhang759740844.github.io/2016/08/27/git%E6%8A%80%E5%B7%A7/</a><br><a href="https://www.restran.net/2016/02/23/git-and-gitlab-guide/" target="_blank" rel="noopener">https://www.restran.net/2016/02/23/git-and-gitlab-guide/</a><br><a href="https://www.jianshu.com/p/f54053afecf2" target="_blank" rel="noopener">https://www.jianshu.com/p/f54053afecf2</a></p>]]></content>
    
    <summary type="html">
    
      docker + gitlab，这才是未来部署的方向
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab的汉化过程</title>
    <link href="http://yoursite.com/2018/05/15/Gitlab%E7%9A%84%E6%B1%89%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/15/Gitlab的汉化过程/</id>
    <published>2018-05-15T02:17:51.000Z</published>
    <updated>2018-05-15T12:29:16.804Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="gitlab的容器安装方法">gitlab的容器安装方法</span></h2><p>部署前的第一句话，gitlab是不支持32位系统的！</p><p>gitlab用容器部署的话非常的简单，首先<code>docker pull gitlab/gitlab-ce:latest</code>下载镜像，然后<code>docker run --detach --hostname 本机外网IP --publish 443:443 --publish 80:80 --publish 2222:22 --name gitlab --restart always gitlab/gitlab-ce:latest</code>建立一个容器，如图：<br><img src="/images/gitlab10.png" alt="paradin"></p><p>然后在浏览器的地址栏里输入服务器的外网IP地址，就到了一个更换密码的页面，这个密码就是root的密码，如图：<br><img src="/images/gitlab13.png" alt="paradin"></p><p>设定密码之后，就可以通过root账号登陆gitlab了，如图：<br><img src="/images/gitlab11.png" alt="paradin"></p><p>至于“使用ldsp方式登录”、“配置域名”和“关闭注册功能”请移步去看：<a href="https://rorschachchan.github.io/2018/05/10/在已经运行的docker容器里面使用中文/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/05/10/在已经运行的docker容器里面使用中文/</a> 。</p><h2><span id="gitlab的汉化方法">gitlab的汉化方法</span></h2><p>汉化之前，要确定gitlab的版本，先<code>docker exec -it 容器ID env LANG=C.UTF-8 /bin/bash</code>登陆到容器里，执行<code>cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</code>，由于当时镜像是最新的，所以gitlab的版本是<code>10.7.3</code>。</p><p>还是在容器里，执行<code>git clone https://gitlab.com/xhang/gitlab.git</code>，克隆获取汉化版本库(这里要感谢辛苦的汉化工作者，向你们致敬！)，默认是获取最新的。如果需要下载老版本的汉化包，则要加上老版本的分支，如：<code>git clone https://gitlab.com/xhang/gitlab.git -b v10.2.5-zh</code>。</p><p>然后<code>gitlab-ctl stop</code>先停止gitlab服务，<code>cd gitlab/</code>进入到刚刚下载的那个git包里，执行如下代码：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@10 gitlab]# git fetch</span><br><span class="line">root@10 gitlab]# git diff v10.7.3 v10.7.3-zh &gt; ../10.7.3-zh.diff</span><br><span class="line">root@10 gitlab]# cd ..</span><br><span class="line">root@10 ~]# patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 10.7.3-zh.diff</span><br><span class="line">root@10 ~]# #如果提示没有patch，请执行apt-get update &amp;&amp; apt-get install patch</span><br><span class="line">root@10 ~]# gitlab-ctl start</span><br></pre></td></tr></table></figure></p><p>重新返回到浏览器里，就能看到汉化后的gitlab了，大功告成！<br><img src="/images/gitlab12.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://xuanwo.org/2016/04/13/gitlab-install-intro/" target="_blank" rel="noopener">https://xuanwo.org/2016/04/13/gitlab-install-intro/</a><br><a href="https://www.jianshu.com/p/6606aed59a56" target="_blank" rel="noopener">https://www.jianshu.com/p/6606aed59a56</a><br><a href="http://adairjun.github.io/2016/12/20/gitlab/" target="_blank" rel="noopener">http://adairjun.github.io/2016/12/20/gitlab/</a><br><a href="https://github.com/marbleqi/gitlab-ce-zh/blob/v10.5.1-zh-patch/Nginx.md" target="_blank" rel="noopener">https://github.com/marbleqi/gitlab-ce-zh/blob/v10.5.1-zh-patch/Nginx.md</a><br><img src="/images/kdshotharden.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      为了考虑众多用户尤其是各位领导的英文水平...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>浅析django里models.py、views.py与网页之间的爱恨纠葛</title>
    <link href="http://yoursite.com/2018/05/14/%E6%B5%85%E6%9E%90django%E9%87%8Cmodels-py%E3%80%81views-py%E3%80%81page%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BA%A0%E8%91%9B/"/>
    <id>http://yoursite.com/2018/05/14/浅析django里models-py、views-py、page之间的纠葛/</id>
    <published>2018-05-14T14:04:16.000Z</published>
    <updated>2018-05-15T02:53:10.183Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>环境：<code>django 2.0</code> + <code>python 3.6</code> + <code>pycharm 2018</code>  </p><p>django建立一个app之后就会有<code>models.py</code>、<code>views.py</code>、<code>admin.py</code>这几个文件，他们三个分别的用途如下： </p><ol><li><code>models.py</code>主要是用来设置数据在数据库的存储格式（比如默认值，字段类型和字段长度等等）; </li><li><code>admin.py</code>是用来设置在/admin/后台里面的显示样式; </li><li><code>views.py</code>是用来设置在前台网页里的显示样式； </li><li><code>urls.py</code>是用来编辑域名规则；</li></ol><p><code>admin.py</code>是后台配置的文件，所以对前台网页来说，它不重要，而真正与前端网页相关的就是三个部分：<code>models.py</code>、<code>views.py</code>和对应的网页。  </p><p>举个例子，假设有一个<code>models.py</code>，内容如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models     </span><br><span class="line">from django.contrib.auth.models import User   </span><br><span class="line">   </span><br><span class="line">class BlogType(models.Model):         </span><br><span class="line">type_name = models.CharField(max_length=15)    #规定type_name是一个最大为15字节的charfield          </span><br><span class="line">def __str__(self):             </span><br><span class="line">return &apos;&lt;BlogType:%s&gt;&apos; % self.type_name</span><br></pre></td></tr></table></figure></p><p>然后随便加入一些内容，如图：<br><img src="/images/type_name1.png" alt="paradin">   </p><p>而在<code>views.py</code>里，要求在前端网页里如此的显示：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render_to_response,get_object_or_404     </span><br><span class="line">from .models import Blog,BlogType    #这里引用了models.py里的那两个class </span><br><span class="line">    </span><br><span class="line">def blog_list(request):         </span><br><span class="line">context = &#123;&#125;         </span><br><span class="line">context[&apos;blog_types&apos;] = BlogType.objects.all()         </span><br><span class="line">return render_to_response(&apos;pageblog/blog_list.html&apos;,context)</span><br></pre></td></tr></table></figure></p><p>在<code>views.py</code>里规定，如果有访问域名是<code>/blog_list/</code>的网页，就返回<code>pageblog/blog_list.html</code>这个页面，而这个<code>blog_list.html</code>只是一个框架，里面的内容是<code>context</code>。<code>context</code>本身是一个字典，里面的里面的key对应的value是用ojbects这个函数获得的，<code>objects.all()</code>就是获取全部的意思。用来填充blog_list.html的context里面有blogs和blog_types两个key。</p><p>那么现在就可以在<code>blog_list.html</code>里使用<code>blog_types</code>这个key了，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 前面略 --&gt;     </span><br><span class="line">&lt;h4&gt;博客分类&lt;/h4&gt;     </span><br><span class="line">&lt;h3&gt; &#123;&#123; blog_types&#125;&#125; &lt;/h3&gt;     </span><br><span class="line">&lt;!-- 后面略 --&gt;</span><br></pre></td></tr></table></figure></p><p>这样的效果如下：<br><img src="/images/type_name2.png" alt="paradin">  </p><p>返回的是<code>QuerySet</code>类型，<code>QuerySet</code>是Django的查询集，可以通过<code>QuerySet</code>条件查询得到对应模型的对象集合。由此看出<code>blog_types</code>已经成功的引入到了<code>blog_list.html</code>里。</p><p>至于拆成每一个“博客类型”就很简单了，html部分如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;博客分类&lt;/h4&gt;                 </span><br><span class="line">&lt;!-- ul是无项目的标签 --&gt;                 </span><br><span class="line">&lt;ul&gt;                     </span><br><span class="line">&#123;% for blog_type in blog_types%&#125;    #开始一个for循环                         </span><br><span class="line">&lt;li&gt;&lt;a href=&quot;&#123;% url &apos;blogs_with_type&apos; blog_type.pk %&#125;&quot;&gt;&#123;&#123; blog_type.type_name &#125;&#125; &lt;/a&gt;&lt;/li&gt;        #对每一个类型加上一个a链接                     </span><br><span class="line">&#123;% empty %&#125;        #如果唯空就说“暂无分类”                         </span><br><span class="line">&lt;!--  li是具体的项目 --&gt;                         </span><br><span class="line">&lt;li&gt; 暂无分类 &lt;/li&gt;                     </span><br><span class="line">&#123;% endfor %&#125;                     </span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      搞明白这个，就算明白django之间几个核心文件的关系了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>加载css样式的两个方法</title>
    <link href="http://yoursite.com/2018/05/12/%E5%8A%A0%E8%BD%BDcss%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/12/加载css样式的两个方法/</id>
    <published>2018-05-12T07:27:19.000Z</published>
    <updated>2018-05-15T03:36:24.864Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="背景说明">背景说明</span></h2><p>环境： <code>django 2.0</code>+<code>python 3.6</code>+<code>pycharm 2018</code><br>project名称: <code>blog</code></p><h2><span id="普通的网页加载css">普通的网页加载css</span></h2><p>网页使用了css才会更好看更炫酷，一般情况下的网页是这样的：<br><img src="/images/css0.png" alt="akb48"></p><p>上面这个html文件里用到了模板，而且又对div和 a标签做了class定义，最后分别对各自的class进行了css说明。整个文档看下来比较直观。</p><p>但是这样就会有一个问题，就是把html内容和css内容写到了一起，一般来说为了后期维护，都会把css单独写到一个文件夹里，然后让这个html来引用这个css文件夹的具体某个css文件。</p><p>于是，我们就在<code>blog</code>这个project目录下建立一个叫static的文件夹，用它来专门装<code>css\js</code>这样的静态文件。</p><p>首先，建立了这个static文件，肯定就涉及到引用的问题，而如何让django可以识别static呢？</p><p>打开<code>blog/settings.py</code>这个文件，这个文件是整个project的配置文件，在文件末尾加上这样的话，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将项目根目录里的static制定成项目的静态文件夹,这样django就可以识别</span><br><span class="line">#注意，static前面没有&apos;/&apos;</span><br><span class="line">STATICFILES_DIRS = [os.path.join(BASE_DIR, &apos;static&apos;),]</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>这样blog这个根目录就可以识别了<code>static</code>文件夹了。</p><p>然后在pycharm里新建一个css文件叫<code>base.css</code>，如果是专业版的pycharm是可以直接建立css类型文件的，免费社区版是没有这个功能。再将原文里面的所有关于css的内容拷贝到这个<code>base.css</code>里，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">margin: 5px;</span><br><span class="line">padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav &#123;</span><br><span class="line">background-color: gold;</span><br><span class="line">border-bottom: 2px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav a&#123;</span><br><span class="line">text-decoration:none;</span><br><span class="line">color: blue;</span><br><span class="line">padding: 5px 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav a.logo&#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">font-size: 120%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存之后，为了验证django是否成功的识别此文件，可以在浏览器里输入<code>外网IP：端口号/static/base.css</code>查看是否返回就是上面内容，如果是就代表识别成功，如果是404就要重新检查<code>settings.py</code>了。</p><p>在原有的html里删除掉<code>&lt;style&gt;</code>标签内css内容，还要在head里添加一句话：<code>&lt;link  rel=&quot;stylesheet&quot; href=&quot;/static/base.css&quot;&gt;</code>,如下：<br><img src="/images/css1.png" alt="akb48"></p><p>这样就达到了引用css所在的static文件夹的目的。</p><h2><span id="django内部的加载css方法">Django内部的加载css方法</span></h2><p>上面说的是普通html加载css的方法，而django内部也有自己的一套方法，再次打开settings.py里看到有如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [   </span><br><span class="line"> <span class="string">'django.contrib.admin'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.auth'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.contenttypes'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.sessions'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.messages'</span>,    </span><br><span class="line"> <span class="string">'django.contrib.staticfiles'</span>,   </span><br><span class="line"> <span class="string">'blog'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>上面的<code>django.contrib.staticfiles</code>就是django的css加载方法，使用这个方法也很简单。</p><p>首先要在html文件最上面先声明要调用这个方法:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&#123;# 这个staticfiles是django自带的，可以在settings文件里看到 #&#125;</span><br></pre></td></tr></table></figure></p><p>然后把link标签改成如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link  rel=&quot;stylesheet&quot; href=&quot;&#123;% static &apos;base.css&apos; %&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>保存文件刷新即可，而且用了这种方法，在chrome浏览器里F12 查看，会解析成普通模式的方法，如图：<br><img src="/images/css2.png" alt="akb48"></p><font color="red">在django项目里，还是更推荐用django的方法。</font><h2><span id="额外补充">额外补充</span></h2><p>如果html文件开头声明引用了某个模板，比如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &apos;base.html&apos; %&#125;#声明引用了base.html这个模板</span><br><span class="line">&#123;% load staticfiles %&#125;</span><br></pre></td></tr></table></figure></p><p>那么<code>extends</code>语句必须在最上面，不然就会报错：<code>TemplateSyntaxError at /&lt;ExtendsNode: extends &#39;base.html&#39;&gt; must be the first tag in the template.</code></p>]]></content>
    
    <summary type="html">
    
      如果html里没有header这个标签，就需要在模板文件里面新加一个块，在块里声明css的地址
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="前端技术" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>创建Mysql容器过程</title>
    <link href="http://yoursite.com/2018/05/12/%E5%88%9B%E5%BB%BAMysql%E5%AE%B9%E5%99%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/12/创建Mysql容器过程/</id>
    <published>2018-05-12T02:28:46.000Z</published>
    <updated>2018-05-15T03:28:57.952Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="过程记录">过程记录</span></h2><p>先<code>docker pull mysql</code>，当前最近的版本是8.0，然后<code>docker images</code>查看一下效果。</p><p>然后就是启动一个容器，命令是：<code>docker run --name test-mysql -p 3306:3306 -e MYSQL\_ROOT\_PASSWORD=123456 -d mysql</code>,这句话的意思是：启动一个叫test-mysql的容器， 端口影射是3306到宿主机的3306，同时设置root的密码是123456，然后以守护进程的形式启动。</p><p>但是如果在宿主机上使用<code>mysql -h127.0.0.1 -uroot -p123456</code>可能会报错，报错内容是：<code>Authentication plugin ‘caching_sha2_password’ cannot be loaded:</code></p><p>那么就<code>docker exec -it 容器ID号 env LANG=C.UTF-8 /bin/bash</code>进入到容器里，使用<code>mysql -uroot -p123456</code>，看一下在容器里是否可以正常登录，如果可以的话，那么就在mysql的命令行里执行<code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code>。  </p><p>退出容器在宿主机上重新连接，这样就OK了。至于原因就是，mysql的客户端是yum安装的，虽然是centos 7，但是安装的版本也是5.5版本的，所以8.0的客户端有一个新的密码加密方式：<code>caching_sha2_password</code>，客户端不支持，所以需要手动到命令行里更改一下。</p><h2><span id="mysql存储的坑">mysql存储的坑</span></h2><p>先思考一个问题：假如某mysql容器里存储了100G的数据，那么这个容器关闭了，这100G的数据还在么？从宿主机是可以找到这100G的数据么？</p><p><code>docker inspect mysql-container-id</code>，找到里面的volume字段，这里也显示挂载的host路径，可以通过这个路径来备份数据。或者使用<code>docker cp mysql-container-id:/path/to/db-backup-file ./</code>，把容器内数据放到当前目录下。如果是生产环境，必须使用Volume或数据容器。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://binary-space.iteye.com/blog/2412769" target="_blank" rel="noopener">http://binary-space.iteye.com/blog/2412769</a><br><a href="http://dockone.io/question/108" target="_blank" rel="noopener">http://dockone.io/question/108</a><br><img src="/images/rondopass1.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      据说mysql的容器坑很多...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="docker容器" scheme="http://yoursite.com/tags/docker%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>python报错：importError: No module named bz2</title>
    <link href="http://yoursite.com/2018/05/12/python%E6%8A%A5%E9%94%99%EF%BC%9A&#39;importError-No-module-named-bz2&#39;/"/>
    <id>http://yoursite.com/2018/05/12/python报错：&#39;importError-No-module-named-bz2&#39;/</id>
    <published>2018-05-12T02:08:07.000Z</published>
    <updated>2018-05-12T04:19:32.054Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>每日统计阿里云同步延迟的邮件早就编写完毕了，现在要放到专门跑脚本的服务器里，进去到这个服务器里发现这个机器已经被人装了两个python，分别是python 2.7.5（默认路径）和python 2.7.13（路径是<code>/usr/local/python/bin/python</code>），说实话我个人不太明白这么做的原因何在。</p><p>但是既然已经被人搞成这样了，那就适应环境吧，把脚本拷贝过来，把依赖库都安装好，但是在执行<code>matplotlib</code>的库的时候，爆了一个错误：<code>ImportError: No module named bz2</code>。</p><p>这就是因为两个python，但是启动的那个python文件夹里面是没有<code>bz2.so</code>这个文件的，于是就需要把系统里默认的2.7.5的<code>bz2.so</code>拷贝到2.7.13的lib路径里。</p><p>首先<code>find / -name bz2.so</code>找一下文件，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dvl-stun-002 GETDTS]# find / -name bz2.so</span><br><span class="line">/usr/local/aegis/PythonLoader/lib/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br><span class="line">/usr/local/aegis/SecureCheck/lib/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br><span class="line">/usr/lib64/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br></pre></td></tr></table></figure></p><p>然后<code>cd /usr/local/python/lib/python2.7/</code>，把<code>/usr/lib64/python2.7/lib-dynload/bz2.so</code>复制到这个文件夹里即可。<br><img src="/images/rubio3kill.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      双python的蛋疼...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>在已经运行的docker容器里面使用中文</title>
    <link href="http://yoursite.com/2018/05/10/%E5%9C%A8%E5%B7%B2%E7%BB%8F%E8%BF%90%E8%A1%8C%E7%9A%84docker%E5%AE%B9%E5%99%A8%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/"/>
    <id>http://yoursite.com/2018/05/10/在已经运行的docker容器里面使用中文/</id>
    <published>2018-05-10T14:52:57.000Z</published>
    <updated>2018-05-14T14:27:43.370Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="配置ldap">配置ldap</span></h2><p>公司搭建的gitlab现在需要开启ldap服务，也就是这样就可以用公司的域账号登陆gitlab，而不用开发一个一个去注册账号了。</p><p>开启ldap登陆的任务光荣了落到了我的身上，于是我就登陆到gitlab服务器一看，嚯，这还是在容器下启动的，如图：<br><img src="/images/gitlab2.png" alt="paradin"></p><p>于是我就<code>docker exec -it 容器ID号 /bin/bash</code>登陆到这个容器里，编辑<code>/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</code>，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ldap:    </span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  sync_time:</span><br><span class="line">  host: <span class="string">'公司域账号服务器IP地址'</span></span><br><span class="line">  port: <span class="number">389</span></span><br><span class="line">  uid: <span class="string">'sAMAccountName'</span></span><br><span class="line">  method: 'plain' # "tls" or "ssl" or "plain"</span><br><span class="line">  bind_dn: <span class="string">'dahuatech\Ldap_System'</span></span><br><span class="line">  password: <span class="string">'对应的密码'</span></span><br><span class="line">  active_directory:</span><br><span class="line">  allow_username_or_email_login:    </span><br><span class="line">  lowercase_usernames:</span><br><span class="line">  base: </span><br><span class="line">  user_filter:</span><br></pre></td></tr></table></figure></p><p>但是在填写到base的时候发现了一个问题，公司的base是中文的，是<code>&#39;OU=大数据研究院,OU=研发中心,OU=大华技术,DC=dahuatech,DC=com&#39;</code>，但是在文件里输入中文却是乱码，如图：<br><img src="/images/gitlab3.png" alt="paradin"></p><p>容器默认是不支持中文的，在容器里的命令行输入中文也是空白。那么面对一个已经运行的容器，如何正常的输入中文呢？</p><p>答案是：使用<code>docker exec -it 容器ID号 env LANG=C.UTF-8 /bin/bash</code>登陆，这样就能正常使用中文了，如图：<br><img src="/images/gitlab1.png" alt="paradin"></p><p><code>gitlab-ctl restart</code>之后，登陆到gitlab页面一看，已经添加ldap访问方式：<br><img src="/images/gitlab4.png" alt="paradin"></p><h2><span id="取消注册功能">取消“注册”功能</span></h2><p>修改好配置文件<code>gitlab.yml</code>之后，现在就要把“注册”功能去掉，这样以后都统一用公司的域账号登陆，避免一些乱七八糟的用户来注册乱七八糟的账号。</p><p>首先用root账号登陆到<code>gitlab</code>里，在网页里进入到<code>admin area</code>，如图：<br><img src="/images/gitlab8.png" alt="paradin"></p><p>然后再点击最下面的<code>settings</code>，选择<code>Sign-up restrictions</code>，然后把<code>Sign-up enabled</code>前面的勾点掉，如图：<br><img src="/images/gitlab9.png" alt="paradin"></p><p>保存改变之后，退出root账号，重新看一下，gitlab的注册功能就暂时被取消了，需要的时候再开即可。</p><h2><span id="配置域名">配置域名</span></h2><p>为了方便记忆，给gitlab服务配置一个域名，在阿里云的域名解析控制台给gitlab配置了域名之后，还要在<code>gitlab.yml</code>手动更改hostanme，把hostname改成域名的样子，如图：<br><img src="/images/gitlab5.jpg" alt="paradin"></p><p>这样没有结束，因为网页里的url还是显示外网IP而非域名,如下：<br><img src="/images/gitlab7.png" alt="paradin"></p><p>此时需要重启，重启的命令是<code>gitlab-ctl restart</code>，重启完了之后url也会发生变化。这样才算完整的配置了域名：<br><img src="/images/gitlab6.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      如果要是dockerfile里都直接使用中文就更好了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>通过阿里云服务器ID添加服务器资料到django的脚本</title>
    <link href="http://yoursite.com/2018/05/07/%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ID%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%96%99%E5%88%B0django%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/05/07/通过阿里云服务器ID添加服务器资料到django的脚本/</id>
    <published>2018-05-07T13:48:29.000Z</published>
    <updated>2018-05-12T06:13:54.179Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文的环境是：<code>centos 7</code> + <code>django 2.0</code> + <code>python 3.6</code></p><p>先给django里的project创建了<code>models.py</code>，里面内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">class ecs(models.Model):</span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">'云服务器名称'</span>,max_length=<span class="number">30</span>)</span><br><span class="line">    ecsid = models.CharField(verbose_name=<span class="string">'云服务器ID'</span>,max_length=<span class="number">30</span>,<span class="keyword">default</span>=<span class="string">''</span>)</span><br><span class="line">    inIP = models.GenericIPAddressField(verbose_name=<span class="string">'云服务器内网地址'</span>)</span><br><span class="line">    outIP = models.GenericIPAddressField(verbose_name=<span class="string">'云服务器外网地址'</span>)</span><br><span class="line">    osname = models.CharField(verbose_name=<span class="string">'操作系统'</span>,max_length=<span class="number">50</span>,<span class="keyword">default</span>=<span class="string">''</span>)</span><br><span class="line">    networktype = models.CharField(verbose_name=<span class="string">'网络类型'</span>,max_length=<span class="number">20</span>)</span><br><span class="line">    CPU = models.IntegerField(verbose_name=<span class="string">'云服务器CPU'</span>,<span class="keyword">default</span>=<span class="string">'2'</span>)</span><br><span class="line">    memory = models.IntegerField(verbose_name=<span class="string">'云服务器内存'</span>,<span class="keyword">default</span>=<span class="string">'2048'</span>)</span><br><span class="line">    netwidth = models.IntegerField(verbose_name=<span class="string">'云服务器外网带宽'</span>,<span class="keyword">default</span>=<span class="string">'0M'</span>)</span><br><span class="line">    signtime = models.DateField(auto_now_add=True)</span><br><span class="line">    remark = models.CharField(verbose_name=<span class="string">'备注'</span>,max_length=<span class="number">255</span>,blank=True)</span><br></pre></td></tr></table></figure></p><p>可以看出这个就是一个很简单的云服务器的配置统计，但是要录入的阿里云服务器很多，一个一个手动输入实在太累，于是就要写一个脚本来达到django同步的效果！</p><p>脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本通过查询阿里云服务器ID来达到同步django的目的</span><br><span class="line"><span class="keyword">import</span> json,pymysql</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> DescribeInstancesRequest</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'这里是ak'</span>,<span class="string">'这里是sk'</span>,<span class="string">'这里是地域名'</span>)</span><br><span class="line"></span><br><span class="line"># 设置参数</span><br><span class="line">request = DescribeInstancesRequest.DescribeInstancesRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line">request.add_query_param(<span class="string">'RegionId'</span>, <span class="string">'cn-hangzhou'</span>)</span><br><span class="line">request.add_query_param('InstanceIds', ['这里是服务器ID'])#如果是多个服务器ID，可以继续往下写</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action(request)</span><br><span class="line"></span><br><span class="line">#print(response)#这里可以看一下返回的response，但是它是byte格式的</span><br><span class="line">data=str(response, encoding = <span class="string">"utf-8"</span>)</span><br><span class="line">ecs = json.loads(data)#转换成str格式</span><br><span class="line">name = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceName'</span>])</span><br><span class="line">ecsid = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceId'</span>])</span><br><span class="line">inIP = str(ecs['Instances']['Instance'][0]['VpcAttributes']['PrivateIpAddress']['IpAddress'])[1:-1]#如果不加[1:-1]的话，得到的是一个IP外面还有中括号</span><br><span class="line">outIP = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'PublicIpAddress'</span>][<span class="string">'IpAddress'</span>])[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line">networktype = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceNetworkType'</span>])</span><br><span class="line">CPU = int(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'Cpu'</span>])</span><br><span class="line">memory = int(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'Memory'</span>])</span><br><span class="line">osname = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'OSName'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建数据库连接，注意这里我加入了charset和cursorclass参数</span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host = <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    user = <span class="string">"数据库账号"</span>,</span><br><span class="line">    password = <span class="string">"数据库密码"</span>,</span><br><span class="line">    database = <span class="string">"数据库名称"</span>,</span><br><span class="line">    charset = <span class="string">'utf8'</span>,</span><br><span class="line">    cursorclass = pymysql.cursors.DictCursor)</span><br><span class="line">#获取游标</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">#三个引号里如何加入变量</span><br><span class="line">sql = <span class="string">""</span><span class="string">"INSERT INTO ecs_ecs (name,ecsid,inIP,outIP,networktype,CPU,memory,netwidth,signtime,osname) VALUES (%(name)s,%(ecsid)s,%(inIP)s,%(outIP)s,%(networktype)s,%(CPU)d,%(memory)d,%(netwidth)d,NOW(),%(osname)s);"</span><span class="string">""</span> % dict(name=<span class="string">'\''</span>+name+<span class="string">'\''</span>,ecsid= <span class="string">'\''</span>+ecsid+<span class="string">'\''</span>,inIP=inIP,outIP=outIP,networktype=<span class="string">'\''</span>+networktype+<span class="string">'\''</span>,CPU=CPU,memory=memory,netwidth=<span class="number">1</span>,osname=<span class="string">'\''</span>+osname+<span class="string">'\''</span>)</span><br><span class="line"></span><br><span class="line">#print (sql)#在这里可以先看看sql输出的是否正确</span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"># 关闭数据库连接</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></p><p>正常来说应该是先建立一个def来获取阿里云服务器配置，再来一个def来将各配置录入到数据库里，同时让阿里云服务器的id作为变量，而且还要加上如果sql执行失败就回滚的语句。而我由于是临时使用，所以这个脚本按照流水式写下来的，不过不影响阅读。</p><p>ps.进化之后的脚本在我的github里，地址是： <a href="https://github.com/RorschachChan/chenWORK/blob/master/通过阿里云ID号将服务器信息同步到django.py" target="_blank" rel="noopener">https://github.com/RorschachChan/chenWORK/blob/master/通过阿里云ID号将服务器信息同步到django.py</a></p><p>比如现在要添加一个服务器，这个服务器的id是：<code>i-bp12ego6x9srzsytxeqo</code>，如图：<br><img src="/images/django3.png" alt="akb48"></p><p>那么对应填写好脚本里的ak/sk之后，就把<code>i-bp12ego6x9srzsytxeqo</code>填写到“服务器ID”的位置 ，执行这个脚本，结果如下：<br><img src="/images/django5.png" alt="akb48"></p><p>不过这个脚本有两个缺点：<br>第一：如果阿里云服务器是中文名称，那么使用api查询出现的是十六进制的符号；<br>第二：如果服务器里没有外网IP或者是后开的临时带宽，那么在outIP的地方得到的值是空，sql语句会因为少一项而报错；<br>第三：这个api没有查询服务器带宽值的功能，还需要另外写一个脚本搭配。</p>]]></content>
    
    <summary type="html">
    
      最近我又把django捡起来了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python3" scheme="http://yoursite.com/tags/python3/"/>
    
      <category term="django2" scheme="http://yoursite.com/tags/django2/"/>
    
  </entry>
  
  <entry>
    <title>记一次nginx负载均衡配置问题</title>
    <link href="http://yoursite.com/2018/04/28/%E8%AE%B0%E4%B8%80%E6%AC%A1nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/28/记一次nginx负载均衡配置问题/</id>
    <published>2018-04-28T13:48:40.000Z</published>
    <updated>2018-04-28T14:00:42.648Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="故障背景">故障背景</span></h2><p>公司有三个实体服务器，内网IP分别是<code>10.1.82.83</code>、<code>10.1.82.84</code>、<code>10.1.82.113</code>，这三个作为源站使用专线连接到了阿里云的一台nginx服务器上，并且通过这个nginx做负载均衡展示这三个服务器里面的网页。负载均衡使用的是<code>nginx 1.12</code>版本，最外面在上一个CDN起到静态页面加速的作用。整个架构如图：<br><img src="/images/aliCDN2.png" alt="paradin"></p><p>CDN的配置界面如下：<br><img src="/images/aliCDN6.png" alt="paradin"></p><p>但是现在很奇怪的是，所有节点启动之后，外网用户通过负载后访问均指向了<code>10.1.82.84</code>这一台服务器，<code>nginx.conf</code>配置是<code>最小连接数</code>的配置，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">upstream eln.dahuatech.com &#123;</span><br><span class="line">      #ip_hash;</span><br><span class="line">      #hash $http_x_forwarded_for;</span><br><span class="line">      #sticky;</span><br><span class="line">      least_conn;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.83</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.84</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.113</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        server_name  eln.dahuatech.com;</span><br><span class="line">            listen     <span class="number">80</span>;</span><br><span class="line">            listen     <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">        access_log logs/eln.dahuatech.com.access.log main;</span><br><span class="line">        error_log  logs/eln.dahuatech.com.error.log;</span><br><span class="line"></span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//eln.dahuatech.com;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试的时候发现，即使绑定美国和香港的节点去<code>curl</code>，是能正常解析到其他机器上的。如下：<br><img src="/images/aliCDN3.png" alt="paradin"></p><p>然而源站过来的请求IP集中到了只有一个，这太奇怪了。</p><h2><span id="故障解决">故障解决</span></h2><p>后来发现ngnix后端会把http1.1转换成1.0变成短连接，这个连接存在的时间非常短，因为后端响应非常快。所以即使配上了<code>least_conn</code>，其实是没有任何效果的。这样负载均衡的nginx看到所有源站其实一直都是没有连接的，所以也就一直在给第一个转。</p><p>既然这样，就取消了<code>least_conn</code>改用轮询，nginx.conf也改成如下的样子：<br><img src="/images/aliCDN1.png" alt="paradin"></p><p>最后终于均衡了，大功告成！<br><img src="/images/aliCDN5.png" alt="paradin"></p><p>后来琢磨了一下，是用sticky其实也是OK的。</p><h2><span id="几个主流负载均衡软件配置cookie的方法">几个主流负载均衡软件配置cookie的方法</span></h2><p>1.Apache的话首先打开<code>httpd.conf</code>配置文件，确保如下配置没有被注释。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule usertrack_module modules/mod_usertrack.so</span><br></pre></td></tr></table></figure></p><p>再在<code>virtual host</code>中添加以下配置。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CookieName name</span><br><span class="line">CookieExpires <span class="string">"1 days"</span></span><br><span class="line">CookieStyle Cookie</span><br><span class="line">CookieTracking on</span><br></pre></td></tr></table></figure></p><p>2.Nginx参考以下配置，设置Cookie。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">8080</span>;</span><br><span class="line">    server_name wqwq.example.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">      add_header <span class="built_in">Set</span>-Cookie name=xxxx;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.Lighttpd参考以下配置，设置Cookie。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.modules  = ( <span class="string">"mod_setenv"</span> )</span><br><span class="line">$HTTP[<span class="string">"host"</span>] == <span class="string">"test.example.com"</span> &#123;</span><br><span class="line">      server.document-root = <span class="string">"/var/www/html/"</span></span><br><span class="line">      setenv.add-response-header = ( <span class="string">"Set-Cookie"</span> =&gt; <span class="string">"name=XXXXXX"</span>      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="扩展阅读">扩展阅读</span></h2><p><a href="https://cloud.tencent.com/document/product/214/2736" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/214/2736</a><br><a href="http://blog.text.wiki/2015/08/01/nginx-sticky-problem.html" target="_blank" rel="noopener">http://blog.text.wiki/2015/08/01/nginx-sticky-problem.html</a><br><a href="https://cloud.tencent.com/developer/article/1004547" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1004547</a></p>]]></content>
    
    <summary type="html">
    
      真正站在运维的层面讲nginx的书不多的...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>记一次阿里云oss云存储删除失败的问题</title>
    <link href="http://yoursite.com/2018/04/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E5%88%A0%E9%99%A4%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/27/记一次阿里云oss云存储删除失败的问题/</id>
    <published>2018-04-27T14:24:58.000Z</published>
    <updated>2018-04-27T14:49:33.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>公司每天云存储都要删除过期的内容，工作细节是这样的：每天零点，采集模块开始收集应该删除掉的内容，然后把这个消息传给阿里云MQ，阿里云MQ又把消息传给删除模块，删除模块拿到名单之后，开始调用阿里云OSS的删除API进行删除。架构如图：<br><img src="/images/oss6.png" alt="paradin"></p><p>但是今天登陆监控平台发现，昨天oss没有删除，上涨了80多个T，如图：<br><img src="/images/oss1.png" alt="paradin"></p><p>老板一看，卧槽这怎么可以，80多个T的云存储费用可是不容小视的，于是责令追查一下为啥会发生这样的情况。</p><p>昨天我的手机又没有收到任何阿里云消息队列告警的信息，可见MQ应该是没问题的，查看一下是否有MQ的产生和消费情况，如下图：<br><img src="/images/oss2.png" alt="paradin" title="这个是消息产生情况"></p><p><img src="/images/oss3.png" alt="paradin" title="这个是消息消费情况"></p><p>产生的消息基本都消费掉了，由此推断之前的过程都应该是OK的。再查看一下会不会是删除模块外网带宽到期的问题，此时发现两天的流量有显著的不同：<br><img src="/images/oss7.png" alt="paradin" title="这个是正常的流量情况"></p><p><img src="/images/oss8.png" alt="paradin" title="这个是异常的流量情况"></p><p>流量明显减少，可以说是删除模块执行任务少了。于是到执行OSS删除API的模块上去抓了几个包，里面情况如下：<br><img src="/images/oss4.png" alt="paradin"></p><p>但是跑到阿里云对应的bucket里看一下文件情况，比如<code>https://lechangecloud.oss-cn-hangzhou.aliyuncs.com/lechange/4B01F1FPAGE4E9D_img/Alarm/20180427000913997_0_fa62bec6dee24cc0bee42e1ee3e75743_thumb_qcif.dav</code>这个文件，这个文件明明还在里面躺着好好的。如图：<br><img src="/images/oss5.png" alt="paradin"></p><p>文件00：27的时候就在了，但是2：53分的时候调用阿里云OSS的API去删除，明明返回了200，但是文件却没有真正的从OSS删除掉。</p><p>我觉得这样就拿去跟阿里云撕逼还是有点不太妥当，又回到刚刚的那个包里，我发现里面还有一些返回的内容是这样的：<br><img src="/images/oss9.png" alt="paradin"></p><p>这个图跟之前的图明显路径上不同，而这些文件在OSS上确认是被成功删除掉的，可见的确是文件路径的问题：失败的文件路径是完全路径，而成功的都是相对路径。于是就告诉开发赶快整改代码，把路径统一…</p><p><img src="/images/朝韩会面.png" alt="paradin" title="历史性的会面"></p>]]></content>
    
    <summary type="html">
    
      这一周六天班通宵了三次...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>在安装docker私有仓库的时候遇到的openssl问题</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9C%A8%E5%AE%89%E8%A3%85docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84openssl%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/21/在安装docker私有仓库的时候遇到的openssl问题/</id>
    <published>2018-04-20T16:45:39.000Z</published>
    <updated>2018-04-26T15:30:53.852Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>按照<a href="http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html</a> 的方法本地安装一个私有仓库，在执行<code>sudo pip install docker-registry</code>这一步的时候，出现了这样的一个错误：<br><img src="/images/openssl1.png" alt="paradin"></p><p>既然说我没有swig，于是我<code>yum install swig -y</code>，安装的是<code>2.0.10-5.el7</code>版本。然后再次<code>pip install docker-registry</code>，一顿噼里啪啦之后，这次成了这样：<br><img src="/images/openssl2.png" alt="paradin"></p><p>又说没有openssl的文件，那执行<code>yum install openssl-devel</code>，OK了之后再次<code>pip install docker-registry</code>，再一次噼里啪啦，如下：<br><img src="/images/openssl3.png" alt="paradin"></p><p>反馈我：<code>/usr/include/openssl/opensslconf.h:44: Error: CPP #error &quot;&quot;This openssl-devel package does not work your architecture?&quot;&quot;. Use the -cpperraswarn option to continue swig processing.</code>,这个提示大意是说openssl-devel版本不适合你的系统架构，也就是x86的去找x86的头文件，x86_64的去找x86_64文件，但现在是互相找不到对方。</p><p>既然说<code>/usr/include/openssl/opensslconf.h</code>这个第44行有错误，那我们就打开这个文件去看看第44行写的是啥：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include "opensslconf-x86_64.h"</span><br><span class="line">43 #else</span><br><span class="line">44 #error "This openssl-devel package does not work your architecture?"</span><br><span class="line">45 #endif</span><br><span class="line"><span class="number">46</span> </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p><p>这里我把第44行改成了这样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include &quot;opensslconf-x86_64.h&quot;</span><br><span class="line">43 #else</span><br><span class="line">44 #include &quot;opensslconf.h&quot;    #去掉了原来的error提示，改成了安装opensslconf.h文件。</span><br><span class="line">45 #endif</span><br><span class="line">46 </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p><p>这一次重新执行<code>sudo pip install docker-registry</code>，终于成功…<br><img src="/images/openssl4.png" alt="paradin"></p><p><img src="/images/agirl.gif" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      这破玩意查了半天...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="容器技术" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在国王杯前夕评巴萨</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9C%A8%E5%9B%BD%E7%8E%8B%E6%9D%AF%E5%89%8D%E5%A4%95%E8%AF%84%E5%B7%B4%E8%90%A8/"/>
    <id>http://yoursite.com/2018/04/21/在国王杯前夕评巴萨/</id>
    <published>2018-04-20T16:44:17.000Z</published>
    <updated>2018-04-20T17:40:54.008Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天凌晨的马竞在西甲意外输给了皇家社会，巴萨的积分优势扩大到了12分。这个周末巴萨要跟塞维利亚打国王杯决赛，4月30号对拉科鲁尼亚的西甲联赛巴萨只要获胜，就会拿到今年的西甲联赛冠军，从而以冠军姿态在诺坎普迎接本赛季第二场国家德比。</p><h2><span id="巴尔韦德的困境">巴尔韦德的困境</span></h2><p>巴萨今年可以说是低姿态开始：从内马尔突然的离开到西超杯被皇马灌了5个，不可为说不惨。但是巴尔韦德在联赛却目前保持不败，这个成绩单可以说是相当不错的，这中间还有在伯纳乌的三球胜利。</p><p>赛季中前段，巴萨三线顺风顺水，前有塞梅多惊艳开场，后有大祭司维尔马伦扎实顶上，主教练巴尔韦德也给了阿奈斯这样小将出场机会，哪怕登贝莱那时候养伤，报纸媒体一片其乐融融。如果保利尼奥再有进球，更是一片狂欢。</p><p>然后巴尔韦德的保守开始慢慢让人所诟病，他是一个重视防守的教练，这很好，但是他有了库迪尼奥也有了归来的登贝莱，结果反而不敢搞轮换，甚至坚持让布教授打封闭出场，虽然不少人抱怨，但是由于球队整体战绩还算平稳，所以没有大规模的重视。可是巴萨欧冠的结果跟恩里克的第二个赛季一样，倒在了与罗马的第二回合比赛里，连续三年没有闯入欧冠四强。</p><p>其实对战罗马的第一回合，巴萨的4：1已经是靠意志拼下来的比赛，球员难免在第二回合的心态上有所轻敌，这种心态上的轻敌难免会影响到身体，但是巴尔韦德的临场指挥也让人严重不满。落下这耻辱一战，媒体和球迷之前的“忍气吞声”一并爆发，狂轰滥炸，直到现在依旧有人说“哪怕真的赛季双冠，也会因为欧冠的失利而让那两冠索然无味”。<br><img src="/images/fcb4.png" alt="paradin"></p><p>所以，巴尔韦德要在这个周日的国王杯决赛和对阵拉科鲁尼亚的西甲联赛里稳扎稳打，把国王杯和西甲冠军彻底拿到手里，这样整个人也能轻松一些。可是说来说去罗马一役这一个跟头摔得太疼了，在那么重大的比赛里失败，肯定需要在一个同样重大的比赛里胜利以挽回颜面，第二回合的国家德比无疑就是一个好的机会，如果巴尔韦德成功捍卫了诺坎普，“联赛双杀皇马+国内双冠”也能成为一个功劳。但是如果那场比赛，一心要打破巴萨不败金身的皇马真的成功了，那巴尔韦德势必在巴萨主帅的位置上也是飘摇。</p><p>所以巴帅，请务必要拿下国王杯冠军+西甲冠军！在第二个国家德比里也请拼尽全力！这样才能多少挽回一点“罗马之耻”的颜面。<br><img src="/images/fcb1.png" alt="paradin"></p><h2><span id="夏季转会展望">夏季转会展望</span></h2><p>我个人认为，巴萨很有可能在今年夏天卖掉如下几个人：西莱森、戈麦斯、小苏亚雷斯、艾尔卡塞尔、比达尔，自由走人的可能会是小白。这些人能套现7000万应该就满足了。</p><p>巴萨后卫现在四个人皮克和维尔马伦属于潜藏的伤员病号，米纳技术还是太糙，稍微让人放心的就是乌姆蒂蒂，他的续约问题肯定是休赛期的一个大事。不过我觉得米纳其实可以再留一年看看，他身体素质很好，而且人还年轻没伤病，只要心态练得沉稳，当一个合格的中后卫不难。</p><p>至于中场，个人希望小白再踢一年，现在我也觉得一个满血的小白应付普通的联赛、欧冠小组赛和杯赛都不是什么难事。但是目前的媒体趋势是小白赛季结束会来中超重庆队，即使这样巴萨也需要一个山寨的坎特和一个山寨的埃里克森，而罗贝托集这两个属性于一身，所以他就是一个“奉献的砖”，但是这样如果比达尔真的不留下来的话，巴萨还需要补进一个右后卫跟塞梅多良性竞争，这个右后卫的人选就比较挠头了。贝莱林？或许是一个选择，但是这个选择跟当年小法一样—要是双输就不好了。</p><p>前场如果能拿下格里兹曼肯定是好的，艾尔卡塞尔这种“躲着后卫”的踢法，虽然进球效率可以，但是没有真正起到轮换苏亚雷斯的作用。这样巴萨还需要在板凳上补充一个中锋（不用多能进球，哪怕搅屎棍也可以），同时也做好登贝莱/苏亚雷斯/梅西/格里兹曼（假设他真的来）的轮换。</p><p>总而言之，现在巴萨还是回归433比较好，配合442和4312的变化。那么休赛期最重要的补强就是格里兹曼+能抗中卫的前锋+一个中场+一个优秀的边后卫。</p><p>我个人希望的引援名单如下：<br>中场是魏格尔和B队的阿莱尼亚，埃里克森、博格巴和维拉蒂这三个不算是好的选择，要么太贵，要么节奏太慢。至于伊斯科、大卫席尔瓦、皮亚尼奇，那想都别想了，母队不会放人的。至于格雷茨卡，拜仁不是善茬；<br>边后卫可以考虑贝莱林，这个要看一下阿森纳的新教练是谁，摩纳哥的法比尼奥也可以，我知道他现在改中场了，也不耽误来一下跟罗贝托交叉换位…<br>前锋的话，我个人推荐B队阿奈斯试试看，其他的人选估计就是在西甲联赛内部找了；<br>这几个位置，最重要就是中场！梅西当初在哈白布的配合下威力无穷，一旦巴萨的中场重新掌握了控制力，不用频繁回撤的梅西依旧会进球如麻，这一点毋庸置疑。<br><img src="/images/fcb3.png" alt="paradin"></p><h2><span id="温格会来">温格会来？</span></h2><p>我个人首先不希望巴尔韦德下课，毕竟现在巴萨联赛冠军十拿九稳，国王杯如果也揽入怀中，这样一个成绩单也是一个80分，如果这个分数都炒掉主教练，那么继任者的压力势必很大，所以我个人倾向巴尔韦德留任，好好想一下，等阿图尔以及可能会来的格里兹曼到位了，巴萨应该怎么打。</p><p>不过如果温格真的来了，我个人也是赞成的，因为阿森纳的球风本来跟巴萨相似，相信温格跟梅西等人也会无缝接入，到时候教授或许真的可以在巴萨圆了欧冠梦想，不过这个想法成真的可能性低于5%，想想就得了。</p><h2><span id="下赛季的任务">下赛季的任务</span></h2><p>1.进攻体系依旧围绕梅西建队，让梅西继续火力全开的同时保证休息，欧冠要他有大用；<br>2.新球员（包括库蒂尼奥和登贝莱）适应巴萨的风格和体系，让皮克和布教授也能轮换得到休息；<br>3.欧冠一定要进入四强；<br>4.欧冠四强的基础上，西甲联赛冠军和国王杯能拿还是要拿，同时最好也能阻击皇马；<br><img src="/images/fcb2.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这几天的巴萨真是风雨飘摇，操碎我的心
    
    </summary>
    
      <category term="追乱花天" scheme="http://yoursite.com/categories/%E8%BF%BD%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="国际足坛" scheme="http://yoursite.com/tags/%E5%9B%BD%E9%99%85%E8%B6%B3%E5%9D%9B/"/>
    
      <category term="巴塞罗那" scheme="http://yoursite.com/tags/%E5%B7%B4%E5%A1%9E%E7%BD%97%E9%82%A3/"/>
    
  </entry>
  
  <entry>
    <title>国内Docker的加速方法</title>
    <link href="http://yoursite.com/2018/04/20/%E5%9B%BD%E5%86%85Docker%E7%9A%84%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/20/国内Docker的加速方法/</id>
    <published>2018-04-19T16:00:04.000Z</published>
    <updated>2018-04-19T16:17:09.102Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>由于大陆政府的特殊政策，国内想访问一些国外的资源是非常的曲折和痛苦，比较有代表性的就是亚马逊的云存储以及docker，尤其在<code>docker pull</code>一些镜像的时候，更是心惊胆战，祈求不要出现timout，然而现实往往很骨感。如下图：<br><img src="/images/jiasu.png" alt="paradin"></p><p>那么应该如何达到加速的效果呢？</p><p>在<code>CentOS 7</code>里，对于使用<code>systemd</code>的系统，请在<code>/etc/docker/daemon.json</code>中写入如下内容：（如果文件不存在请新建该文件）<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p><p>之后重新启动服务。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>注意：如果您之前查看旧教程，修改了<code>docker.service</code>文件内容，请去掉您添加的内容（–registry-mirror=<a href="https://registry.docker-cn.com）。" target="_blank" rel="noopener">https://registry.docker-cn.com）。</a></p><p>配置加速之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行<code>docker info |grep &#39;Registry Mirrors&#39; -A</code>，如果从结果中看到了如下内容，说明配置成功。<br><img src="/images/jiasu2.png" alt="paradin"></p><p>现在再重新尝试一下<code>docker pull training/webapp</code>，看看效果：<br><img src="/images/jiasu3.png" alt="paradin"></p><p>仅用17秒就pull了几乎400MB的镜像，高下立判！</p>]]></content>
    
    <summary type="html">
    
      墙内想干点事的确挺费劲
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>在Grafana里添加worldping插件</title>
    <link href="http://yoursite.com/2018/04/19/%E5%9C%A8Grafana%E9%87%8C%E6%B7%BB%E5%8A%A0worldping%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/04/19/在Grafana里添加worldping插件/</id>
    <published>2018-04-19T02:41:18.000Z</published>
    <updated>2018-04-19T03:53:34.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装插件">安装插件</span></h2><p>worldping是一个监控网站的dns、ping、http响应、https响应的插件，要安装它很简单，在granafa服务器里执行如下命令：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grafana-cli plugins install raintank-worldping-app</span><br><span class="line">systemctl restart grafana-server.service</span><br></pre></td></tr></table></figure></p><p>执行完毕之后在grafana的界面里选择<code>Plugins</code>，然后在<code>APP</code>里找到<code>worldping</code>，启动它，但是此时发现需要一个api，如图：<br><img src="/images/worldping.png" alt="paradin"></p><p>此时你需要登录grafana的官网，然后点击<code>api keys</code>和<code>ADD API KEY</code>，就可以生成一个<code>API KEY</code>，名字可以随便起，如下：<br><img src="/images/worldping2.png" alt="paradin"></p><p>将生成的api key保存好，并且填回到grafana的api key里，这样worldping插件就可以使用了，如图：<br><img src="/images/worldping3.png" alt="paradin"></p><h2><span id="监控网站节点">监控网站节点</span></h2><p>此时点击黄色旋涡，发现多了worldping的选项，点击<code>worldping Home</code>，如图：<br><img src="/images/worldping4.png" alt="paradin"></p><p>然后点击<code>+ New Endpoint</code>，这里我输入我公司的官网域名，然后<code>begin auto-discovery</code>，如图：<br><img src="/images/worldping5.png" alt="paradin"></p><p>生成了结果之后，点击add，此时开始检查几个大城市，如芝加哥、东京、纽约、巴黎等大城市连接到刚刚输入的域名的情况，如图：<br><img src="/images/worldping6.png" alt="paradin"></p><p>大约需要1~2分钟后，数据检查完成，可以点击<code>GO to Summary Dashboard</code>，就会看到图像了：<br><img src="/images/worldping7.png" alt="paradin"></p><p>为什么我这个图里没有http?因为在nginx里我们做了http强制rewrite跳转到https，所以是读不到值的。</p><h2><span id="删除网站节点">删除网站节点</span></h2><p>如果要删除网站节点，还是在worldping里点击要删除网站后面的齿轮图标，如图：<br><img src="/images/worldping8.png" alt="paradin"></p><p>然后选择<code>configuration</code>，这里可以修改网站域名，要删除的话，选择最下面的<code>destory</code>，输入DELETE确认，然后就可以点击<code>DELETE</code>删除了，如图：<br><img src="/images/worldping9.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这个搭配zabbix的网站监控，双重check!
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="grafana" scheme="http://yoursite.com/tags/grafana/"/>
    
      <category term="图像监控" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>用非root用户启动tomcat进程</title>
    <link href="http://yoursite.com/2018/04/18/%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%90%AF%E5%8A%A8tomcat/"/>
    <id>http://yoursite.com/2018/04/18/使用普通用户启动tomcat/</id>
    <published>2018-04-18T14:19:34.000Z</published>
    <updated>2018-04-19T14:05:04.577Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>使用非root用户启动进程是运维安全的一个主要环节，拿tomcat进程来说，如果是使用root用户去启动了tomcat，那么有一个严重的问题，那就是tomcat具有root权限。这意味着你的任何一个jsp脚本都具有root权限，所以那些不怀好意的人可以轻易地用jsp脚本去搞破坏，甚至删除你整个硬盘里的东西！所以为了活着，我们要极力避免这种现象。很多的软件都自带的用户/用户组，比如nginx、zabbix、elasticsearch，但是也有很多的软件没有这么贴心的服务，这就需要我们手动的更改了。</p><h2><span id="使用非root用户启动tomcat">使用非root用户启动tomcat</span></h2><p>以tomcat为例，打算用chris账号(属于chen这个group)启动。那么首先先创建账号和组，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]groupadd chen    #创建chen这个组</span><br><span class="line">[root@chen-docker ~]useradd -s /bin/bash -g chen chris    #在这个组里面添加chris这个用户</span><br><span class="line">[root@chen-docker ~]passwd chris    #给这个用户设定密码</span><br><span class="line">[root@chen-docker ~]# id chris</span><br><span class="line">uid=1000(chris) gid=1002(chen) groups=1002(chen)    #可见添加成功</span><br></pre></td></tr></table></figure></p><p><code>su chris</code>切换到chris用户，在<code>/home/chris</code>里使用<code>wget http://apache.fayea.com/tomcat/tomcat-9/v9.0.7/bin/apache-tomcat-9.0.7.tar.gz</code>下载tomcat。然后解压缩在/home/chris里，因为chris用户在这里是有权限的。然后进行如下的操作：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd  ~<span class="regexp">/ 代表用户所在目录</span></span><br><span class="line"><span class="regexp">mkdir -p ~/</span>shell-script</span><br><span class="line">cd ~<span class="regexp">/shell-script/</span></span><br><span class="line">touch start.sh</span><br><span class="line">toush stop.sh</span><br></pre></td></tr></table></figure></p><p>这个<code>start.sh</code>的内容很简单，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">if [ "root" == "$USER" ]    #不让root启动</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"can't start with user 'root',retry after change user!"</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd /home/chris/apache-tomcat<span class="number">-9.0</span><span class="number">.7</span>/bin/    &amp;&amp; ./start.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p><code>shutdown.sh</code>的内容同理：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">if [ "root" == "$USER" ]    #不让root启动</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"can't start with user 'root',retry after change user!"</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd /home/chris/apache-tomcat<span class="number">-9.0</span><span class="number">.7</span>/bin/    &amp;&amp; ./shutdown.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p><code>chmod +x *.sh</code>给上面两个脚本可执行权限，但是现在执行startup.sh或者shutdown.sh会出现一个问题：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</span><br><span class="line">At least one <span class="keyword">of</span> these environment variable is needed to run <span class="keyword">this</span> program</span><br></pre></td></tr></table></figure></p><p>这是因为chris用户没有权限去启动java这个可执行程序，如果使用<code>java -version</code>回答是<code>bash: java: command not found</code>，这个时候怎么办？</p><p>编辑<code>~/.bash_profile</code>，在末尾处加上如下的内容：<br><img src="/images/noroot2.png" alt="paradin"></p><p>然后<code>source .bash_profile</code>，再使用<code>java -version</code>确认一下应该是OK了。这个时候也是可以使用chris用户去启动刚刚的那个start.sh和shutdown.sh的。<br><img src="/images/noroot3.png" alt="paradin"></p><p>由于我们的tomcat是源码解压缩，所以要使用root用户去创建一下<code>/etc/init.d/tomcat</code>。里面内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">case</span> $<span class="number">1</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">su - chris -lc "sh /home/chris/shell-script/start.sh";;     #如果要root启动，那就是su - root -lc "sh /home/utomcat/shell-script/start.sh";;</span><br><span class="line">stop)</span><br><span class="line">su - chris -lc <span class="string">"sh /home/chris/shell-script/shutdown.sh"</span>;;</span><br><span class="line">*)</span><br><span class="line">echo <span class="string">"parameter error, usage:(start|stop)"</span>;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>保存之后，执行一下<code>service tomcat start</code>看看效果。<br><img src="/images/noroot4.png" alt="paradin"></p><p>如果要设置开机自启动，别忘了<code>chkconfig --add tomcat</code>和<code>chkconfig tomcat on</code>，在浏览器打开<code>ip:8080</code>看见汤姆猫~<br><img src="/images/noroot5.png" alt="paradin"></p><h2><span id="当普通用户要使用1024以下的端口">当普通用户要使用1024以下的端口</span></h2><p>众所周知，linux默认是不准许普通用户调用1024以下的端口的，那么遇到这样的需求怎么办呢？最好的方法是使用iptables。</p><p>首先让程序运行在非root帐户下，并绑定高于1024的端口，在确保能正常工作的时候，将低端口通过端口转发，将低端口转到高端口，从而实现非root运行的程序绑定低端口。要使用此方法可以使用下面的方式：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward=1        #要长久保存，需要在/etc/sysctl.conf文件内修改，然后sysctl -p /etc/sysctl.conf</span><br><span class="line">iptables -F -t nat</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to:8088    #将80端口转发到8088</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080    #这句话也可以</span><br></pre></td></tr></table></figure></p><p>这么操作在速度上没有任何影响。</p>]]></content>
    
    <summary type="html">
    
      chmod u+s 就是给某个程序的所有者以suid权限，可以像root用户一样操作
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
      <category term="运维安全" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>用非root启动进程以及启动docker</title>
    <link href="http://yoursite.com/2018/04/18/%E7%94%A8%E9%9D%9Eroot%E5%90%AF%E5%8A%A8%E8%BF%9B%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%90%AF%E5%8A%A8docker/"/>
    <id>http://yoursite.com/2018/04/18/用非root启动进程以及启动docker/</id>
    <published>2018-04-18T14:19:34.000Z</published>
    <updated>2018-05-15T06:28:45.869Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="使用非root用户启动普通进程">使用非root用户启动普通进程</span></h2><p>使用非root用户启动进程是运维安全的一个主要环节，拿tomcat进程来说，如果是使用root用户去启动了tomcat，那么有一个严重的问题，那就是tomcat具有root权限。这意味着你的任何一个jsp脚本都具有root权限，所以那些不怀好意的人可以轻易地用jsp脚本去搞破坏，甚至删除你整个硬盘里的东西！所以为了活着，我们要极力避免这种现象。</p><p>很多的软件都自带的用户/用户组，比如nginx、zabbix、elasticsearch，但是也有更多的软件没有这么贴心的服务，这就需要我们手动的更改了。</p><h2><span id="docker不应该使用root启动">docker不应该使用root启动</span></h2><p>1.8版本之前的docker是不支持<code>user namespace</code>的，所以那样的话，如果在docker容器内部使用root运行app，那么不可否认，这个root和宿主机的root是同一个UID。但是，需要特别注意的是，容器内的root与宿主机上的root权限并不一定是相等的。</p><p>但是为了绝对的安全，还是推荐把docker升级到1.8以上，然后彻底避免用root去启动容器，在<a href="http://www.projectatomic.io/docs/docker-image-author-guidance/里最下面一段也明文说了---" target="_blank" rel="noopener">http://www.projectatomic.io/docs/docker-image-author-guidance/里最下面一段也明文说了---</a><font color="red">生产环境里不要用root用户去启动docker!!!</font><br><img src="/images/noroot.png" alt="paradin"></p><p>使用非root用户启动docker的办法如下：<br>创建docker组：<code>sudo groupadd docker</code><br>将当前用户加入docker组：<code>sudo gpasswd -a ${USER} docker</code><br>重新启动docker服务：<code>sudo service docker restart</code>或<code>sudo systemctl restart docker</code><br>当前用户退出系统再重新登陆。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.zhihu.com/question/25580965" target="_blank" rel="noopener">https://www.zhihu.com/question/25580965</a></p>]]></content>
    
    <summary type="html">
    
      root尽可能的不要出现在服务器里
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用docker做一个主从同步的redis集群</title>
    <link href="http://yoursite.com/2018/04/18/%E4%BD%BF%E7%94%A8docker%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84redis%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2018/04/18/使用docker做一个主从同步的redis集群/</id>
    <published>2018-04-17T16:14:44.000Z</published>
    <updated>2018-04-19T03:51:26.430Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="查看容器内部信息">查看容器内部信息</span></h2><p>之前用<code>docker run -it --name redis-master redis /bin/bash</code>创建了一个redis的docker，现在登陆发现状态已经是exit，于是就使用<code>docker container start 容器ID号or容器名称</code>来重新启动。如图：<br><img src="/images/docker4.png" alt="paradin"></p><p>然后书里说到要用<code>docker inspect</code>来查看所挂载volume的情况，使用命令:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .Volumes &#125;&#125;&quot; f391531120b0</span><br></pre></td></tr></table></figure></p><p>但是很不幸，系统反馈给我一个错误：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Template parsing error: template: :1:3: executing &quot;&quot; at &lt;.Volumes&gt;: map has no entry for key &quot;Volumes&quot;</span><br></pre></td></tr></table></figure></p><p>没有这个<code>Volumes</code>，那就干脆查看一下这个容器的所有信息：<code>docker inspect f391531120b0</code>，这个命令里面有<code>Config、Mounts</code>、<code>HostConfig</code>、<code>NetworkSettings</code>等等整个容器的所有信息，比如看一下NetworkSettings相关的内容，如图：<br><img src="/images/docker6.png" alt="paradin"></p><p>此时使用如下命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&quot; f391531120b0    #注意前面的.</span><br><span class="line">192.168.0.2</span><br><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .NetworkSettings.MacAddress &#125;&#125;&quot; f391531120b0</span><br><span class="line">02:42:c0:a8:00:02</span><br></pre></td></tr></table></figure></p><p>这样就可以获取到内网IP和mac地址，同理换成<code>docker inspect f391531120b0 | grep Mounts -A 10</code>，看一下挂载信息，如图：<br><img src="/images/docker5.png" alt="paradin"></p><p>原来容器里的/data其实就是宿主机的<code>/var/lib/docker/volumes/94b3c20a6d269c7498ab59ee45c560e84fed64a636767a4baa54fa7befbcd4ff/_data</code>这个文件夹。为了验证这一点，我先到宿主机去创建一个叫aaa文件，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@f391531120b0:/data# cat aaa </span><br><span class="line">123123</span><br></pre></td></tr></table></figure></p><p>再返回到宿主机上看：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# cd /var/lib/docker/volumes/94b3c20a6d269c7498ab59ee45c560e84fed64a636767a4baa54fa7befbcd4ff/_data</span><br><span class="line">[root@chen-docker _data]# ls</span><br><span class="line">aaa</span><br><span class="line">[root@chen-docker _data]# cat aaa </span><br><span class="line">123123</span><br></pre></td></tr></table></figure></p><p>这就搞定了！</p><h2><span id="主从同步排错">主从同步排错</span></h2><p>就是按书里写的开始配置和启动<code>redis-slave</code>，但是却发现同步没有成功，在<code>redis-slave</code>日志里发现这样的话：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32677:S 08 Feb 16:14:40.952 * Connecting to MASTER 172.168.10.70:6379</span><br><span class="line">32677:S 08 Feb 16:14:40.952 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">32677:S 08 Feb 16:14:40.953 # Error condition on socket for SYNC: Connection refused</span><br></pre></td></tr></table></figure></p><p>这个的原因就是redis主服务器绑定了127.0.0.1，那么跨服务器IP的访问就会失败，从服务器用IP和端口访问主的时候，主服务器发现本机6379端口绑在了127.0.0.1上，也就是只能本机才能访问，外部请求会被过滤。所以需要修改<code>redis-master</code>的<code>redis.conf</code>，注释掉<code>bind 127.0.0.1</code>，如果是线上生产环境建议绑定IP地址。</p><p>重新启动redis之后，发现同步依然失败，日志变成了这样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">90:S 17 Apr 09:27:35.906 * Non blocking connect for SYNC fired the event.</span><br><span class="line">90:S 17 Apr 09:27:35.907 # Error reply to PING from master: &apos;-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect&apos;</span><br><span class="line">90:S 17 Apr 09:27:36.908 * Connecting to MASTER 192.168.0.2:6379</span><br><span class="line">90:S 17 Apr 09:27:36.909 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">90:S 17 Apr 09:27:36.909 * Non blocking connect for SYNC fired the event.</span><br><span class="line">90:S 17 Apr 09:27:36.909 # Error condition on socket for SYNC: Connection reset by peer</span><br></pre></td></tr></table></figure></p><p>这个日志的意思是说redis在没有开启bind和密码的情况下，保护模式被开启。然后Redis的只接受来自环回IPv4和IPv6地址的连接。于是还是要修改redis-master的<code>redis.conf</code>关闭保护模式：<code>portected-mode no</code>，然后重启redis-master即可。</p><h2><span id="容器内安装ping">容器内安装ping</span></h2><p>先检查你的容器是使用什么系统的景象，如果是ubantu那就是<code>apt-get</code>，安装ping的命令如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install inetutils-ping</span><br></pre></td></tr></table></figure></p><h2><span id="如何让容器一直启动">如何让容器一直启动</span></h2><p>如果用了一段时间的docker就会发现，我们的容器经常用了一段时间就自动退出了，<code>docker ps</code>已经找不到了，在<code>docker ps -a</code>里面了，如图：<br><img src="/images/docker7.png" alt="paradin"></p><p>然后我们<code>docker start containerId</code>想重新开启这个容器，可能这次来的更快，没几分钟容器又自己关了，由这个问题又可能引发其它很多的问题。</p><p><code>docker run</code>指定的命令如果不是那些一直挂起的命令（比如运行top，不断echo），就是会自动退出的。<code>-d</code>命令是设置detach为<code>true</code>，根据官方的文档，意思是让这个命令在后台运行，但并不是一直运行，Docker容器后台运行,就必须有一个前台进程。主线程结束，容器会退出。</p><p>我们启动容器的时候不要<code>-d</code>命令启动，用<code>-dit</code>就好了，例如：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d hello-world(不要这么做)</span><br><span class="line">docker run -dit hello-world(推荐)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      从《容器与容器云》 的第19页开始...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="主从同步" scheme="http://yoursite.com/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix监控memcache</title>
    <link href="http://yoursite.com/2018/04/03/%E4%BD%BF%E7%94%A8zabbix%E7%9B%91%E6%8E%A7memcache/"/>
    <id>http://yoursite.com/2018/04/03/使用zabbix监控memcache/</id>
    <published>2018-04-03T11:00:58.000Z</published>
    <updated>2018-04-03T11:05:46.074Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>监控memcache的原理跟监控redis差不多，都是通过一个类似info的东西可以查询到memcache的状态值，然后通过脚本去获取这些值给zabbix，当发现某值不正常就发出告警。</p><p>查询当年memcache状态的命令是<code>echo stats |nc 127.0.0.1  11211</code>，如果没有<code>nc</code>命令，那就<code>yum install -y nc</code>。</p><p>获得到的结果是这个样子的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@lconline-ec2 ~]# echo stats |nc 127.0.0.1  11211</span><br><span class="line">STAT pid <span class="number">1859</span>        memcache服务进程ID</span><br><span class="line">STAT uptime <span class="number">491093</span>    服务器已运行秒数</span><br><span class="line">STAT time <span class="number">1522740969</span>    服务器当前Unix时间戳</span><br><span class="line">STAT version <span class="number">1.4</span><span class="number">.25</span>        memcache版本</span><br><span class="line">STAT libevent <span class="number">1.4</span><span class="number">.13</span>-stable</span><br><span class="line">STAT pointer_size <span class="number">64</span>        操作系统指针大小</span><br><span class="line">STAT rusage_user <span class="number">14.321822</span>        进程累计用户时间</span><br><span class="line">STAT rusage_system <span class="number">14.095857</span>        进程累计系统时间</span><br><span class="line">STAT curr_connections <span class="number">5</span>        当前连接数量</span><br><span class="line">STAT total_connections <span class="number">51010</span>    Memcached运行以来连接总数</span><br><span class="line">STAT connection_structures <span class="number">8</span>    Memcached分配的连接结构数量</span><br><span class="line">STAT reserved_fds <span class="number">20</span></span><br><span class="line">STAT cmd_get <span class="number">0</span>        get命令请求次数</span><br><span class="line">STAT cmd_set <span class="number">0</span>        set命令请求次数</span><br><span class="line">STAT cmd_flush <span class="number">0</span>    flush命令请求次数</span><br><span class="line">STAT cmd_touch <span class="number">0</span>    touch命令请求次数</span><br><span class="line">STAT get_hits <span class="number">0</span>        get命令命中次数</span><br><span class="line">STAT get_misses <span class="number">0</span>    get命令未命中次数</span><br><span class="line">STAT delete_misses <span class="number">0</span>    <span class="keyword">delete</span>命令未命中次数</span><br><span class="line">STAT delete_hits <span class="number">0</span>        <span class="keyword">delete</span>命令命中次数</span><br><span class="line">STAT incr_misses <span class="number">0</span>        incr命令未命中次数</span><br><span class="line">STAT incr_hits <span class="number">0</span>        incr命令命中次数</span><br><span class="line">STAT decr_misses <span class="number">0</span>        decr命令未命中次数</span><br><span class="line">STAT decr_hits <span class="number">0</span>        decr命令命中次数</span><br><span class="line">STAT cas_misses <span class="number">0</span>        cas命令未命中次数</span><br><span class="line">STAT cas_hits <span class="number">0</span>            cas命令命中次数</span><br><span class="line">STAT cas_badval <span class="number">0</span>        使用擦拭次数</span><br><span class="line">STAT touch_hits <span class="number">0</span></span><br><span class="line">STAT touch_misses <span class="number">0</span></span><br><span class="line">STAT auth_cmds <span class="number">0</span>        认证命令处理的次数    </span><br><span class="line">STAT auth_errors <span class="number">0</span>        认证失败数目</span><br><span class="line">STAT bytes_read <span class="number">357040</span>        读取总字节数    </span><br><span class="line">STAT bytes_written <span class="number">60197691</span>        发送总字节数</span><br><span class="line">STAT limit_maxbytes <span class="number">1073741824</span>        分配的内存总大小（字节）</span><br><span class="line">STAT accepting_conns <span class="number">1</span>        服务器是否达到过最大连接（<span class="number">0</span>/<span class="number">1</span>）</span><br><span class="line">STAT listen_disabled_num <span class="number">0</span>        失效的监听数</span><br><span class="line">STAT time_in_listen_disabled_us <span class="number">0</span></span><br><span class="line">STAT threads <span class="number">4</span>        当前线程数</span><br><span class="line">STAT conn_yields <span class="number">0</span>        连接操作主动放弃数目</span><br><span class="line">STAT hash_power_level <span class="number">16</span></span><br><span class="line">STAT hash_bytes <span class="number">524288</span>        当前存储占用的字节数</span><br><span class="line">STAT hash_is_expanding <span class="number">0</span></span><br><span class="line">STAT malloc_fails <span class="number">0</span>    </span><br><span class="line">STAT bytes <span class="number">0</span>        当前存储占用的字节数</span><br><span class="line">STAT curr_items <span class="number">0</span>        当前存储的数据总数</span><br><span class="line">STAT total_items <span class="number">0</span>        启动以来存储的数据总数</span><br><span class="line">STAT expired_unfetched <span class="number">0</span>    </span><br><span class="line">STAT evicted_unfetched <span class="number">0</span></span><br><span class="line">STAT evictions <span class="number">0</span>        LRU释放的对象数目</span><br><span class="line">STAT reclaimed <span class="number">0</span>        已过期的数据条目来存储新数据的数目</span><br><span class="line">STAT crawler_reclaimed <span class="number">0</span></span><br><span class="line">STAT crawler_items_checked <span class="number">0</span></span><br><span class="line">STAT lrutail_reflocked <span class="number">0</span>    </span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>修改<code>zabbix_agentd.conf</code>，添加一个新的自定义项：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=memcached.stat[*],(echo stats; sleep <span class="number">1</span>) | telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">11211</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | awk <span class="string">'/STAT $1 / &#123;print $NF&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后重启<code>zabbix-agent</code>，模板就用github里的就好，看到的效果如下：<br><img src="/images/check-memcached.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      上帝抛弃了吃不饱饭的人民
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="memcached" scheme="http://yoursite.com/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控网站和tcp连接</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控网站/</id>
    <published>2018-04-02T01:42:45.000Z</published>
    <updated>2018-04-03T11:58:22.848Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="网页状态码监控">网页状态码监控</span></h2><p>在zabbix的web界面，<code>配置</code>–<code>主机</code>–选择一个有外网权限的服务器，比如选择zabbix server–<code>Web检测</code>，如图：<br><img src="/images/checkweb1.png" alt="paradin"></p><p>然后点击右上角的<code>创建Web场景</code>，然后依次填入<code>名称</code>，<code>间隔</code>，<code>客户端</code>等等，如图：<br><img src="/images/checkweb2.png" alt="paradin"></p><p>然后编辑<code>步骤</code>，先<code>添加</code>，填入对应的url，然后写上200状态码，意思就是返回200是OK的。<br><img src="/images/checkweb4.png" alt="paradin"><br>保存即可，如果还有http认证，那么就继续填写认证。</p><p>至此，一个简单的监控官网状态码的配置过程就结束了，剩下就是增添一下触发器，如下：<br><img src="/images/checkweb3.png" alt="paradin"></p><h2><span id="tcp连接监控">tcp连接监控</span></h2><p>首先在<code>zabbix-agentd.conf</code>里添加一个新的自定义监控项：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=tcp.status[*],netstat -a | awk <span class="string">'/^tcp/ &#123;++y[$NF]&#125; END &#123;for(i in y) print i,y[i]&#125;'</span> |  grep $<span class="number">1</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后<code>service zabbix-agent restart</code>重启客户端，模板就是<a href="https://gitee.com/careyjike_173/zabbix/tree/master/template" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix/tree/master/template</a> 里的<code>zbx_tcp_status_templates.xml</code>，直接导入即可。如图：<br><img src="/images/checkweb5.png" alt="paradin"></p><p>然后自己配置一下<code>time_wait</code>/<code>close_wait</code>的告警阈值。</p><p><img src="/images/裤子卡世界波.gif" alt="akb48" title="裤子卡中圈世界波"></p>]]></content>
    
    <summary type="html">
    
      我可算是那个zabbix监控模板扒个精光...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="web监控" scheme="http://yoursite.com/tags/web%E7%9B%91%E6%8E%A7/"/>
    
      <category term="tcp连接" scheme="http://yoursite.com/tags/tcp%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
</feed>

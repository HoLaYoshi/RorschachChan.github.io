<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-05T02:36:03.032Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zookeeper集群的搭建与配置</title>
    <link href="http://yoursite.com/2018/02/05/Zookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/02/05/Zookeeper集群的搭建与配置/</id>
    <published>2018-02-05T02:15:21.000Z</published>
    <updated>2018-02-05T02:36:03.032Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Zookeeper的下载地址：<code>https://github.com/apache/zookeeper/archive/master.zip</code><br>zkclient的下载地址：<code>https://github.com/sgroschupf/zkclient</code></p><p>至于zookeeper的作用和原理我这里就不多赘述了，大家有兴趣可以去查查，这里主要就是动手操作。</p><h2><span id="搭建集群">搭建集群</span></h2><p>首先先看一下本次zk实验服务器的名称和IP情况，这里我们选择了三台服务器作zkserver，因为三台是标配，一台的话就只有leader没有follower，不是很稳定的结构，当然啦如果你的公司土豪的话是可以玩三十台：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dvl-mrszk<span class="number">-001</span><span class="number">10.117</span><span class="number">.0</span><span class="number">.125</span></span><br><span class="line">dvl-mrszk<span class="number">-002</span><span class="number">10.117</span><span class="number">.1</span><span class="number">.158</span></span><br><span class="line">dvl-mrszk<span class="number">-003</span><span class="number">10.168</span><span class="number">.152</span><span class="number">.227</span></span><br></pre></td></tr></table></figure></p><p>对这三台服务器都要进行如下的步骤:</p><p>1)先把zookeeper.zip传到linux里，然后解压到<code>/usr</code>文件夹下；</p><p>2）进入<code>/usr/zookeeper/conf</code>文件夹，<code>vim zoo.cfg</code>，在最下面补充上面的三个zkserver，见图：<br><img src="/images/zook1.png" alt="paradin"></p><p>3）再来到<code>/usr/zookeeper/data</code>文件夹，如果里面有文件就清空所有文件，如果是1号zkserver就<code>echo 1 &gt; myid</code>，如果当前机器是2号zkserver就<code>echo 2 &gt; myid</code>，依次类推，这里一定要注意，不可以都写一样。</p><p>4）<code>vim /etc/host</code>s，还要把这三台机器的ip地址和名字都写进去，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line">::<span class="number">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"><span class="number">10.117</span><span class="number">.0</span><span class="number">.125</span> dvl-mrszk<span class="number">-001</span></span><br><span class="line"><span class="number">10.117</span><span class="number">.1</span><span class="number">.158</span> dvl-mrszk<span class="number">-002</span></span><br><span class="line"><span class="number">10.168</span><span class="number">.152</span><span class="number">.227</span> dvl-mrszk<span class="number">-003</span></span><br></pre></td></tr></table></figure></p><p>5）再来<code>/usr/zookeeper/bin</code>文件夹，<code>./zkServer.sh start</code>启动zk，然后再<code>./zkServer.sh status</code>查看进程情况，如图看见第一台和第三台zkserver的身份是<code>follower</code>，第二台是<code>leader</code>：<br><img src="/images/zook2.png" alt="paradin"></p><p><img src="/images/zook3.png" alt="paradin"></p><p><img src="/images/zook4.png" alt="paradin"></p><p>至此整个zk集群就搭建并且启动完成了。</p><font color="red">注意：zookeeper集群时，zookeeper要求半数以上的机器可用，zookeeper才能提供服务。</font><p>如果这里有启动失败的情况，比如<code>Error contacting service. It is probably not running.</code>这样的字样，那么有这么几种可能：</p><p>1）data文件夹下的<code>myid</code>有数字重复或者是数字漏写的情况；</p><p>2）<code>zoo.cfg</code>里的指定日志文件夹没有手动创建；</p><p>3）<code>/etc/hosts</code>下的名字与zoo.cfg里的server字段不相符，注意一下，/etc/hosts里的127.0.0.1的名字不要与本ip后面的名字一模一样，不然zk也无法识别！</p><p>4）<code>/etc/hosts</code>名字使用了中文，java系对中文是很不友好的。</p><h2><span id="配置文件详解">配置文件详解</span></h2><p>1.tickTime：这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。<br>2.dataDir：顾名思义就是Zookeeper保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。<br>3.clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。<br>4.initLimit：这个配置项是用来配置 Zookeeper 接受 客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5<em>2000=10 秒。<br>5.syncLimit：这个配置项标识 Leader 与Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是2</em>2000=4 秒。<br>6.server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p><h2><span id="验证成果">验证成果</span></h2><p>Zookeeper的配置工具叫<code>Zooinspector</code>，下载地址是：<code>https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</code>，下载完直接解压缩就可以在windows里使用。</p><p>我们实验的这三台服务器只有内网，但是如果要连接zooinspector，还是需要通过外网权限连接的，这里可以配一个iptables转发规则，配iptables的步骤在这里：<a href="http://chenx1242.blog.51cto.com/10430133/1875950，照葫芦画瓢即可，但是要注意，zk的端口是`2181`。" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1875950，照葫芦画瓢即可，但是要注意，zk的端口是`2181`。</a></p><p>当然，如果不想费事的话，就直接给zkserver 配一个外网IP，直接连接。</p><p>成功连接到<code>zooinspector</code>，就会看到这样的内容，这里的lcconfig是手动添加的，右击鼠标，选择<code>add node</code>，然后直接写上<code>lcconfig</code>就行，这个名字是根据实际需要填写的：</p><p><img src="/images/zook5.png" alt="paradin"></p><p>上面我们已经配置了zkserver集群而且还启动zkserver进程，现在还需要zkclient，zkclient就是请求发起的一方，然后我们可以在各个的模块服务器上部署zkclient服务，通过启动zkclient服务，来让这些模块统一从zooinspector里取值，这样就达到了批量配置，同时保证一致性的效果。</p><p>zk的模板文件是<code>_tpl.properties</code>为结尾的文件，我这里模块的名字叫mrs，那么在实验里这个模板文件就是<code>mrs_tpl.properties</code>，这个<code>mrs_tpl.properties</code>里有这样的一个字段，如图：</p><p><img src="/images/zook6.png" alt="paradin"></p><p>而我们在zooinspector里对应就这么填写：</p><p><img src="/images/zook7.png" alt="paradin"></p><p>保存zooinspector，然后从windows返回到linux，启动zkclient服务和对应的模块进程，如果配置都正常的话，那么程序就会正常启动，<code>ps -ef|grep java</code>就会看到一个叫<code>lczk.AppServerDaemon</code>的进程。这个时候在去看一下mrs的配置文件：</p><p><img src="/images/zook8.png" alt="paradin"></p><p>可以看到areaAk取得值就是zk里面<code>data_center</code>里面<code>access_key</code>里面的ak的值，其他的几个值也是同理。可见整个zk已经配置成功，模块都进行了统一配置，而且这些配置既然能被一个接受，同时也会被其他相同的模块服务器所接受。这样就达到了批量配置的效果。</p><h2><span id="拓展阅读">拓展阅读</span></h2><p><a href="http://ibruce.info/2014/10/23/zookeeper/" target="_blank" rel="noopener">http://ibruce.info/2014/10/23/zookeeper/</a></p>]]></content>
    
    <summary type="html">
    
      纵然你的身子骨是铁打的，我想你也需要了解一款“实现同步服务，配置维护和命名服务”的东西吧。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Uwsgi的安装和简单使用</title>
    <link href="http://yoursite.com/2018/02/02/Uwsgi%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/02/Uwsgi的安装和简单使用/</id>
    <published>2018-02-02T10:41:29.000Z</published>
    <updated>2018-02-02T10:50:19.673Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>运维平台的搭建已经提上日程，而我选用了大家比较常用的<code>Uwsgi+nginx+django</code>的架构，这里先记录一下安装Uwsgi的过程。</p><p>这里解释一下<code>Uwsgi+nginx+django</code>，我们整个流程如下图：<br><img src="/images/uwsgi1.png" alt="paradin"></p><p>这里我们可以看出，web server是无法与我们的app（django等等）进行直接对话，他需要通过uwsgi这个桥梁，这个桥梁很重要，虽然我们使用django的<code>runserver</code>功能也会打开一个页面，但是这个页面是很脆弱的，小规模使用还好，要是放在网络上供很多人点击的话，根本就是脆不经风。</p><p>uwsgi是啥，请查看文末的参考资料，写的已经非常好了。我这里就简单说下：</p><blockquote><p>uwsgi 实际上也是一个http服务器，只不过它只面向python网络应用程序。虽然uwsgi也是http服务器，但是却不能直接使用它部署python web应用程序，否则会出错。</p><p>在本文中，uwsgi所扮演的的角色是后端http服务器，nginx扮演的角色是前端http服务器，<code>hello.py</code>是客户端应用程序。用户从网页浏览器中发出请求，nginx服务器收到请求后，会通过它的uwsgi模块将用户的请求转发给uwsgi服务器，uwsgi服务器处理完毕后将结果返回给 nginx，浏览器将最终的结果展现给用户。</p></blockquote><p>Uwsgi的安装比较简单，推荐使用<code>yum install Uwsgi</code>直接下载使用，而不推荐用<code>pip install uwsgi</code>，因为pip安装的话，虽然也能成功（如下图红框），是没有<code>uwsgi.ini</code>文件的，其实没有这个<code>uwsgi.ini</code>是无足轻重的，因为这个文件可以自己写，但是对于生手来说，没有这个文件可能会心里发毛，就无法按照攻略继续下去，所以我更推荐用yum安装，如图：<br><img src="/images/uwsgi2.png" alt="paradin"></p><p>为了纪念我们的金刚狼同志，我们就写一个叫<code>logan.py</code>，里面的内容是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def application(env, start_response):</span><br><span class="line">       start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"good bye,Logan..."</span></span><br></pre></td></tr></table></figure></p><p>然后我们就可以启动这个<code>uwsgi</code>看看效果，使用<code>uwsgi --http :8001 --wsgi-file logan.py</code>，把端口设定为<code>8001</code>，同时指定协议是<code>http</code>，然后加载的文件就是<code>logan.py</code>，启动之后，如图：<br><img src="/images/uwsgi3.png" alt="paradin"></p><p>遇到这种情况，你就<code>yum install uwsgi-plugin-python</code>，然后把命令做一点点修改，改成：<code>uwsgi --plugin python --http-socket :8001 --wsgi-file logan.py</code>。</p><p>屏幕会出现一大堆文字，然后提示，uwsgi已经启动成功了。在浏览器输入<code>服务器外网地址:8001</code>看一下效果，如图：<br><img src="/images/uwsgi4.png" alt="paradin"></p><p>我们在root目录下再写一个测试的文件，这次我们写一个比较老实的python脚本来测试，这个脚本就叫<code>test.py</code>，里面的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">def application(environ, start_response):</span><br><span class="line">       status = <span class="string">'200'</span></span><br><span class="line">       output = <span class="string">'this is a test for uwsgi,HOHO~'</span></span><br><span class="line">       response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>),(<span class="string">'Content-Length'</span>, str(len(output)))]</span><br><span class="line">       start_response(status, response_headers)</span><br><span class="line">       <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></p><p>还是用刚才的方法，依旧可以打开网页，其实上面这个简单的<code>uWSGI</code>程序更好理解整个套路，只需要实现一个名为<code>application</code>的函数就可以了，该函数有两个参数，<code>environ</code>为包含有<code>http</code>请求的环境变量，<code>start_response</code>为一个函数，用来设置http头。在这个函数里，我们只需要调用一次<code>start_response</code>函数，设置一下<code>HTTP</code>返回头，再<code>return</code>一个<code>HTTP body</code>即可。</p><p>至此，整个uwsgi就安装成功了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://xiaorui.cc/2017/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3uwsgi%E5%92%8Cgunicorn%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8A/" target="_blank" rel="noopener">http://xiaorui.cc/2017/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3uwsgi%E5%92%8Cgunicorn%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8A/</a><br><a href="http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html" target="_blank" rel="noopener">http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html</a></p>]]></content>
    
    <summary type="html">
    
      Uwsgi+nginx+django，光搭建一个框架就要了我的老命...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="uwsgi" scheme="http://yoursite.com/tags/uwsgi/"/>
    
  </entry>
  
  <entry>
    <title>从excel的大单元格里快速提取内容</title>
    <link href="http://yoursite.com/2018/02/01/%E4%BB%8Eexcel%E7%9A%84%E5%A4%A7%E5%8D%95%E5%85%83%E6%A0%BC%E9%87%8C%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2018/02/01/从excel的大单元格里快速提取内容/</id>
    <published>2018-02-01T02:42:54.000Z</published>
    <updated>2018-02-01T02:47:24.133Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我公司的服务器信息会保存在一份高加密的excel里，由于历史遗留问题，里面的格式节选一部分出来是这样的：<br><img src="/images/excel1.png" alt="抱光妹"></p><p>注意看，ip地址不分内网外网是放在一个大的单元格里，中间是用空格隔开的，造成了这样的视觉效果。</p><p>现在公司需要把所有的服务器重新更换到新的zookeeper，那么使用ansible在批量处理的时候，就需要提取这些服务器的内网ip地址录入到hosts文件里，但是由于服务器实在太多不可能一个一个手动从excel的单元格挑选出“内网IP地址”复制粘贴，那么就需要进行一下批量挑选内网IP地址的操作。</p><p>首先我们先把整个IP的单元列里的”（公）””（内）”的字样去掉，然后把整列全部拷贝，粘贴到notepad里，看到它们变成了这样的样子：<br><img src="/images/excel2.png" alt="抱光妹"></p><p>在notepad里，双引号之间的内容会被认为同一行，所以这里我们需要使用“替换”功能把所有的双引号去掉，让它变成下面这样：<br><img src="/images/excel3.png" alt="抱光妹"></p><p>这样就可以把上面的内容复制到一个新的excel去，发现每一个内容对应了一行，即一个小单元格：<br><img src="/images/excel4.png" alt="抱光妹"></p><p>然后我们把第一行染成黄色，第二行染成绿色，当然颜色你可以选择自己的口味，然后使用excel的“格式刷”功能，一拉到底，让他们变成条纹状：<br><img src="/images/excel5.png" alt="抱光妹"></p><p>然后在excel里找到“筛选”功能，先选择住这一条纹块，然后选择“按颜色筛选“，由于我们需要内网IP，那么我们就留下绿色内容即可，如图：<br><img src="/images/excel6.png" alt="抱光妹"></p><p>得到效果如下：<br><img src="/images/excel7.png" alt="抱光妹"></p><p>这样就可以把整个内容拷贝进ansible的hosts文件里，然后搭配ansible批处理这些内网IP，双管齐下，大大的提升了提取数据的效率。</p><p>如果遇到偶尔三行（即中间有空格行）的情况，那么就在notepad那一步的时候，把空格行干掉，不如下图的情况里，第五行和第八行是空格行，可能是当初记录人员复制的时候自带了空格：<br><img src="/images/excel8.png" alt="抱光妹"></p><p>如果空格很多的情况，那么就需要批处理一次性的把所有空格都干掉，干掉的方法，还是使用notepad的“替换功能”，选择“正则表达式”，然后把“\n[\s|]*\r”替换成空值就可以了。<br><img src="/images/excel9.png" alt="抱光妹"></p>]]></content>
    
    <summary type="html">
    
      没想到我的这个博客里还需要写office的操作小技巧，真是太惊喜太意外了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
      <category term="excel" scheme="http://yoursite.com/tags/excel/"/>
    
  </entry>
  
  <entry>
    <title>再见，魔兽世界</title>
    <link href="http://yoursite.com/2018/02/01/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2018/02/01/再见，魔兽世界/</id>
    <published>2018-02-01T01:56:20.000Z</published>
    <updated>2018-02-02T10:35:31.158Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"></div><script>var ap = new APlayer({element: document.getElementById("aplayer0"),narrow: false,autoplay: false,showlrc: 0,music: {title: "暴风城主题音乐",author: "World of Warcaft",url: "http://p1x3hd2at.bkt.clouddn.com/stormwind.mp3",pic: "http://p1x3hd2at.bkt.clouddn.com/wow.jpg",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><p>这张月卡马上就要用完了，我想我的《魔兽世界》生涯也要到头了。</p><h2><span id="地球时代">地球时代</span></h2><p>我是从大学的时候就开始接触《魔兽世界》，当时是在同寝的xur同学的推荐下，注册账号买了CDKey，然后跟着他在六区黑翼之巢创建了角色，那是一个留着武士头和山羊胡的暗夜精灵德鲁伊，起了个带有劲舞团性质的ID叫“删除过去”。记得德鲁伊刚出生是人形态，泰达希尔里背着一个木棒棒，靠着“愤怒”这个技能打人。于是乎，我就搓出了一个又一个原谅色的冲击波，波遍了泰达希尔的每一个角落，波倒了一个又一个萨特和野熊。当时我作为一个萌新，什么都不懂，后来在一个另外的德鲁伊的帮助下，开始做任务升级，顺便粗略的了解了魔兽最基本的操作。这个德鲁伊是我在游戏里认识的第一个朋友，是一个萌妹子，ID叫什么我忘了，不过后来她游戏上的很少了，依稀记得后来某一个半夜我在西瘟疫之地变成小豹子一个一个挠亡灵的时候，她上过一次线，等级好像是20~30级的样子，我俩说了一会话，具体说的是什么我已经记不清了，那就是我俩最后一次说话。</p><p>从泰达希尔港出来，我就开始了艾泽拉斯的冒险之路：去月光林地学变熊变豹子，拖尸到血色修道院，打过那么一两次诺莫瑞根，在荆棘谷的森林里穿梭，长期蹲在塔纳利斯刷“XD求组祖尔法拉克”。</p><p>当时寝室里没有电脑装wow，总去学府三和学府四那两条街的网吧玩，就这样我成了被盗号的重灾户。记得最过分的那次上号发现角色干脆消失了，还有一回上号发现，角色被扒的就剩下一个裤衩、一个披风和一个狼头样子的皮甲头，还别说，这造型跑出去比较拉风。后来九城推出了密保卡，就是充值卡后面的8x8的数字卡，虽然有一小段时间遏制了盗号，不过缺点就是要随身带着密保卡。在网吧开机坐下了发现没带密保卡，又跑回寝室取卡的事情，我当初可没少干。</p><p>这个德鲁伊就这样摸爬滚打到了六十级满级的时候，开始刷三大本（前后斯坦索姆，通灵学院，黑石塔上层），那时候的黑下是一个冷门本，黑石深渊更不要说了，打一次就花费了几乎一下午的时光。那段反复的刷斯坦索姆和通灵学院的日子给银色十字军捐过不少亡灵印记。后来加入了工会跟工会开始打熔火之心，记得公会团长叫火枪队长，一个男人类战士，其他的一团的队员我现在还能记住名字的有：京乐春水（德鲁伊）、Hater（女人类牧师），魂之血杀（暗夜大元帅战士）。那时候的MC已经没有DOT限制了，但是还要做水元素任务，带着圣水去灭火。接触的第一个G团是祖尔格拉布，当时德鲁伊是一个稀缺职业，我就开始去打工兼消费挣俩小钱，用那点G去买拍爪子的材料。在祖格G团认识了同大学的一个哥们，叫阿尔萨斯之心，是一个女人类圣骑士，他那个时候就有祖格龙了，但是没玩太久，60级没完事就把号给卖了…MC通了后，公会团开始打黑翼之巢，我记得当时的BWL老1还有BUG，远程和治疗可以跳在窗户上。到了老2就卡的死去活来，好不容易过了老2，接下来的三个就一片通途。然后又花了一个晚上打掉了克洛玛古斯。我那时候奈法利安和克洛玛古斯打得不多，仅有的几次击杀也没有掉落怒风胸和怒风肩，这成了我60级的一个怨念。</p><p>在打BWL的时候，安其拉版本已经开始了。G团也开始做安其拉废墟的生意，我也在其中一次无疤者奥斯利安的身上得到了废墟法杖，换掉了之前埃克索图斯的挖掘锤，为了这个废墟法杖我还卖了一张卡，那时候一张卡是300G，那次好像是我唯一的一次卖卡。说到卖卡我想起来，我人生的第一只千金虎是一个暗夜盗贼赞助的，ID好像叫小什么哥，当时的G真的很值钱，非常非常感谢他。</p><p>我在地球时代RAID的最高纪录就是安其拉神殿到公主、NAXX打了蜘蛛区前二、DK区到了老1、憎恶区的帕奇维克好像是没过，反正就是一个很一般的进度啦。然后公会团就有了一些动荡，我个人总觉得德鲁伊打人不爽，还是拿起大刀砍人过瘾，于是就开始了玩战士小号的生涯，ID叫燕小鱼。战士满级后不久就开了“远征前夕”，也就是那个全民刷战场换大元帅的时代。我那时候也在YY里加入了联盟军校，开始了没日没夜刷大奥的日子，先换了猪头锤，又换了雷矛羊，最后拿着一堆牌子去换一身漂亮的大元帅，直到现在我的YY名称依旧是以“联盟军校”开头。</p><p>我玩战士的时候还认识了一个男矮人牧师，叫赤红丹朱，这个哥们手法很骚，以前是玩部落的，记得有一次我俩要去荒芜之地，在莫高雷的高原上，他说这里曾经是他玩部落开始的地方，然后看着脚下这片大草原心潮澎湃，我俩一起战斗过不少副本，从斯坦索姆到祖尔格拉布，他没有坚持到70级就不玩了，账号也给我了…我后来去他的新浪博客看过，背景音乐是王若琳的《有你的快乐》，后来的某一天，发现他的新浪博客内容就被全删光了。</p><h2><span id="燃烧的远征">燃烧的远征</span></h2><p>记得那是7月份，大二刚开学没多久，我就穿过黑暗之门开始了燃烧的远征。那时候我先升的是战士，在地狱火堡垒里面拿大砍刀砍来砍去。七十级的raid就是先从卡拉赞开始，当时我的小战士就当主t，当时跟的团团长ID是叫小豆宝宝，一个侏儒术士。那时候卡拉赞的bug很多，埃兰可以卡门，马克扎尔王子也可以卡地点。我个人对于卡拉赞比较有印象的是虚空龙，那是这个十人小团队一个比较有成就感的boss。</p><p>往后就是打格鲁尔，那个时候我记得隔壁寝室的老朱已经开始练他的女暗夜盗贼了，那个时候我俩开始比较频繁的厮混在一起，肩并肩的不上课跑去网吧打魔兽，我印象最深的一次就是他当时为了刷一个午夜护腿在沙塔斯找了一个猎人，但是这个猎人不是很靠谱，在奴里围栏一个人忙乎从早上八点到晚上八点，结果还没出，给老朱气得牙痒痒。</p><p>TBC的时候，就有了日常任务的概念，每天早上要做奥格瑞拉和虚空龙任务，后来又有了奎岛日常，日复一日的刷声望。玛瑟里顿这个副本公会团当时没有正经打，直接就开始打风暴要塞，当时打掉了凤凰和奥术师和机器人。而毒蛇神殿我跟公会打得不多，记得有打过瞎子外加鱼斯拉。这个时候，邪神禁地祖阿曼上线了，开始了有事没事冲箱子的新征程。我印象里整个70级就是一个很多bug的版本，祖阿曼体现的尤为明显，里面BUG有术士副本拉人以及祖尔金跳柱子。但是即使这样我也只冲成功过一次四箱，那一次是t6级别队伍带队，完全没用bug。除了那一次剩下的基本就是两箱，三箱屈指可数。</p><p>然后我现实的一个的哥们由于学业的问题不能继续跟团队RAID无奈只能把账号暂给我打理，于是我改玩了他的暗夜女精灵牧师，ID叫外面下雨了（后面简称下雨）。我开始跟《荣耀》公会活动，会长就是鼎鼎有名的震撼。荣耀公会最早是桑德兰服务器的，后来由于想当联通区的第一工会，就集体转服到泰拉尔。当时我也是第一次接触牧师，完全是抱大腿的姿势跟他们一团打掉阿克和伊利丹。他们打阿克因为要录视频所以是不用bug的，真真的要考验跑火的功力。第一次打伊利丹我印象很深，当时寝室里有电脑了，由于很多人当时进度很慢，所以打伊利丹的时候，全楼道的wower都来看，然后啧啧惊叹。</p><p>跟着震撼一边打进度团也一边打公会的G团，记得当时t5一套是五万金，t6一套是十五万金。再加上卖武器饰品，一趟下来也分到不少，而且还能直接跟老板换卡，据说公会当时用的付费ts语音也是用老板的钱买的。</p><p>那时候打进度团主要就是开荒太阳井，我用那个牧师号拿了全服第一个t6鞋，首down双子的战报也上了nga，地址在：<a href="http://nga.178.com/read.php?tid=1644774" target="_blank" rel="noopener">http://nga.178.com/read.php?tid=1644774</a> ，视频也被传上了优酷，但是现在那个视频找不到了，不过记得BGM还是很好听的。当时进度团活动时间是晚上七点到早上五点，真的很累人，最后击杀基尔加丹我并没有参与。但是震撼的指挥和语音口头禅给我留下了很深的记忆，他的确是一个很赞的指挥。</p><p>燃烧的远征也是我寝室山哥沉迷魔兽并且活跃的日子，当时山哥投奔了部落玩德鲁伊。我记得他们团第一次过血沸很惊险，当时血沸还有大约5%的血，T都躺光了，就在BOSS准备大肆屠杀的时候，结果血沸那时候点名，好巧不巧的点名了一个盗贼，那贼开着闪避上去顶掉了最后5%的血。其实FD就是这样，需要实力的同时也需要那么一点运气。</p><h2><span id="巫妖王之怒">巫妖王之怒</span></h2><p>当时由于大陆魔兽推迟开巫妖王，那时候我跟老朱、涛哥、永森、老刘、阿俊、小勇几个寝室的哥们还有那个下雨一起转战去了台服，改玩部落。当时我是防骑，老朱改玩牧师，涛哥是法师，老刘是盗贼兼指挥，小勇是术士、阿俊是德鲁伊、永森是萨满，下雨依旧是牧师，不过老朱主要玩的是神牧，下雨主要是暗牧，必要的时候会切奶。</p><p>老朱的魔兽之路开始于60级，当时他第一个职业是法师，最开始的时候他跟xur打赌会尽快的把等级练到骑小马的等级，话说老朱练号的速度是很快的，他也是我们几个人里玩职业好象最多的。从法师到萨满，然后还有盗贼，但是直到这次玩上了牧师，他终于找到了灵魂的归属，发现原来牧师才是他的本命。</p><p>除了老朱我多说说老刘，老刘原名刘义超，是我们年级的一个牛人，很瘦，戴个眼镜，走路有点发飘。用他话说从小身体就不好，所以不是很喜欢运动，除了打魔兽打dota就是看漫画再不然就是用psp打麻将，老刘的经典语录就是“对于我来说，每一把DOTA都是一把新的DOTA”。老刘是一个很聪明的人，打游戏思路很清晰，很少反重复的错误。他为了游戏也肯砸钱，那时候都是老刘给我们搞代理。老刘巅峰的时候在第七天堂打主力牧师，我也亲眼见过他那时候打便当二十五人英雄十字军，后来由于要带我们几个就放弃了第七天堂，转来跟我们一起组团队。当时我们几个人一边小团队打十人icc，一边也跟个工会活动。 不过后来老刘觉得公会团打得不爽，揭竿而起，自立门户开起了25人H ICC金团。每周四，都会看到一个叫德意忘形的德鲁伊在达拉然喊人刷屏，喊满了就向冰冠堡垒浩浩荡荡的出发，由老刘带队指挥，当然我们也会偷偷摸摸的黑下几件装备和一点金。老刘指挥虽然不如震撼激情，但是思路很有条理，基本上战斗力不算很差的团一个下午就打掉2到3个区。当时我已经大四下半学期了，由于有驾校考试，所以当时老刘的金团我参与了也就一半，不过在金团里我得到了大盾冰冠冰川之墙，当时好像是花了4万金。最可惜的一次就是他们有一次开出了英雄的异物逐除，卖了17万金，按当时的物价换算是二千多块人民币!那次的金团真是赚翻了。</p><p>我们十人团的进度是“十人十字军试炼最高差两次就大十字军”、“ICC普通全通”、“h我记得没过冰龙”，因为不久就要毕业了，就没有很全力的去开荒。毕业后从此我们几个战友就四散天涯：老刘回齐齐哈尔，永森和阿俊回佳木斯，涛哥留在哈尔滨，我、小勇和老朱回大庆上班，而下雨就一直在国外，直到现在也没有回来。</p><p>现在除了涛哥和老朱，我还有联系之外，其他人我已经联系不上了，也不知道他们过得好不好。</p><p>魔兽的八十级之前的版本可以说陪伴了我在大学的大多数时光，那也是我魔兽生涯唯一玩部落的时光。</p><h2><span id="大地的裂变">大地的裂变</span></h2><p>到了八十五级我又回归国服了，重返联盟命。由于大学里各位同学都开始了新的生活，我也开始直到现在的魔兽独行侠之路，独自练级独自打战场。 也从此之后，我就再也没有正经的跟过公会团，要么是打随机本看看剧情，要么就是打金团。其实我对八十五级的印象不多了。不过要说一下，八十五刚开始的5h真的很难，经常小怪的治疗一个打断不到就满血了，记得那时候打一个影牙城堡就累的死去活来。硬要说大裂变里印象比较深的，也就是打托尔巴拉德和打巨龙之魂，比如很多战士一起开剑刃风暴一起命令怒吼，场面非常壮观。那个时候我也把战士的种族转成了狼人，也背上了触手剑爬在地上跑来跑去。最后没事干，就趁此机会又练起来一个牧师和一个女人类圣骑士，开始了我的圣光追寻之旅。</p><h2><span id="熊猫人之谜">熊猫人之谜</span></h2><p>到了九十级，朋友也多了起来。主要是跟单位里的磊哥、建哥、亮哥和迪哥一起在奥拉基尔服务器玩。磊哥原先是亡灵贼，后来投奔了联盟转了女人类，但是一直都纠结女人类的动作不如男亡灵飘逸。磊哥自封外号“阿拉希小王子”，长期在农场神出鬼没，也善于在战歌抗旗。迪哥是男德莱尼萨满，满地插柱子，他是一个个性男人，死活不去网吧，坚持就在家里玩。不过迪哥玩魔兽的时间并不长，也就几个月的时间他就投奔去三国杀和单机游戏了。健哥是一个猎人，单刷无敌，他那时候是我们几个里最有G的，输出也最为残暴，不过后来他由于工作原因也忍痛割爱了。亮哥是血DK，号称“通信公司第一DK”，不过我们四个很少玩在一起，毕竟上线时间其实是错开的。</p><p>熊猫人的本我印象比较深的就是“攻打奥格瑞玛”，至于之前的恐惧之心、永春台神马的我压根就没参与过。当时我的小牧师也算练的不错了，主要得益于我下班没事经常混迹在NGA看帖子，再加上那个版本对戒律牧也特别的友好，偶尔在金团也能拿到治疗第一的补助。而磊哥一直想要箱子BOSS的马刀，最后他也算圆梦了。至于建哥一直眼馋的火鹰，好像一直都是没有达成。</p><p>这里我要感谢磊哥，当时我俩在祖尔格拉布翻新之前去刷过祖格虎，结果出虎的时候，磊哥高风亮节让给我了，满足了我开上“红色法拉利”的梦想。</p><h2><span id="德拉诺之王">德拉诺之王</span></h2><p>一百级给我的游戏感觉就是高开低走，尤其是要塞，从最开始新鲜成了后期的累赘。虽然它给了我很多战火装备，但是也让我越来越少出去。整个德拉诺之王我最喜欢的副本就是黑石铸造厂，很有六十级副本的味道，容错率很低。那个时候也认识了以骄傲纹身为首的几个朋友，也打了金团攒了不少钱，这些钱后来也都被我换成了点卡。</p><p>至于地狱火堡垒这个副本我印象不多，翻来覆去就打了两三遍h，还都是跟G团，最后过了h的阿克蒙德，m难度我压根没尝试，后来由于公司里各个朋友们由于现实各种情况AFK，我也开始改玩单机游戏，上号就是刷刷阿什兰和四本刷金，消磨时间休闲娱乐。</p><h2><span id="军团再临">军团再临</span></h2><p>到了一百一十级，几乎整个一百级都没玩的老朱重返魔兽，一口气练了牧师、死骑和恶魔猎手三个职业，我俩也配合打了几个高层大秘境，没有老朱的日子就是我自己慢慢肝神器，每周争取打一次低保，再混一次世界BOSS。也就是这张点卡玩完，我觉得魔兽已经对于我来说没有什么留恋的了，该体验的我差不多都体验过了，没体验到了我也不在乎了。我把牧师停在暴风大教堂，把战士停在暴风要塞，把圣骑士停在激流堡，下线。</p><p>至此，我整个魔兽的生涯就算总结完了。</p><h2><span id="pvp有关">PVP有关</span></h2><p>地球时代的野德不算很强，除了战歌抗旗好像就是补刀了。那时候我看过一个叫dazeroth的暗夜德鲁伊Unstoppable系列视频，觉得很吊，他的视频不算很多，但是打得很棒，然后再看德鲁伊就是一个中国风很浓的暗夜德鲁伊视频，但是我忘了他的名字了。改玩了战士之后，就看Swifty的视频和苹果牛的视频，看直播就看太极龙。牧师的话，看Hydra是最多的。</p><p>我个人认为PVP是魔兽的一个重要的玩法，不过这种玩法随着玩家属性暴涨而变得不再公平（不过有几个乱斗还是挺好玩的）。我竞技场打得不算多，从70年代组织55战队去每周去混10场到现在，加起来不超过200场的JJC实战经验。不过战场混得经验丰富，打一些战场也有自己的心得，比如征服之岛要上来抢车间，大奥如果速推不成功就要抢冰雪墓地耐心打平推，打战歌中场压制住了等于赢了8成，风暴之眼先抢墓地再抢骑，控制了地盘后第一时间去墓地堵人等等等等。但是战场毕竟各位玩家PK水平参差不齐，打战场其实更多就是一个图个乐。</p><p>至于搏击俱乐部，我没玩太多，不过金牌挑战我还是很喜欢的。</p><h2><span id="结束语">结束语</span></h2><p>魔兽世界陪伴了我12年的时光，现在回首来看，我个人最喜欢的是WLK，因为那个版本装备比较好看，其次相对来说各个职业的能力都比较平均，最重要的就是身边有一堆战友并肩作战；其次就是TBC，他在一定程度上弥补了很多60级的缺陷，而且极大地提升了惩戒骑、野德、元素萨等混合职业的存在感，不过TBC的BUG实在太多（我重复几次了？），光一个阿克我就见识过不下4种BUG打法，这一点是TBC的败笔；再其次就是90级和地球时代；大灾变和军团再临他们俩并列再后面一点。</p><p>我爱魔兽，他是我的另一个世界，因为我觉得在现实世界里能做的事情，在魔兽世界能做的更多。不可否认，我曾经在魔兽世界上投入了大量的时间，这耽误了我很多现实中的事儿，不过我还是认可它给我带来了不少的快乐。我还记得在06年的路边书摊会买魔兽世界带副本地图和掉落的攻略的那个宅男；我也记得当初那个小德鲁伊在灰谷，一边看着新浪魔兽任务详解，一边在地图上费劲的查找线索；我也记得当初圣骑士到了查索拉盆地的时候，被那种仙剑风的音乐陶醉；我也记得在阿什兰和奥特兰克山谷，战士那一身部落血的豪爽。但是一切缘分都有到头的时候（或许我将来会有机会到网易的魔兽世界部门上班，不过这个暂且不提），虽然我不能亲眼看见联盟一统艾泽拉斯，但是我还是要说，谢谢暴雪做的这款精良的游戏，感谢你陪我走过的这12年，谢谢跟我并肩作战过的战友，没有你们，我也无法享受这段丰富而美好的时光。</p><p>最后，我要用《军团再临》里面伊利丹的那个口信内容作为我整个魔兽世界生涯的结尾：</p><blockquote><p>我留下的水晶里其实有三条口信</p><p>最后一条是给你的，勇士</p><p>你证明了你对艾泽拉斯的忠诚</p><p>你的奉献和牺牲都足以与我媲美</p><p>但你还得付出许多，更多!</p><p>此刻敌人正在集结，阴云正在汇聚</p><p>从今天起，守护我们的世界和亲人的重任</p><p>就交给你了</p></blockquote><p>再见了，那些一路陪伴我的NPC们，我要离开你们了，去开始新的征程。<br><img src="/images/wowsq.jpg" alt="paradin" title="See you..."></p>]]></content>
    
    <summary type="html">
    
      12年了，到了说离开的时候了。
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="魔兽世界" scheme="http://yoursite.com/tags/%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈raid0,raid1,raid10,raid01等等硬盘阵列搭配</title>
    <link href="http://yoursite.com/2018/01/31/%E7%AE%80%E6%9E%90raid0-raid1-raid10-raid01%E7%AD%89%E7%AD%89%E7%A1%AC%E7%9B%98%E6%90%AD%E9%85%8D/"/>
    <id>http://yoursite.com/2018/01/31/简析raid0-raid1-raid10-raid01等等硬盘搭配/</id>
    <published>2018-01-31T06:43:03.000Z</published>
    <updated>2018-01-31T13:14:11.632Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="raid-0">RAID 0</span></h2><p>RAID 0可用于两个或更多硬盘或SSD。目标是提高读的性能。</p><p>数据以特定大小（通常为64KB）的块写入，并在可用驱动器中平均分配。下图显示了带有三个硬盘的RAID 0阵列的示意图。RAID控制器将第一个数据块写入硬盘1，第二个数据块写入硬盘2，第三个数据块写入硬盘3，第四个数据块再次写入硬盘1,以此类推，RAID 0中的三个1TB硬盘提供3TB的存储空间。<br><img src="/images/raid1.png" alt="paradin"></p><p>由于数据分布均匀，所以在访问的时候会从硬盘1~硬盘3提取数据，然后拼接在一起就是一个完整的数据。理论上从3个硬盘的RAID 0阵列读取数据比从一个硬盘读取要快3倍，换言之，使用RAID 0读数据的能力跟磁盘数量成正比。</p><p>RAID 0也有缺点：如果其中一个磁盘出现故障，从其他磁盘上的数据拼起来就不再是一个完整的数据了。另外，磁盘越多，则发生磁盘故障的可能性也越高。所以如果磁盘阵列里包含着对您来说很重要的数据，则最好创建频繁的备份。</p><h2><span id="raid-1">RAID 1</span></h2><p>RAID 1用于创建数据的自动副本。RAID 1会将同一份数据写入两个单独的磁盘，如果A盘出现故障，仍然可以在B磁盘上读取所有数据，当然这是比较壕的，毕竟做一件事用了两块盘。这里要注意！<font color="red">镜像和备份可不是一样！！！如果你不小心从一个磁盘A上删除了一个文件，或者某个文件被病毒侵蚀了，那它再另一个磁盘B上也是一样的待遇。只有真正的备份才能使所有文件保持其保存状态。</font>因此，如果想不让宝贵数据陷入灾难，创建频繁的备份是必须的。</p><p>RAID 1中的读性能通常与单独的硬盘差不多—-从A和B里一起读数据，谁出数据快就采用谁的，写的话就是要同时写到两个盘里去。因此，使用RAID 1来获得额外更多的读写性能是不太可能的。以下是RAID 1的工作原理图，如果HDD1坏了，那么HDD2直接上任，若HDD1里的东西被删除了，那么HDD2也会被删除，即使它上任了也是坏的。<br><img src="/images/raid2.png" alt="paradin"></p><h2><span id="raid-10和raid-01">RAID 10和RAID 01</span></h2><p>所谓RAID 10,其实就是磁盘阵列<code>先RAID 1,后RAID 0</code>,同理，RAID 01也是先<code>RAID 0,后RAID 1</code>。无论是1+0还是0+1，都至少需要4个硬盘。</p><p>这里先看一下RAID 10和RAID 01的效果图：<br><img src="/images/raid3.png" alt="paradin"></p><p>就像图里说的“在六个硬盘列里，RAID 10比RAID 01更安全”。的确，RAID 10也凭借很棒的容错能力和恢复能力当选了大多数的RAID配置，为什么不要RAID 01呢？那就是如果在RAID 0那一步磁盘就坏了，那RAID 1那步就没有意义了，因为生成的镜像全是坏镜像。</p><h2><span id="raid-3">RAID 3</span></h2><p>RAID 3是这样的：若有n块盘，其中拿出1块盘作为校验盘，剩余n-1块盘相当于作RAID 0同时读写，当n-1那里的其中一块盘坏掉时，可以通过校验码还原出坏掉盘的原始数据。这个校验方式比较特别，事奇偶检验，1 XOR 0 XOR 1=0，0 XOR 1 XOR 0=1，最后的数据是校验数据，当中间缺了一个数据时，可以通过其他盘的数据和校验数据推算出来。但是这存在了问题，由于n-1块盘做了RAID 0，每一次读写都要牵动所有盘来服务，而且万一校验盘坏掉就完蛋了。</p><h2><span id="raid-5-and-6">RAID 5 and 6</span></h2><p>上面说了RAID 10是一个很棒的方案，但是它的实现至少需要4个硬盘，这一点太伤钱了，于是就出现了RAID 5。与RAID 0一样，数据被分成块并执行写入处理，同时把RAID 3的“校验盘”也分成块分散到所有的盘里。同时，产生并写入称为“奇偶校验”的冗余代码。因此，即使其中的一个硬盘出现故障，也可以根据剩余的数据和奇偶校验来计算出丢失的数据，然后生成完整的状态数据。由于无论需要配置多少个硬盘，保存校验只使用一台设备的容量，容量效率随着待配置硬盘数量的增加而提高。<font color="red">RAID 5模式下硬盘读取数据的速度很快，因为它是从多个驱动器同时处理的</font>。预计速度将与要配置的驱动器的数量成比例地增加。但是，数据的写入/更新涉及奇偶校验的创建/更新，所以<font color="red">写入性能不高</font>。</p><p>RAID 5已经提供了一定程度的可靠性,然而也牺牲了一定的读取速度。RAID 5的局限性还表现在RAID 5仅能在一块硬盘发生故障的情况下修复数据,如果2块硬盘同时发生故障,RAID 5则无能为力。于是RAID 6应需诞生了，RAID 6同RAID 5最大的区别就是在RAID 5的基础上除了具有P校验位以外,还加入了第2个校验位Q位。当一块磁盘出现数据错误或者丢失的时候,恢复方法同RAID 5,无须使用Q校验位。当两块磁盘上的数据出现错误或者丢失的时候,恢复方法为:利用上边给出的P,Q的生成公式,联立方程组,无论受损的数据是否包括P或者Q,总是能够解出损失的两位的数据。</p><h2><span id="raid-50-and-60">RAID 50 and 60</span></h2><p>在硬盘数量较少的情况下，RAID 5是极好的选择，如7-8块硬盘组成的RAID。但是，当硬盘的数量更多的时候，如10块、20块甚至100块，那么RAID 5就无法胜任了。RAID 50是在RAID 5的基础上，将多个RAID 5组以RAID 0的形式组成在一起。可以这么认为，一个RAID 5组在这里就是一个“大硬盘”，再把这些“大硬盘”以RAID 0的形式组成在一起。而RAID 60的组成就是在RAID 6组的上面组成一个RAID 0。理论上说在写入性能方面，RAID 50相比RAID 5要好太多，而RAID 50相比性能冠军RAID 10要差一点，考虑到RAID 5在一些负载面前的平庸性能，RAID 50是个不错的中间选择。和RAID 5和RAID 10一样，RAID 50也提供极好的读性能，同时RAID 50即使使用最低配置，也需要六个硬盘，所以安装成本很高。</p><p>如果担心一个RAID组里面同时有2块硬盘发生故障，导致数据丢失，那么可以选择使用RAID 60。RAID 60提供更高的安全性，相应的其可用容量会比RAID 50少点，RAID 60即使使用最少的配置，也需要8个硬盘，所以安装成本相当高。</p><h2><span id="结语">结语</span></h2><p>以上几个磁盘阵列，从读的能力来说：RAID 5 ≈ RAID 6 ≈ RAID 60 &gt; RAID 0 ≈ RAID 10 &gt; RAID 3 ≈ RAID 1<br>从写的能力来说:RAID 10 &gt; RAID 50 &gt; RAID 1 &gt; RAID 3 &gt; RAID 5 ≈ RAID 6 ≈ RAID 60<br>如果将来有一天你对这篇文章记得不是很清晰了，那么但愿你可以记住下面这张图，这几幅图虽然对于RAID 上不是完全的准确，但是已经很大的表达清楚了各种RAID的特点了。<br><img src="/images/raid4.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://us.hardware.info/reviews/4123/raid-0-raid-1-raid-10-and-raid-5-how-do-they-actually-work" target="_blank" rel="noopener">https://us.hardware.info/reviews/4123/raid-0-raid-1-raid-10-and-raid-5-how-do-they-actually-work</a><br><a href="http://support.huawei.com/enterprise/zh/knowledge/KB1000149118/" target="_blank" rel="noopener">http://support.huawei.com/enterprise/zh/knowledge/KB1000149118/</a><br><a href="https://zh.wikipedia.org/wiki/RAID" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/RAID</a><br><a href="http://www.hpc.co.jp/raid_kaisetsu.html" target="_blank" rel="noopener">http://www.hpc.co.jp/raid_kaisetsu.html</a></p>]]></content>
    
    <summary type="html">
    
      磁盘阵列这个东西，有钱就有安全
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="raid" scheme="http://yoursite.com/tags/raid/"/>
    
      <category term="磁盘阵列" scheme="http://yoursite.com/tags/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Ansible-playbook如何获取ip</title>
    <link href="http://yoursite.com/2018/01/31/Ansible-playbook%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96ip/"/>
    <id>http://yoursite.com/2018/01/31/Ansible-playbook如何获取ip/</id>
    <published>2018-01-31T05:54:08.000Z</published>
    <updated>2018-01-31T06:21:34.530Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>公司的模块都新加了加密算法，现在就是需要把约100台机器的<code>/etc/hosts</code>文件里的zookeeper server的ip调整成新的ip 地址，目前在ansible控制机上已经写好了带有新的zookeeper server的ip的<code>/etc/hosts</code>文件，然后计划是把这个新文件下发到大约100台具体模块的服务器里，然后这100台机器的文件中把他们各自的ip和hostname添加到这个新的<code>/etc/hosts</code>文件上。</p><p>于是就写了一个ansible-playbook:<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: all</span><br><span class="line">  tasks:</span><br><span class="line">        - name: 将原有的hosts文件备份</span><br><span class="line">          shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">        - name: 将ansible端的hosts复制到各自机器上</span><br><span class="line">          copy: src=<span class="regexp">/root/</span>hosts dest=<span class="regexp">/etc/</span> owner=root group=root mode=<span class="number">0544</span></span><br><span class="line"></span><br><span class="line">        - name: 在新的hosts文件后面追加各自机器内网ip和hostname</span><br><span class="line">          lineinfile: dest=<span class="regexp">/etc/</span>hosts line=<span class="string">"`ansible_all_ipv4_addresses`  `ansible_hostname`"</span></span><br></pre></td></tr></table></figure></p><p>但是写完之后执行出来，却是这样的效果：<br><img src="/images/ansibleip.png" alt="akb48"></p><p>而我想要的是这样的效果：<br><img src="/images/ansibleip2.png" alt="akb48"></p><p>遇到这种情况怎么办？</p><p>后来调整了一下，变量用<code>IP</code>: ““，而不是<code>ansible_all_ipv4_addresses</code>。</p><p>修改了之后的playbook 如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: all</span><br><span class="line">  vars:</span><br><span class="line">        IP: <span class="string">"&#123;&#123; ansible_eth0['ipv4']['address'] &#125;&#125;"</span></span><br><span class="line">  tasks:</span><br><span class="line">        - name: 将原有的hosts文件备份</span><br><span class="line">          shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">       - name: 将ansible端的hosts复制到各自机器上</span><br><span class="line">         copy: src=<span class="regexp">/root/</span>hosts dest=<span class="regexp">/etc/</span> owner=root group=root mode=<span class="number">0644</span></span><br><span class="line"></span><br><span class="line">        - name: 在新的hosts文件后面追加各自机器内网ip和hostname</span><br><span class="line">          lineinfile: dest=<span class="regexp">/etc/</span>hosts line=<span class="string">"`IP`  `ansible_hostname`"</span></span><br></pre></td></tr></table></figure></p><p>这样就达到目的了。</p>]]></content>
    
    <summary type="html">
    
      把每一项累手的任务都转换成累心
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>mysql查看实时语句和慢sql</title>
    <link href="http://yoursite.com/2018/01/30/mysql%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%85%A2sql/"/>
    <id>http://yoursite.com/2018/01/30/mysql查看实时语句和慢sql/</id>
    <published>2018-01-30T12:50:14.000Z</published>
    <updated>2018-01-30T13:40:03.228Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="查看实时语句">查看实时语句</span></h2><p>Mysql除了手动执行的语句，还有很多在后台由其他模块执行的语句，按理来说，那些由其他模块执行的语句是不能实时查看的，因为这个资源消耗特别的大，但是当我们实在需要查看实时sql语句的时候也不是做不到，需要手动开启一个日志开关<code>general_log</code>。</p><p>首先登陆mysql，然后执行<code>show variables like &quot;general_log%&quot;;</code>，看一下反馈的结果，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"general_log%"</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| general_log      | OFF   |</span><br><span class="line">| general_log_file |       |</span><br><span class="line">+------------------+-------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure></p><p>发现这个Value是<code>off</code>，那么就说明实时记录<code>general_log</code>没有开启，如果我们要开启它很简单，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global log_output = file;</span><br><span class="line">mysql&gt; set global general_log = <span class="string">'ON'</span>;</span><br><span class="line">mysql&gt; set global general_log_file = <span class="string">'/tmp/mysql/general_log.log'</span>;</span><br></pre></td></tr></table></figure></p><p>可见我们不仅打开了<code>general_log</code>的开关，而且设置日志输出方式为文件（如果设置<code>log_output=table</code>的话，则日志结果会记录到名为<code>gengera_log</code>的表中，这表的默认引擎都是<code>CSV</code>）。同时规定它的保存位置是<code>/tmp/mysql/general_log.log</code>。</p><p>但是这个是临时方法，如果mysql重启了那么就会失效，如果想要永久有效的话，就要编辑<code>my.cnf</code>，添加下面两句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">general_log = <span class="number">1</span></span><br><span class="line">general_log_file = <span class="regexp">/tmp/my</span>sql/general_sql.log</span><br></pre></td></tr></table></figure></p><p>这里要注意！<font color="red">开启general_log会影响性能，谨慎使用!正式系统用完要关闭!!!</font>关闭的语句<code>SET GLOBAL general_log = &#39;OFF&#39;;</code>。</p><h2><span id="查看慢sql">查看慢sql</span></h2><p>慢sql的意思就是那些执行很慢的sql，这些sql拖慢进程的执行效率而且有很大的优化空间。默认的来说，执行时间超过1秒就算慢sql了，在mysql里输入<code>show variables like &#39;long%&#39;</code>，就会看到如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'long%'</span>;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | <span class="number">1.000000</span> |</span><br><span class="line">+-----------------+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>这个<code>long_query_time</code>是可以更改的，这里是1，那就是代表查询时间大于(不是大于等于)1秒的都是记录到日志，最大值是10。如果写的是0，那么就是输出所有的语句。</p><p>这里多说一句，使用命令<code>set global long_query_time=4</code>修改慢查询阈值为4秒后，需要重新连接或新开一个会话才能看到修改值。你用<code>show variables like &#39;long_query_time&#39;</code>查看是当前会话的变量值，你也可以不用重新连接会话，而是用<code>show global variables like &#39;long_query_time&#39;;</code>。</p><p>那么记录这些慢日志的地方在哪呢？使用<code>show variables  like &#39;%slow_query_log%&#39;;</code>看看：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like <span class="string">'%slow_query_log%'</span>;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                           |</span><br><span class="line">| slow_query_log_file | <span class="regexp">/tmp/my</span>sql/DB-Server-slow.log   |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>这里说明慢日志的地址是<code>/tmp/mysql/DB-Server-slow.log</code>，但是慢日志记录的功能没有启动。如果要启动，语句是：<code>set global slow_query_log=1;</code>，跟上面开启实时日志<code>general_log</code>一样，这个方法仅仅是一个临时方法，重启了mysql就会失效，如果要长期生效，还是在<code>my.cnf</code>文件里添加如下两句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log =<span class="number">1</span></span><br><span class="line">slow_query_log_file=<span class="regexp">/tmp/my</span>sql/DB-Server-slow.log</span><br></pre></td></tr></table></figure></p><p>慢日志还有一个系统变量叫<code>log-queries-not-using-indexes</code>，它的意思是未使用索引的查询也被记录到慢查询日志中，哪怕他可能执行的非常快（可选项）。如果调优的话，建议开启这个选项。另外，开启了这个参数，其实使用<code>full index scan</code>的sql也会被记录到慢查询日志。如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'log_queries_not_using_indexes'</span>;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| log_queries_not_using_indexes | OFF   |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global log_queries_not_using_indexes=<span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>如果你想自己试试慢sql是否被记录，那么可以使用<code>select sleep(5);</code>这样的语句，执行效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(<span class="number">5</span>) ;</span><br><span class="line">+----------+</span><br><span class="line">| sleep(<span class="number">5</span>) |</span><br><span class="line">+----------+</span><br><span class="line">|        <span class="number">0</span> |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">5.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> mysql.slow_log;</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| start_time          | user_host                 | query_time | lock_time | rows_sent | rows_examined | db | last_insert_id | insert_id | server_id | sql_text        | thread_id |</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| <span class="number">2018</span><span class="number">-01</span><span class="number">-30</span> <span class="number">21</span>:<span class="number">45</span>:<span class="number">23</span> | root[root] @ localhost [] | <span class="number">00</span>:<span class="number">00</span>:<span class="number">05</span>   | <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  |         <span class="number">1</span> |             <span class="number">0</span> |    |              <span class="number">0</span> |         <span class="number">0</span> |         <span class="number">1</span> | select sleep(<span class="number">5</span>) |         <span class="number">2</span> |</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line"><span class="number">1</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.cnblogs.com/kerrycode/p/5593204.html" target="_blank" rel="noopener">http://www.cnblogs.com/kerrycode/p/5593204.html</a><br><a href="https://www.cnblogs.com/qmfsun/p/4844472.html" target="_blank" rel="noopener">https://www.cnblogs.com/qmfsun/p/4844472.html</a><br><a href="http://www.cnblogs.com/jasondan/p/3491258.html" target="_blank" rel="noopener">http://www.cnblogs.com/jasondan/p/3491258.html</a></p><p><img src="/images/curry3p.gif" alt="库里三分" title="神射手萌库"></p>]]></content>
    
    <summary type="html">
    
      这些都是在自己的mysql上使用的，云厂家的数据库就不要想了，需要在控制台查看。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Goaccess---良心nginx日志分析工具</title>
    <link href="http://yoursite.com/2018/01/30/Goaccess-%E8%89%AF%E5%BF%83nginx%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/01/30/Goaccess-良心nginx日志分析工具/</id>
    <published>2018-01-30T07:42:33.000Z</published>
    <updated>2018-01-30T07:53:27.531Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Goaccess是一个非常良心的开源软件，它的良心之处体现在如下方面：</p><ul><li>安装简单；</li><li>操作容易；</li><li>界面酷炫；</li></ul><h2><span id="安装">安装</span></h2><p>安装<code>Goaccess</code>十分的简单，在centos里直接<code>yum install goaccess</code>，如果yum源里没有<code>goaccess</code>，可以先安装<code>epel</code>。安装<code>epel</code>的方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></span><br><span class="line">wget http:<span class="comment">//rpms.famillecollet.com/enterprise/remi-release-6.rpm</span></span><br><span class="line">rpm -Uvh remi-release<span class="number">-6</span>*.rpm epel-release<span class="number">-6</span>*.rpm</span><br></pre></td></tr></table></figure></p><h2><span id="配置和使用">配置和使用</span></h2><p>安装完<code>goaccess</code>之后，我们需要在<code>/etc/goaccess.conf</code>里添加如下几句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time-format %T</span><br><span class="line">date-format %d/%b/%Y</span><br><span class="line">log-format %h %^[%d:%t %^] “%r” %s %b “%R” “%u”</span><br></pre></td></tr></table></figure></p><p>保存退出之后，我们就可以通过<code>goaccess</code>来分析<code>nginx</code>日志了，语句格式也很简单：<code>goaccess -f nginx日志的绝对路径</code>。比如我的nginx日志是<code>access-chen.log</code>，查看一下里面的内容：<br><img src="/images/goaccess1.png" alt="goaccess"></p><p>虽然有规律，但是看上去很乱，需要在分析日志之前喝两瓶静心口服液。</p><p>然后我就<code>goaccess -f access-chen.log</code>，就会看到如下的界面：<br><img src="/images/goaccess2.png" alt="goaccess"></p><p>这一下，整个日志看起来更加友好，更加直白，更加高大上。足以吸引周围人的羡慕目光。</p><p>但是这里面还是有一个注意点：<code>goaccess</code>默认支持的日志格式是<code>nginx</code>默认的日志格式，也就是nginx.conf里的如下格式：<br><img src="/images/goaccess3.png" alt="goaccess"></p><p>如果你的日志格式是有过更改的，而且还不想改回来，那么就需要去<code>/etc/goaccess.conf</code>里对应的<code>log-format</code>进行更改。</p><p>这还没有完，goaccess还可以生成html，这里<code>goaccess -f access-chen.log  -a &gt; /nginx安装路径/html/chen.html</code>。然后在浏览器里登陆到这个服务器的chen.html，就会看到整个日志情况的网页排版，如图：<br><img src="/images/goaccess4.png" alt="goaccess"></p><p>这样的话，我们可以每一天都发一份当天的日志html去运维人员的信箱里，这样更加方便我们分析日志。</p><h2><span id="缺点">缺点</span></h2><p>虽然前面说了那么多goaccess的优点，但是缺点也是有的，比如<code>goaccess</code>的粒度太粗，只能按天分割，如果要按小时分割，需要先<code>grep</code>出来，这个做法比较挫我懂…</p><p>还有一个缺点，就是访问人的来源只能定位到国家，无法具体定位到省市县村屯…<br><img src="/images/goaccess5.png" alt="goaccess"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.maxhemby.se/determine-the-apache-traffic-load/#respond" target="_blank" rel="noopener">http://blog.maxhemby.se/determine-the-apache-traffic-load/#respond</a></p>]]></content>
    
    <summary type="html">
    
      面试的时候一定会被面到的问题是：给出web服务器的访问日志，请写一个脚本来统计访问前10的IP有哪些？访问前10的请求有哪些？当你领略过goaccess之后，你就明白，这些问题，除了考验你的脚本背诵记忆能力以外，唯一的作用只有装A或者装C了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="日志统计" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>处理掉积压过多的activemq持久化消息</title>
    <link href="http://yoursite.com/2018/01/29/%E5%A4%84%E7%90%86%E6%8E%89%E7%A7%AF%E5%8E%8B%E8%BF%87%E5%A4%9A%E7%9A%84activemq%E6%8C%81%E4%B9%85%E5%8C%96%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/01/29/处理掉积压过多的activemq持久化消息/</id>
    <published>2018-01-29T06:27:26.000Z</published>
    <updated>2018-01-31T06:03:32.033Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="问题描述">问题描述</span></h2><p>在项目使用<code>activemq 5.14</code>时，客户端发送消息而没有得到回复（在不考虑消费者是什么问题的情况下），导致持久化消息不断积压而得不到释放，最后造成队列堵塞而嗝屁。</p><p>一般来说遇到这样的情况，可以在配置文件中配置消息的过期时间和死信处理来防止消息的积压，配置如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">       &lt;!-- <span class="number">86</span>,<span class="number">400</span>,<span class="number">000</span>ms = <span class="number">1</span> day --&gt;</span><br><span class="line">         &lt;timeStampingBrokerPlugin ttlCeiling=<span class="string">"10000"</span> zeroExpirationOverride=<span class="string">"10000"</span>/&gt;</span><br><span class="line">     &lt;<span class="regexp">/plugins&gt;</span></span><br></pre></td></tr></table></figure></p><p>配置消息过期时间使用<code>timeStampingBrokerPlugin</code>插件,<code>ttlCeiling</code>：表示过期时间上限（模块程序写的过期时间不能超过此时间，超过则以此时间为准），<code>zeroExpirationOverride</code>：表示过期时间（给未分配过期时间的消息分配过期时间），一般来说这两个值是一样的。执行之后，message过期则客户端不能接收，那些已经过期的message将会保存在<code>data/kahadb</code>目录下。</p><p>但是最近发现了一个问题，就是<code>data/kahadb</code>这个目录最近越来越大，越积越多。但是这个topic和quere又依旧是“持续订阅”的，它的消费者还在。遇到这样的情况，如何在activemq里配置呢？</p><h2><span id="解决办法">解决办法</span></h2><ul><li><p>配置message过期自动丢弃策略</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;borker&gt;</span><br><span class="line">   &lt;destinationPolicy&gt;</span><br><span class="line">       &lt;policyMap&gt;</span><br><span class="line">           &lt;policyEntries&gt;</span><br><span class="line">               &lt;policyEntry topic=<span class="string">"&gt;"</span> expireMessagesPeriod=<span class="string">"60000"</span>&gt;</span><br><span class="line">                   &lt;deadLetterStrategy&gt;</span><br><span class="line">                        &lt;sharedDeadLetterStrategy processExpired=<span class="string">"false"</span> /&gt;</span><br><span class="line">                   &lt;<span class="regexp">/deadLetterStrategy&gt;</span></span><br><span class="line"><span class="regexp">               &lt;/</span>policyEntry&gt;</span><br><span class="line">           &lt;<span class="regexp">/policyEntries&gt;</span></span><br><span class="line"><span class="regexp">       &lt;/</span>policyMap&gt;</span><br><span class="line">   &lt;<span class="regexp">/destinationPolicy&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>borker&gt;</span><br></pre></td></tr></table></figure></li></ul><p>标签<code>processExpired=&quot;false&quot;</code>表示<font color="red">不保存过期消息到死信队列，处理手段为删除</font>，为<code>true</code>则是保留。<br>标签<code>expireMessagesPeriod=&quot;60000&quot;</code>属性表示每隔60秒钟检查message是否过期。<br><code>topic=&quot;&gt;&quot;</code>表示该策略对所有topic都生效。而<code>topic=&quot;active.&gt;&quot;</code>就表示该策略对以<code>active.</code>开头的所有<code>topic</code>生效，注意有个点号<code>.</code>。</p><ul><li>message过期时间设置<br>上面那步搞定了之后，再修改<code>timeStampingBrokerPlugin</code>标签里<code>ttlCeiling=&quot;360000&quot; zeroExpirationOverride=&quot;360000&quot;</code>表示过期时间为360000ms（1小时）。  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;borker&gt;</span><br><span class="line">   &lt;plugins&gt;</span><br><span class="line">       &lt;!-- <span class="number">86</span>,<span class="number">400</span>,<span class="number">000</span>ms = <span class="number">1</span> day --&gt;</span><br><span class="line">       &lt;timeStampingBrokerPlugin ttlCeiling=<span class="string">"360000"</span> zeroExpirationOverride=<span class="string">"360000"</span> /&gt;</span><br><span class="line">   &lt;<span class="regexp">/plugins&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>borker&gt;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="解决空队列的方法">解决“空队列”的方法</span></h2><p>如果不是那种“持续订阅”的topic，那就简单了，配置如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> schedulePeriodForDestinationPurge=<span class="string">"10000"</span>&gt;</span><br><span class="line">   &lt;destinationPolicy&gt;</span><br><span class="line">      &lt;policyMap&gt;</span><br><span class="line">         &lt;policyEntries&gt;</span><br><span class="line">            &lt;policyEntry queue=<span class="string">"&gt;"</span> gcInactiveDestinations=<span class="string">"true"</span> inactiveTimoutBeforeGC=<span class="string">"30000"</span>/&gt;</span><br><span class="line">         &lt;<span class="regexp">/policyEntries&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>policyMap&gt;</span><br><span class="line">   &lt;<span class="regexp">/destinationPolicy&gt;     </span></span><br><span class="line"><span class="regexp"> &lt;/</span>broker&gt;</span><br></pre></td></tr></table></figure></p><p><code>schedulePeriodForDestinationPurge</code>执行清理任务的周期，<code>gcInactiveDestinations=&quot;true&quot;</code>表示启用清理功能，<code>inactiveTimoutBeforeGC=&quot;30000&quot;</code>这个是Topic或Queue超时时间,在规定的时间内，无有效订阅，没有入队记录，超时后就会被清理。<br><img src="/images/大帝扣威少.gif" alt="" title="大帝扣威少！"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://activemq.apache.org/timestampplugin.html" target="_blank" rel="noopener">http://activemq.apache.org/timestampplugin.html</a></p>]]></content>
    
    <summary type="html">
    
      “不活动的空队列”和“过期队列”可不是一个意思！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="activemq" scheme="http://yoursite.com/tags/activemq/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python里调用redis的方法</title>
    <link href="http://yoursite.com/2018/01/29/Python%E9%87%8C%E8%B0%83%E7%94%A8redis%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/29/Python里调用redis的方法/</id>
    <published>2018-01-29T04:38:39.000Z</published>
    <updated>2018-01-29T04:48:40.333Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>Python 2.7里不是自带<code>redis</code>模块的，那么在调用redis的时候自然也会报错，比如：<br><img src="/images/pyredis1.png" alt=""></p><p>遇到这种情况怎么办？</p><p>第一种方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure></p><p>第二种方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install redis</span><br></pre></td></tr></table></figure></p><p>第三种方法：<br>去登录<code>https://github.com/andymccurdy/redis-py</code>，下载包上传到linux里之后，<code>python setup.py install</code>。<br><img src="/images/pyredis2.png" alt=""></p><p>flask模块的安装也是同理。</p><p>注意！这里只有<code>Redis</code>，如果使用<code>StrictRedis</code>会报错：<code>AttributeError: &#39;Redis&#39; object has no attribute &#39;StrictRedis&#39;</code>。这个是版本的问题。见<br><a href="https://github.com/andymccurdy/redis-py/issues/188" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py/issues/188</a></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://debugo.com/python-redis/" target="_blank" rel="noopener">http://debugo.com/python-redis/</a></p><p><img src="/images/欧文骚脚步.gif" alt="" title="这脚步把我看高潮了..."></p>]]></content>
    
    <summary type="html">
    
      本文的写作来源于《第一本 docker书》的第189页。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Ssh连接port 22: Connection refused</title>
    <link href="http://yoursite.com/2018/01/29/Ssh%E8%BF%9E%E6%8E%A5port-22-Connection-refused/"/>
    <id>http://yoursite.com/2018/01/29/Ssh连接port-22-Connection-refused/</id>
    <published>2018-01-29T03:30:18.000Z</published>
    <updated>2018-01-29T03:38:54.116Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>金山云有一个服务器需要连接到数据库但是总是失败，检查之后发现它的VPC配错了，更改VPC之后，这台服务器也会更换一个新的内网IP地址，但是问题来了，更换了内网IP之后，从跳板机连接，提示<code>port 22: Connection refused</code>。</p><p><code>ssh -v 新的ip地址</code>发现根本没有到<code>Connection established</code>。直接就提示<code>port 22: Connection refused</code>。这基本可以断定不是跳板机的问题了，那么就需要在远程机器里看配置。</p><p>但是远程机器是无法连接的啊，怎么办？从金山控制台“连接实例”。<br><img src="/images/ksssh1.png" alt=""></p><p>然后键盘随便按一下，就会看到linux界面，输入账号名和密码，这里密码不支持复制粘贴，需要手动输入。然后就会看到如下界面。<br><img src="/images/ksssh2.png" alt=""></p><p>这样，我们就可以登陆这台机器了，然后<code>vim /etc/ssh/sshd_config</code>，看到最上面有这样的内容。<br><img src="/images/ksssh3.png" alt=""></p><p>这个<code>listenaddress</code>后面就是跳板机ssh的地址，但是这个地址还是老的，而不是更改过后的内网ip地址，所以ssh的连接自然就是<code>refuse</code>。所以我们只需要手动更改成新的内网ip地址就好了。</p><p>更改完之后，重启一下服务器或者<code>/etc/init.d/sshd restart</code>就可以从跳板机上正常连接了。</p><p>如果在<code>/etc/init.d/sshd restart</code>的时候爆出“address family must be specified before ListenAddress”的错误，那么就把<code>AddressFamily</code>移到<code>ListenAddress</code>上面就可以了，如图：<br><img src="/images/ksssh4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      调换了内网IP之后，来了这么一出
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>SFTP不能连接服务器怎么办？</title>
    <link href="http://yoursite.com/2018/01/27/SFTP%E4%B8%8D%E8%83%BD%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/01/27/SFTP不能连接服务器怎么办？/</id>
    <published>2018-01-27T08:19:55.000Z</published>
    <updated>2018-01-29T04:35:52.647Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在跳板机上传送文件，发现使用<code>SFTP</code>连接的时候，出现了这样的一个拒绝情况：<br><img src="/images/sftp1.png" alt=""></p><p>登陆到这个跳板机里，使用<code>tail /var/log/secure</code>，看到了拒绝的具体信息，如下：<br><img src="/images/sftp2.png" alt=""></p><p>这个时候，我就需要<code>locate sftp-server</code>，用<code>locate</code>定位一下<code>sftp</code>文件，但是发现服务器竟然回答我<code>-bash: locate: command not found</code>。</p><p>于是就<code>yum -y install mlocate</code>，安装<code>mlocate</code>之后执行<code>updatedb</code>，需要等待一小会，然后再次执行<code>locate sftp-server</code>，就可以得到sftp-server的文件路径了，如下图：<br><img src="/images/sftp3.png" alt=""></p><p>打开sshd的配置文件，<code>vi /etc/ssh/sshd_config</code>，把<code>Subsystem</code>这一行前面的<code>#</code>去掉：<br><img src="/images/sftp4.png" alt=""></p><p>然后重启启动ssh服务，语句是<code>/etc/init.d/sshd reload</code>，重新连接一下，发现就恢复正常了。</p>]]></content>
    
    <summary type="html">
    
      总有意向不到的插曲
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="sftp" scheme="http://yoursite.com/tags/sftp/"/>
    
  </entry>
  
  <entry>
    <title>Ansible部署模块的时候出现中文乱码的问题</title>
    <link href="http://yoursite.com/2018/01/27/Ansible%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/27/Ansible部署模块的时候出现中文乱码的问题/</id>
    <published>2018-01-27T05:58:49.000Z</published>
    <updated>2018-01-27T06:02:16.658Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在部署服务的时候遇到了一个很罕见的现象，线上有15台服务器是手机推送消息的服务，新来的小运维使用ansible批量跑部署脚本的时候，发现手机端接收到来的消息全是乱码，然后登陆到服务器，查看日志发现，日志里面就是乱码，如图：<br><img src="/images/luanma1.png" alt=""></p><p>由于这个问题用户是有感知的，所以属于“事故”级别了，于是小boss大怒，叫运维赶快回滚，然后让开发赶紧重新检查代码，然后开骂测试都是吃屎的么这么大的一个问题都看不出来真是一群猪伤不起啊。</p><p>开发看了半天自己的代码，发现没有任何问题，战战兢兢跑来跟新来的小运维窃窃私语，结果我发现这个模块用手动单独部署，日志却是正常的，中文显示十分OK。<br><img src="/images/luanma2.png" alt=""></p><p>这一下开发就腰杆硬了，说这不是我的锅啊我是无辜的啊老子天天辛苦加班没有功劳也有苦劳没有苦劳也有疲劳老子的代码经得住考验这一切就是部署的问题。</p><p>于是我就查看了一下ansible的配置文件，<code>vim /etc/ansible/ansible.cfg</code>，发现了问题所在：<br><img src="/images/luanma3.png" alt=""></p><p>这里最后三行需要改成下面的样子，这样就解决了乱码问题。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#module_lang    = C</span><br><span class="line">#module_set_locale = False</span><br><span class="line">module_lang    = zh_CN.UTF<span class="number">-8</span></span><br><span class="line">module_set_locale = True</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这个情况纯属意外...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
      <category term="自动化部署" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6.x安装php 5.6和redis扩展的全过程</title>
    <link href="http://yoursite.com/2018/01/26/CentOS-6-x%E5%AE%89%E8%A3%85php-5-6%E5%92%8Credis%E6%89%A9%E5%B1%95%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/26/CentOS-6-x安装php-5-6和redis扩展的全过程/</id>
    <published>2018-01-26T10:00:08.000Z</published>
    <updated>2018-01-26T10:03:53.515Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装php-56">安装PHP 5.6</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum update    整体升级一下yum包</span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum list installed | grep php    检查时候安装过PHP</span><br><span class="line">rpm -Uvh http:<span class="comment">//mirror.webtatic.com/yum/el6/latest.rpm </span></span><br><span class="line">yum -y install php56w.x86_64</span><br><span class="line">yum -y --enablerepo=webtatic install php56w-devel</span><br><span class="line">yum -y install php56w-xml.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 php56w-opcache.x86_64</span><br><span class="line">yum -y install php56w-fpm</span><br><span class="line">chkconfig php-fpm on    开机自启动</span><br><span class="line">/etc/init.d/php-fpm start    启动进程</span><br><span class="line">php -v    查看是否安装成功</span><br></pre></td></tr></table></figure></code></pre><p><img src="/images/php1.png" alt=""><br>注1：如果想更换到php5.5或5.4版本, 直接把上面的56w换成55w或者54w就可以了；<br>注2：php-opcache和php-xcache会有效的提高php执行速度；</p><p>装php的扩展其实不是很麻烦，主要的步骤如下：<br>1）在扩展模块的客户端文件夹里面使用phpize，这样会生成一个configure文件；<br>2）执行configure文件，后面要加上php的路径；<br>3）将“模块.so”文件名添加到php.ini文件里，重启php-fpm进程；<br>4）通过so文件去调用扩展模块的客户端，实现连接对应的模块；</p><h2><span id="安装redis扩展">安装redis扩展</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -v    检查是否安装了redis</span><br><span class="line">redis-server -v</span><br><span class="line">wget http:<span class="comment">//pecl.php.net/get/redis-2.2.8.tgz </span></span><br><span class="line">tar -zxvf redis<span class="number">-2.2</span><span class="number">.8</span>.tgz</span><br><span class="line">cd redis<span class="number">-2.2</span><span class="number">.8</span>    </span><br><span class="line">phpize    一个专门挂接php扩展的工具，该命令一定要使用在php的模块文件夹主目录下，这里报错Cannot find config.m4。因为phpize要根据模块生成模块的配置文件放在模块文件夹下面</span><br></pre></td></tr></table></figure></code></pre><p><img src="/images/php2.png" alt=""><br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="keyword">with</span>-php-config=<span class="regexp">/usr/</span>bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">make test</span><br><span class="line">vim /etc/php.ini      在php.ini里添加一句“extension=<span class="string">"redis.so"</span>”</span><br><span class="line">service php-fpm restart</span><br></pre></td></tr></table></figure></p><p><img src="/images/php3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      《世界第一等》---伍佰         听闽南语歌，就有一个感觉：我虽卑微平凡，但是不甘平庸，最穷不过要饭，不死总会出头！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>一个连接两个文件的python脚本</title>
    <link href="http://yoursite.com/2018/01/26/%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84python%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/01/26/一个连接两个文件的python脚本/</id>
    <published>2018-01-26T07:13:26.000Z</published>
    <updated>2018-01-26T10:15:18.813Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1><span id="背景交代">背景交代</span></h1><p>公司在阿里云上有一个模块叫mrs，一共120台，它是跟云录像有关的，这个服务一直都是云服务器里没有公网但是购买了公网SLB，然后20个为一组配置到一个SLB里，这个SLB是按流量收费的。但是最近到了年末，各种账目审核，领导发现这个SLB的费用太惊人了，这么搞不够挣的。但是实在没办法，因为云录像嘛，肯定流量很大，如图：<br><img src="/images/mrs1.png" alt=""></p><p>纵然流量大，但是开源节流也是必须的，于是领导就责令开发赶快想出一个办法，减少SLB的费用。于是开发们拉上运维就吭哧吭哧的开始算经济账，最后确定每一个云服务器买7M带宽，然后流量全部走公网，把SLB的架构舍弃掉。</p><p>但是开发在这个模块V2.0里有一个变化，就是Zookeeper需要读取到每一台设备的外网IP，同时这个外网IP必须跟机器是一一对应的，这样模块才能正常工作。</p><p>原来的zookeeper在servermap是长这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">剩下略</span><br></pre></td></tr></table></figure></p><p>而现在开发要求改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"对应的外网IP"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"对应的外网IP"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"对应的外网IP"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">剩下略</span><br></pre></td></tr></table></figure></p><p>那么这就要把两个文件合并起来了，而且是在合并后做到一对一，不能把IP搭配串了。</p><h1><span id="准备工作">准备工作</span></h1><p>首先，阿里云的网页控制台是无法做到“包年包月的服务器批量永久升级基础带宽”的，只能通过API实现。那么开启了外网IP之后，服务器就会有一个对应的外网IP地址，然后在控制台里，点击“导出资源列表”，只选择<code>服务器名称</code>、<code>内网IP</code>和<code>外网IP</code>。<br><img src="/images/mrs2.png" alt=""></p><p>然后在生成的excel表格里，剪除掉不需要的服务器以及服务器名称，然后保证“内网IP”在前，“外网IP”在后的样式，而且不要服务器名只保留IP,然后把这个文件复制到linux里，起个名，比如叫<code>IP.txt</code>,如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 tmp]# cat IP.txt</span><br><span class="line"><span class="number">10.161</span><span class="number">.236</span><span class="number">.231</span><span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line"><span class="number">10.161</span><span class="number">.235</span><span class="number">.150</span>  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line"><span class="number">10.51</span><span class="number">.10</span><span class="number">.182</span><span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line"><span class="number">10.117</span><span class="number">.219</span><span class="number">.72</span>   <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p><p>再把已经使用的zookeeper复制一下，放到一个叫<code>mingdan.txt</code>的文件里，如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 tmp]# cat mingdan.txt</span><br><span class="line">[<span class="string">"10.117.219.72"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.161.235.150"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.161.236.231"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.51.10.182"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br></pre></td></tr></table></figure></p><h1><span id="脚本思路">脚本思路</span></h1><p>我最开始打算用<code>awk</code>的<code>NR</code>、<code>FNR</code>去写，但是发现由于我这个文本的结构太过复杂。<code>awk</code>对付这样的力不从心，稍不好就把人搞得无法自拔，于是就考虑使用python的字典。</p><p>各位都知道，字典里key是不能重复的，而我又不想把这个脚本搞得太复杂，就想在<code>mingdan.txt</code>里的每一行加上序号，用这个序号去当key，而后面的内网IP就作为value，这样保证一一对应。加序号的方法很多，你可以在<code>vim</code>状态下<code>:set number</code>，然后手动复制粘贴。不过我是用的是如下两个命令：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i 's/^[ \t]*//g' mingdan.txt#这一步是添加每一行序号</span><br><span class="line">sed -i 's/\t/ /g'  mingdan.txt#添加序号之后，会生成一个ta</span><br></pre></td></tr></table></figure></p><p>然后<code>mingdan.txt</code>就成了这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 tmp]# cat mingdan.txt </span><br><span class="line"><span class="number">1</span> [<span class="string">"10.117.219.72"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">2</span> [<span class="string">"10.161.235.150"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">3</span> [<span class="string">"10.161.236.231"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">4</span> [<span class="string">"10.51.10.182"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br></pre></td></tr></table></figure></p><p>万事俱备，现在就要把<code>IP.txt</code>和<code>mingdan.txt</code>按照相同的内网IP整合成一个文件！</p><h1><span id="脚本正文">脚本正文</span></h1><p>这个脚本是不怕<code>mingdan.txt</code>和<code>IP.txt</code>的IP顺序的。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">fd = &#123;&#125;#先设置一个新的空字典叫fd</span><br><span class="line">#以下都是最后拼字符串用的</span><br><span class="line">aaa = <span class="string">'["'</span></span><br><span class="line">bbb = <span class="string">'"] = &#123;app = "mrs",mrsReportIp = "'</span></span><br><span class="line">ccc = <span class="string">'",weight = 100&#125;,'</span></span><br><span class="line"> </span><br><span class="line">#首先先判断mingdan.txt里是否存在</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> open(<span class="string">'mingdan.txt'</span>, <span class="string">'r'</span>):</span><br><span class="line">        ar = re.split(r'[ ""]',l)#做分割，把内网IP切出来</span><br><span class="line">        print "ip is :" + ar[2]#确认是否分割出来的是内网IP地址</span><br><span class="line">        fd[ar[0]] = ar[2]#把这个内网IP地址当作value，前面的序号就是key</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'out.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> open(<span class="string">'IP.txt'</span>, <span class="string">'r'</span>):</span><br><span class="line">                ar = l.split()</span><br><span class="line">                if ar[0] in fd.values():#如果IP.txt里面的内网IP与字典fd里的value相符合</span><br><span class="line">                       fw.write(aaa + ar[0] + bbb + ar[1] + ccc)#拼成一个完整的字符串</span><br><span class="line">                       fw.write('\n')#保存文件</span><br><span class="line">print(<span class="string">'文件整合完毕，请查看out.txt的结果！'</span>)</span><br></pre></td></tr></table></figure></p><h1><span id="执行结果">执行结果</span></h1><pre><code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 tmp]# cat out.txt </span><br><span class="line">[<span class="string">"10.117.219.72"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"1.1.1.1"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.161.235.150"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"2.2.2.2"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.161.236.231"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"3.3.3.3"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.51.10.182"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"4.4.4.4"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[root@paas-online-crs-001 tmp]#</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      看了今年的阿里云账单，大领导眉头一皱，发现事情不是那么简单
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix-proxy的搭建和配置全过程</title>
    <link href="http://yoursite.com/2018/01/26/Zabbix-proxy%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/26/Zabbix-proxy的搭建和配置全过程/</id>
    <published>2018-01-26T06:27:04.000Z</published>
    <updated>2018-01-26T07:06:37.849Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1><span id="zabbix-proxy的用途和构建图">Zabbix-proxy的用途和构建图</span></h1><p>Zabbix-server是建立在金山云的，现在需要监控阿里云的redis，但是阿里云跟金山云之间通信是无法走内网的，如果直接让zabbix-server与redis直接联系，一旦公网的信息被截获的话，整个金山区的zabbix可能都会遭殃，那么既然有这种“远程监控+当监控的位置通信不便”的需求，就搭建一个zabbix-proxy来解决问题。</p><p>Zabbix-proxy是一个监控代理服务器，它收集监控到的数据，先存放在缓冲区，保存的时间可以通过配置文件设定，然后再传送到zabbix-server，这样也大大减缓了zabbix-server的压力，<font color="red">注意！监控代理需要一个单独的数据库，因为它的数据库表名与zabbix-server的数据库表名是一样的，如果不单独分开，后果就是数据错乱。</font></p><p>有人看到这里可能问了，说来说去你的zabbix-proxy跟阿里的redis依旧是走公网的啊！虽然这样也是走公网，我现在只需要配置一个防火墙规则来让他俩保证通信即可，通过防火墙来提升安全系数。架构如图：<br><img src="/images/proxy1.png" alt=""></p><h1><span id="安装mysql-55">安装Mysql 5.5</span></h1><p>Zabbix-proxy机器情况：金山云<code>centos 6.5</code>，安装zabbix版本：<code>3.0.8</code><br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@js-online-cjhmq-002 opt]yum list installed | grep mysql    #列出已经安装过的mysql情况</span><br><span class="line">[root@js-online-cjhmq-002 opt]yum -y remove mysql-libs.x86_64      #把之前的mysql连根拔起</span><br><span class="line">[root@js-online-cjhmq-002 opt]# rpm -ivh http://repo.mysql.com/yum/mysql-5.5-community/el/6/x86_64/mysql-community-release-el6-5.noarch.rpm</span><br><span class="line">Retrieving http:<span class="comment">//repo.mysql.com/yum/mysql-5.5-community/el/6/x86_64/mysql-community-release-el6-5.noarch.rpm</span></span><br><span class="line">Preparing...                ########################################### [100%]</span><br><span class="line">  1:mysql-community-release########################################### [100%]</span><br><span class="line">[root@js-online-cjhmq-002 opt]groupadd zabbix                       #新建用户组zabbix</span><br><span class="line">[root@js-online-cjhmq<span class="number">-002</span> opt]useradd -g zabbix -u <span class="number">808</span> -m zabbix</span><br><span class="line">#-g：指定用户所属的群组；</span><br><span class="line">#-u：指定用户id。</span><br><span class="line">#-m：自动建立用户的登入目录；</span><br></pre></td></tr></table></figure></p><p>现在要修改一下<code>/etc/yum.repos.d/mysql-community.repo</code>这个文件，将5.5的enabled改为1,5.6的enabled改为0：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Enable to use MySQL 5.5</span><br><span class="line">[mysql55-community]</span><br><span class="line">name=MySQL <span class="number">5.5</span> Community Server</span><br><span class="line">baseurl=http:<span class="comment">//repo.mysql.com/yum/mysql-5.5-community/el/6/$basearch/</span></span><br><span class="line">enabled=1    #这里改成1</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">gpgkey=file:<span class="regexp">/etc/</span>pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br><span class="line"># Enable to use MySQL 5.6</span><br><span class="line">[mysql56-community]</span><br><span class="line">name=MySQL <span class="number">5.6</span> Community Server</span><br><span class="line">baseurl=http:<span class="comment">//repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/</span></span><br><span class="line">enabled=0    #这里改成0</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=file:<span class="regexp">/etc/</span>pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure></p><p>然后执行<code>yum install mysql-community-client mysql-community-devel mysql-community-server php-mysql</code>， 安装服务端和客户端，安装完毕之后可以<code>mysql -h127.0.0.1</code>看一下。<br><img src="/images/proxy2.png" alt=""></p><p>安装完毕之后，修改一下<code>/etc/my.cnf</code>，如图：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size = 512M        #这个根据服务器性能填写，这个机器是2核2G的，所以我拿出半个G给mysql</span><br><span class="line">innodb_file_per_table=1               #这个是新增的字段，设置InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据目录</span><br></pre></td></tr></table></figure></p><p>mysql安装完毕之后，我们还要导表进去，如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br><span class="line">mysqladmin -uroot password <span class="string">'123456'</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">'create database zabbix_proxy character set utf8;'</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">"grant all privileges on zabbix_proxy.* to zabbix@localhost identified by 'zabbix';"</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">"flush privileges;"</span></span><br><span class="line">mysql -uzabbix -pzabbix zabbix_proxy &lt;<span class="regexp">/解压路径/</span>zabbix<span class="number">-3.0</span><span class="number">.8</span>/database/mysql/schema.sql</span><br></pre></td></tr></table></figure></p><p>至此，mysql部分已经全部搞定。</p><h1><span id="安装zabbix-proxy">安装Zabbix-proxy</span></h1><p>先去<code>https://sourceforge.net/projects/zabbix/files/ZABBIX%20Latest%20Stable/3.0.8/</code>下载<code>zabbix-3.0.8.tar.gz</code>，上传到proxy服务器里。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zabbix<span class="number">-3.0</span><span class="number">.8</span>.tar.gz</span><br><span class="line">./configure --prefix=<span class="regexp">/usr/</span>local/zabbix<span class="number">-3.0</span><span class="number">.8</span>  --sysconfdir=<span class="regexp">/etc/</span>zabbix  --enable-proxy  --enable-agent  --enable-ipv6  --<span class="keyword">with</span>-mysql=<span class="regexp">/usr/</span>bin/mysql_config  --<span class="keyword">with</span>-net-snmp  --<span class="keyword">with</span>-libcurl  --<span class="keyword">with</span>-openipmi  --<span class="keyword">with</span>-unixodbc  --<span class="keyword">with</span>-ldap  --<span class="keyword">with</span>-ssh2  --enable-java</span><br></pre></td></tr></table></figure></p><p>如果出现了<code>configure: error: Invalid LDAP directory - unable to find ldap.h</code>，解决方法就是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install openldap*</span><br></pre></td></tr></table></figure></p><h1><span id="zabbix-proxy的配置">Zabbix-proxy的配置</span></h1><p>打开<code>/etc/zabbix/zabbix_proxy.conf</code>，需要修改几个地方：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ProxyMode=0                                   #0是主动模式，1是被动模式</span><br><span class="line">Server=A.B.C.D                #这里填写zabbix-server的内网IP</span><br><span class="line">Hostname=J.Q.K.A              #这里要与/etc/hosts下的名字一模一样</span><br><span class="line">LogFile=<span class="regexp">/tmp/</span>zabbix_proxy.log</span><br><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbix_proxy</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix</span><br><span class="line">ConfigFrequency=120              #主动去server端去拉去配置更新的频率120秒一次</span><br><span class="line">DataSenderFrequency=60              #发送采集的监控数据到服务器端，默认是1秒，我们一分钟发送一次</span><br><span class="line">#ProxyLocalBuffer=0                #ProxyLocalBuffer表示数据传递给server之后还要在proxy里保存多久（单位为小时）。如果注释就是代表不删除。</span><br><span class="line">#ProxyOfflineBuffer=1               #ProxyOfflineBuffer表示数据没有传递给server的话还要在proxy里保存多久（单位为小时）。如果注释就是代表不删除。</span><br></pre></td></tr></table></figure></p><p>然后就是启动proxy:<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/zabbix_proxy/sbin/zabbix_proxy</span><br></pre></td></tr></table></figure></p><p>用netstat查看一下端口和进程是否都OK：<br><img src="/images/proxy3.png" alt=""></p><h1><span id="zabbix-server端的配置">Zabbix-server端的配置</span></h1><p>登入zabbix-server的网页，如图添加proxy：<br><img src="/images/proxy4.png" alt=""></p><p>点击“create proxy”之后，就对应填写资料吧：<br><img src="/images/proxy5.png" alt=""></p><p><img src="/images/proxy6.png" alt=""></p><p>这里对上面的几个选项多说几句：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connections to proxy：服务器如何连接到被动代理：无加密（默认），使用PSK（预共享密钥）或证书。</span><br><span class="line">Connections <span class="keyword">from</span> proxy：从活动代理中选择允许的连接类型。 可以同时选择几种连接类型（用于测试和切换到其他连接类型）。 默认为“无加密”。</span><br><span class="line">#点击Certificate之后又两个参数：</span><br><span class="line">Issuer：允许颁发证书。 证书首先通过CA（认证机构）验证。 如果CA有效，则由CA签名，则可以使用Issuer字段来进一步限制允许的CA。 该字段是可选的，如果您的Zabbix安装使用多个CA的证书，则使用该字段。</span><br><span class="line">Subject：允许的证书。 证书首先通过CA验证。 如果它有效，由CA签名，则主题字段可用于仅允许Subject字符串的一个值。 如果此字段为空，则接受由配置的CA签名的任何有效证书。</span><br><span class="line">#点击PSK之后又两个参数：</span><br><span class="line">PSK identity：预共享密钥身份字符串。</span><br><span class="line">PSK ： 预共享密钥（hex-string）。 如果Zabbix使用mbed TLS（PolarSSL）库，Zabbix将使用GnuTLS或OpenSSL库，<span class="number">64</span>位十六进制（<span class="number">32</span>字节PSK），最大长度为<span class="number">512</span>位十六进制数（<span class="number">256</span>字节PSK）。 示例：<span class="number">1</span>f87b595725ac58dd977beef14b97461a7c1045b9a1c963065002c5473194952</span><br></pre></td></tr></table></figure></p><p>保存之后，就在zabbix-server用<code>zabbix-get</code>去ping一下proxy，看看返回值是否是1，如果是<code>zabbix_get [18290]: Check access restrictions in Zabbix agent configuration</code>，就检查一下刚才的hostname等值是否正确。<br><img src="/images/proxy7.png" alt=""></p><h1><span id="被监控机器的配置">被监控机器的配置</span></h1><p>在被监控的阿里云redis里安装<code>zabbix-agent</code>，在<code>agentd.conf</code>里把<code>hostname</code>写成自己在<code>/etc/hosts</code>里的<code>hostname</code>，<code>Server</code>地址和<code>ServerActive</code>的地址都要写成proxy的外网IP地址。保存之后启动agent进程，这个时候在proxy端是可以通过<code>zabbix_get</code>得到这台被监控机器的值，如图：<br><img src="/images/proxy8.png" alt=""></p><p>在Zabbix-Server的WEB界面里，为阿里云的redis新建一个host，<code>Agent interface</code>那里填写被监控的机器IP，端口是10050，<code>Monitored by proxy</code>的地方要写成刚刚添加的proxy。如图：<br><img src="/images/proxy9.png" alt=""></p><p>上面已经提到过，用proxy模式并且zabbix的客户端也是主动模式提交数据，这样能大大提高采集效率，降低zabbix服务器端和proxy端的压力。现在我们希望添加的还是使用zabbix_agent的方式，新加到zabbix_proxy里面的主机使用<code>zabbix_agent（active）</code>的方式。注意在模板的克隆要选择<code>full clone</code>，不要选“clone”，那样的话就仅仅是把iterm的名字克隆过去而已，如图：<br><img src="/images/proxy10.png" alt=""></p><p>然后在items选择具体的类型，根据需要，想改那个改哪个，如图，注意！我图里写的是<code>Zabbix agent</code>，但是type这里选择<code>Zabbix agent (active)</code>。<br><img src="/images/proxy11.png" alt=""></p><p>改完之后，保存一下，就会看到type都是<code>zabbix agent（active）</code>了。<br><img src="/images/proxy12.png" alt=""></p><p>最后在host里把这个机器添加到proxy的模板里，如图：<br><img src="/images/proxy13.png" alt=""></p><p>在Administration的Proxies也看到效果了，如果server与proxy没有正确连接的话，last seen的地方会是<code>--</code>，如果连接的话就会显示具体时间，如图:<br><img src="/images/proxy15.png" alt=""></p><p>返回到hosts里，查看那个被监控的redis机器也成功被监控到了，<code>ZBX</code>已经变绿。如图：<br><img src="/images/proxy14.png" alt=""></p><p>因为我们线上环境基本都是用的zabbix_proxy方式是active方式，然后客户端也是active方式，既然都是active方式，那么zabbix_agent的Hostname就很重要，打个比方如果再zabbix_server端把一个主机的Hostname改了，然后客户端那边也改了，服务端和客户端的Hostname是统一的，但是proxy那里还记录的是旧Hostname，然后就会在proxy日志里面看到下面一条：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot send list <span class="keyword">of</span> active checks to <span class="string">"proxy内网IP地址"</span>: host [virt_proxy内网IP地址] not found</span><br></pre></td></tr></table></figure></p><p>proxy主动模式下，<code>ConfigFrequency</code>默认的是3600秒一小时，显然有点大了，可以适当的调低一下，如10分钟或者几分钟什么的。然后出现问题多看看zabbix服务端和proxy的日志，对症下药。</p><h1><span id="参考资料">参考资料</span></h1><p><a href="http://www.51niux.com/?id=156" target="_blank" rel="noopener">http://www.51niux.com/?id=156</a><br><a href="http://www.cnblogs.com/wangxiaoqiangs/p/5336630.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangxiaoqiangs/p/5336630.html</a></p>]]></content>
    
    <summary type="html">
    
      把监控的手伸的再长一点...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="监控技术" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器更改时区为utc</title>
    <link href="http://yoursite.com/2018/01/25/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E6%94%B9%E6%97%B6%E5%8C%BA%E4%B8%BAutc/"/>
    <id>http://yoursite.com/2018/01/25/阿里云服务器更改时区为utc/</id>
    <published>2018-01-25T14:31:16.000Z</published>
    <updated>2018-01-26T06:55:58.895Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>开发提出需求说，某个模块是给洋人使用，于是把服务器里的时间改成UTC时间。我登陆到服务器里使用<code>date</code>查看了一下，发现目前使用的是东八区时间，如图：<br><img src="/images/time1.png" alt="goodbye,Kobe"></p><p>首先先开启UTC，方法就是在<code>/etc/sysconfig/clock</code>的文件里修改这样一处：<code>UTC=true</code>。这样即使机器重启，UTC时间依旧会“<code>BIOS ▶ UTC时区转换 ▶ 系统时间</code>”的顺序正常使用。</p><p>在Centos 6.5里，各时区的时间是在一个叫<code>/usr/share/zoneinfo/</code>的文件夹下，在里面我们发现了我们的目标—-<code>UTC</code>，如图：<br><img src="/images/time2.png" alt="goodbye,Kobe"></p><p>然后就是修改，方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/localtime /etc/localtime-bak</span><br><span class="line">ln -s /usr/share/zoneinfo/UTC /etc/localtime</span><br></pre></td></tr></table></figure></p><p>先把老的时间文件备份，然后把UTC文件做一个软连接过来即可。我们所熟悉的<code>date</code>命令就是<code>/etc/localtime</code>的输出结果。</p><p>现在去<code>date</code>一下，看看结果，果然改成了<code>UTC</code>：<br><img src="/images/time3.png" alt="goodbye,Kobe"></p><p>这个时候，如果你服务器里装的是nginx的话，就会发现nginx日志里的时间也会变成<code>UTC</code>而不会再是<code>CST</code>了。</p>]]></content>
    
    <summary type="html">
    
      为美国人服务的模块就要改成美国时间
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>阿里云购买、启动、停止ecs等等操作的python脚本</title>
    <link href="http://yoursite.com/2018/01/24/%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%AD%E4%B9%B0%E3%80%81%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2ecs%E7%9A%84python%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/01/24/阿里云购买、启动、停止ecs的python脚本/</id>
    <published>2018-01-24T14:52:41.000Z</published>
    <updated>2018-01-25T04:47:44.335Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>以下所有脚本都是在python 2.7的环境亲自测试的。<br>阿里云的ak/sk是没有地域概念的，在任何地域都可以使用。</p><h2><span id="购买服务器">购买服务器</span></h2><p>以在新加坡购买服务器为例子：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#注意！服务器创建完毕之后，状态是关机的。</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> CreateInstanceRequest</span><br><span class="line"># 创建 Client 实例</span><br><span class="line">clt = client.AcsClient('阿里云ak','阿里云sk','新加坡的地域')#各地域的缩写请看：https://help.aliyun.com/document_detail/40654.html?spm=5176.doc25499.2.14.yh6n8c</span><br><span class="line"></span><br><span class="line"># 创建 request，并设置参数</span><br><span class="line">request = CreateInstanceRequest.CreateInstanceRequest()</span><br><span class="line"></span><br><span class="line"># 设置ECS细节</span><br><span class="line">request.set_ImageId("centos_7_04_64_20G_alibase_201701015.vhd")#这里是镜像</span><br><span class="line">request.set_InstanceName("xjp-test-001")#这里写名称</span><br><span class="line">request.set_SecurityGroupId("sg-23t6c6mjw")#这里是安全组</span><br><span class="line">request.set_Password("W2.bi7FX1dyb)T3Wh^,[")#这里是密码，推荐使用https传输，安全</span><br><span class="line">request.set_InstanceChargeType("PrePaid")#确定是包年包月</span><br><span class="line">request.set_Period("2")#先买两个月的</span><br><span class="line">request.set_SystemDiskCategory("cloud_efficiency")#注意，如果是海外的机器的话，要额外说明，海外的机器只有高速云盘和SSD盘</span><br><span class="line"></span><br><span class="line"># 设置实例规格</span><br><span class="line">request.set_InstanceType(<span class="string">"ecs.s2.large"</span>)</span><br><span class="line"></span><br><span class="line"># 发起 API 请求并打印返回</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></p><h2><span id="服务器停机">服务器停机</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> StopInstanceRequest</span><br><span class="line">list1 = [<span class="string">'要停机的ecs id1'</span>,<span class="string">'要停机的ecs id2'</span>,<span class="string">'要停机的ecs id3'</span>...]</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云ak'</span>,<span class="string">'阿里云sk'</span>,<span class="string">'地域名'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">       shutdown = StopInstanceRequest.StopInstanceRequest()</span><br><span class="line">       shutdown.set_InstanceId(i)</span><br><span class="line">       action = clt.do_action_with_exception(shutdown)</span><br><span class="line">       print <span class="string">"现在停机:"</span> + i</span><br><span class="line">       print action</span><br></pre></td></tr></table></figure></code></pre><h2><span id="服务器启动">服务器启动</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> StartInstanceRequest</span><br><span class="line">list = [<span class="string">'要停机的ecs id1'</span>,<span class="string">'要停机的ecs id2'</span>,<span class="string">'要停机的ecs id3'</span>...]</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云ak'</span>,<span class="string">'阿里云sk'</span>,<span class="string">'地域名'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">       start = StartInstanceRequest.StartInstanceRequest()</span><br><span class="line">       start.set_InstanceId(i)</span><br><span class="line">       action = clt.do_action_with_exception(start)</span><br><span class="line">       print <span class="string">"现在启动:"</span> + i</span><br><span class="line">       print action</span><br></pre></td></tr></table></figure></code></pre><h2><span id="查询阿里云镜像">查询阿里云镜像</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> DescribeImagesRequest</span><br><span class="line"><span class="keyword">import</span> aliyunsdkcore.request</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云ak'</span>,<span class="string">'阿里云sk'</span>,<span class="string">'地域名'</span>)</span><br><span class="line"></span><br><span class="line">request = DescribeImagesRequest.DescribeImagesRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></code></pre><h2><span id="查询服务器规格">查询服务器规格</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> DescribeInstanceTypesRequest</span><br><span class="line"><span class="keyword">import</span> aliyunsdkcore.request</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云ak'</span>,<span class="string">'阿里云sk'</span>,<span class="string">'地域名'</span>)</span><br><span class="line"></span><br><span class="line">request = DescribeInstanceTypesRequest.DescribeInstanceTypesRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></code></pre><h2><span id="参考资料">参考资料</span></h2><p><a href="https://help.aliyun.com/document_detail/25499.html?spm=5176.doc25501.6.857.wR0MHP" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/25499.html?spm=5176.doc25501.6.857.wR0MHP</a></p><p><img src="/images/xiaomage.jpg" alt="小马哥" title="GOOD LUCK AND THANK U,Masche."></p>]]></content>
    
    <summary type="html">
    
      有了这些脚本，七拼八凑的就可以写出来一个批量购买服务器的脚本了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="阿里云api" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91api/"/>
    
  </entry>
  
  <entry>
    <title>Crontab里解决脚本时间重叠的问题</title>
    <link href="http://yoursite.com/2018/01/24/Crontab%E9%87%8C%E8%A7%A3%E5%86%B3%E8%84%9A%E6%9C%AC%E6%97%B6%E9%97%B4%E9%87%8D%E5%8F%A0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/24/Crontab里解决脚本时间重叠的问题/</id>
    <published>2018-01-24T06:17:32.000Z</published>
    <updated>2018-01-24T06:26:57.148Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>Linux里的Crontab是一个好东西，但是它的默认最小执行频率是1分钟，但是我们在实际生产环境里有的时候遇到的脚本执行时间是大于1分钟的，这样就会出现一个很尴尬的情况，就是在1分钟过后，系统进程会出现多个脚本，neck and neck式的在后台运行，比如这样：<br><img src="/images/log499.png" alt="akb48"></p><p>从上面的图可以看到，10点36分<code>log499.sh</code>没有执行完毕，10点37又开始了执行了一个新的<code>log499.sh</code>脚本。这种脚本冲突肯定不是我们所希望的，那么如何才能保证后台只是在一段时间里只执行一个脚本呢？</p><p>这个时候我们就要使用文件锁，<code>flock</code>，这种方法要比判断pid高大上的多。</p><p>首先假设我们的脚本名字叫abc.sh，这个脚本文件的执行时间是要大于1分钟的，同时我们再设定一个锁文件，位置就叫<code>/tmp/abc.lock</code>,这个文件可以是空的，然后<code>crontab -e</code>，添加一句命令如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * flock -xn /tmp/abc.lock -c <span class="string">'sh /路径/abc.sh &gt;&gt; /记录日志的路径 2&gt;&amp;1'</span></span><br></pre></td></tr></table></figure></p><p>这个时候静候crontab启动abc.sh，通过<code>ps -ef|grep abc</code>，发现在后台始终只有一个abc进程。</p><p>但是有的时候会有这样的一个问题，就是abc执行一次之后，在下一次该执行的时候却没有执行，好像crontab失效了一样，对于这样的情况，就需要添加下面的语句到abc.sh末尾：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/abc.lock      #删除掉原有的锁文件</span><br><span class="line">sleep n                      #睡n秒</span><br><span class="line">touch /tmp/abc.lock     #再新建一个锁文件</span><br></pre></td></tr></table></figure></p><p>这样不断地更新lock锁文件，就会保证crontab每次都会按期执行。</p><p>这里要注意一下，里面我加了一句<code>sleep n</code>，这里的n是为了跨分钟的存在，这是为了防止没有走到下一个分钟又会生成一个新的lock锁文件，这样还是会出现重复启动脚本的情况。</p><p>这里就涉及到flock的一个原理：<strong>在每一次执行任务的时候都会先去尝试取到锁文件，如果取到了锁文件，那么就会下一步，反之就会放弃执行</strong>。A任务在运行的时候已经占据了lock文件，那么B任务来了，发现没有lock了，就不会执行任务。</p><p>这里我们使用了flock的三个参数：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-x, --exclusive: 获得一个独占锁</span><br><span class="line">-n, --nonblock:  如果没有立即获得锁，直接失败而不是等待</span><br><span class="line">-c, --command:   在shell中运行一个单独的命令</span><br></pre></td></tr></table></figure></p><p>当然，flock还是有很多丰富的参数可以供各位使用，大家就各自去google一下吧。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.csdn.net/fdipzone/article/details/38284009" target="_blank" rel="noopener">http://blog.csdn.net/fdipzone/article/details/38284009</a><br><a href="http://chuansong.me/n/285635151949" target="_blank" rel="noopener">http://chuansong.me/n/285635151949</a><br><a href="https://segmentfault.com/q/1010000008039907" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008039907</a></p>]]></content>
    
    <summary type="html">
    
      话说那是一个年久失修的模块，现在只能靠这种每分钟监控的脚本来残喘续命了...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="crontab" scheme="http://yoursite.com/tags/crontab/"/>
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>yum提示Error: rpmdb open failed</title>
    <link href="http://yoursite.com/2018/01/24/yum%E6%8F%90%E7%A4%BAError-rpmdb-open-failed/"/>
    <id>http://yoursite.com/2018/01/24/yum提示Error-rpmdb-open-failed/</id>
    <published>2018-01-24T06:09:35.000Z</published>
    <updated>2018-01-25T09:35:20.166Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在一台机器里，使用<code>yum</code>安装的时候，出现了如下的故障：<br><img src="/images/yum1.png" alt="akb48"></p><p>这种情况就是RPM数据库被破坏了，这个时候就需要我们重建数据库，于是就输入如下的命令：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd / <span class="keyword">var</span> / lib / rpm /</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">` ls | grep 'db.' `</span> ; <span class="keyword">do</span> mv $i $i .bak ; done</span><br><span class="line">rpm -- rebuilddb</span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure></p><p>重新<code>cleanup</code>就正常了。</p>]]></content>
    
    <summary type="html">
    
      解决yum的小故障
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="yum" scheme="http://yoursite.com/tags/yum/"/>
    
  </entry>
  
</feed>

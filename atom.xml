<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-31T09:16:19.120Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈raid0,raid1,raid10,raid01等等硬盘阵列搭配</title>
    <link href="http://yoursite.com/2018/01/31/%E7%AE%80%E6%9E%90raid0-raid1-raid10-raid01%E7%AD%89%E7%AD%89%E7%A1%AC%E7%9B%98%E6%90%AD%E9%85%8D/"/>
    <id>http://yoursite.com/2018/01/31/简析raid0-raid1-raid10-raid01等等硬盘搭配/</id>
    <published>2018-01-31T06:43:03.000Z</published>
    <updated>2018-01-31T09:16:19.120Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="raid-0分条">RAID 0(分条)</span></h2><p>RAID 0（也称为分条）可用于两个或更多硬盘或SSD。目标是提高读的性能。</p><p>数据以特定大小（通常为64KB）的块写入，并在可用驱动器中平均分配。下图显示了带有三个硬盘的RAID 0阵列的示意图。RAID控制器将第一个数据块写入硬盘1，第二个数据块写入硬盘2，第三个数据块写入硬盘3，第四个数据块写入硬盘1,以此类推，RAID 0中的三个1TB硬盘提供3TB的存储空间。<br><img src="/images/raid1.png" alt="paradin"></p><p>由于数据分布均匀，所以在访问的时候会从硬盘1~硬盘4提取数据，然后拼接在一起就是一个完整的数据。理论上从四个硬盘的RAID 0阵列读取数据比从一个硬盘读取要快四倍，换言之，使用RAID 0读的能力跟磁盘数量成正比。</p><p>RAID 0也有缺点。如果一个磁盘出现故障，从其他磁盘上的数据拼起来就不再是一个完整的数据了。另外，磁盘越多，则发生磁盘故障的可能性也越高。所以如果数组包含对您来说很重要的数据，则最好创建频繁的备份。</p><h2><span id="raid-1镜像">RAID 1(镜像)</span></h2><p>RAID 1（也称为镜像）用于创建数据的自动副本。RAID 1会将数据写入两个单独的磁盘，如果A盘出现故障，您仍然可以在B磁盘上使用所有数据，当然这是比较壕的，毕竟做一件事用了两块盘。这里要注意！<font color="red">镜像和备份可不是一样！！！如果你不小心从一个磁盘上删除了一个文件，或者某个文件被病毒侵蚀了，那它再另一个磁盘上也是一样的待遇。只有真正的备份才能使所有文件保持其保存状态。</font>因此，如果您想为您的数据创造最好的机会来挽救灾难，那么您应该使用RAID 1，RAID 10或RAID 5，并创建频繁的备份。</p><p>RAID 1中的性能通常与单独的硬盘或SSD相同。因此，您不要使用RAID 1来获得额外的读写性能，而是要获得所有文件的额外副本。以下是RAID 1的工作原理图，如果HDD1坏了，那么HDD2直接上任，若HDD1里的东西被删除了，那么HDD2也会被删除，即使它上任了也是坏的。<br><img src="/images/raid2.png" alt="paradin"></p><h2><span id="raid-10和raid-01">RAID 10和RAID 01</span></h2><p>所谓RAID 10,其实就是<code>先RAID 1,后RAID 0</code>,同理，RAID 01也是先<code>RAID 0,后RAID 1</code>。无论是1+0还是0+1，都至少需要4个硬盘。</p><p>这里先看一下RAID 10和RAID 01的效果图：<br><img src="/images/raid3.png" alt="paradin"></p><p>就像图里说的“在六个硬盘列里，RAID 10比RAID 01更安全”，而且RAID 10也是大多数的RAID配置，为什么呢？那就是如果在RAID 0那一步磁盘就坏了，那RAID 1就没有意义了，因为生成的镜像全是坏镜像。</p><h2><span id="raid-3">RAID 3</span></h2><p>RAID 3是这样的：若你有n块盘，其中1块盘作为校验盘，剩余n-1块盘相当于作RAID 0同时读写，当其中一块盘坏掉时，可以通过校验码还原出坏掉盘的原始数据。这个校验方式比较特别，奇偶检验，1 XOR 0 XOR 1=0，0 XOR 1 XOR 0=1，最后的数据时校验数据，当中间缺了一个数据时，可以通过其他盘的数据和校验数据推算出来。但是这有个问题，由于n-1块盘做了RAID 0，每一次读写都要牵动所有盘来为它服务，而且万一校验盘坏掉就完蛋了。</p><h2><span id="raid-5-and-6">RAID 5 and 6</span></h2><p>RAID 10是一个很棒的方案，但是它的实现至少需要4个硬盘，这一点太伤钱了，于是就出现了RAID 5，与RAID 0一样，数据被分成块并执行写入处理，同时把RAID 3的“校验盘”也分成块分散到所有的盘里。同时，产生并写入称为“奇偶校验”的冗余代码。因此，即使构成其中的一个硬盘出现故障，您也可以根据剩余的数据和奇偶校验计算丢失的数据，并生成完整的状态数据。由于无论需要配置多少个硬盘，保存校验只使用一台设备的容量，容量效率随着待配置硬盘数量的增加而提高。<font color="red">读取数据的速度很快，因为它是从多个驱动器同时处理的</font>。预计速度将与要配置的驱动器的数量成比例地增加。但是，数据的写入/更新涉及奇偶校验的创建/更新，所以<font color="red">写入性能不高</font>。</p><p>RAID5已经提供了一定程度的可靠性,然而也牺牲了一定的读取速度。RAID5的局限性还表现在RAID5仅能在一块硬盘发生故障的情况下修复数据,如果2块硬盘同时发生故障,RAID5则无能为力。于是RAID6应需诞生了，RAID6同RAID5最大的区别就是在RAID5的基础上除了具有P校验位以外,还加入了第2个校验位Q位。当一块磁盘出现数据错误或者丢失的时候,恢复方法同RAID5,无须使用Q校验位。当两块磁盘上的数据出现错误或者丢失的时候,恢复方法为:利用上边给出的P,Q的生成公式,联立方程组,无论受损的数据是否包括P或者Q,总是能够解出损失的两位的数据。</p><h2><span id="raid-50-and-60">RAID 50 and 60</span></h2><p>在硬盘数量较少的情况下，RAID5是极好的选择，如7-8块硬盘组成的RAID。但是，当硬盘的数量更多的时候，如10块、20块甚至100块，那么RAID5就无法胜任了。RAID50是在RAID5的基础上，将多个RAID5组以RAID0的形式组成在一起。可以这么认为，一个RAID5组在这里就是一个“大硬盘”，再把这些“大硬盘”以RAID0的形式组成在一起。而RAID60的组成就是在RAID6组的上面组成一个RAID0。理论上说在写入性能方面，RAID50相比RAID5要好太多，而RAID50相比性能冠军RAID10要差一点，考虑到RAID5在一些负载面前的平庸性能，RAID50是个不错的中间选择。和RAID5和RAID10一样，RAID50也提供极好的读性能。</p><p>如果担心一个RAID组里面同时有2块硬盘发生故障，导致数据丢失，那么可以选择使用RAID60。RAID60提供更高的安全性，相应的其可用容量会比RAID50少点。</p><p>结语<br>如果你对这篇文章记得不是很清晰了，那么但愿你可以记住这样图，这幅图虽然不是很准确，但是已经很大的表达清楚了各种RAID的特点了。<br><img src="/images/raid4.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://us.hardware.info/reviews/4123/raid-0-raid-1-raid-10-and-raid-5-how-do-they-actually-work" target="_blank" rel="noopener">https://us.hardware.info/reviews/4123/raid-0-raid-1-raid-10-and-raid-5-how-do-they-actually-work</a><br><a href="http://support.huawei.com/enterprise/zh/knowledge/KB1000149118/" target="_blank" rel="noopener">http://support.huawei.com/enterprise/zh/knowledge/KB1000149118/</a><br><a href="https://zh.wikipedia.org/wiki/RAID" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/RAID</a></p>]]></content>
    
    <summary type="html">
    
      磁盘阵列这个东西，有钱就有安全
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="raid" scheme="http://yoursite.com/tags/raid/"/>
    
      <category term="磁盘阵列" scheme="http://yoursite.com/tags/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Ansible-playbook如何获取ip</title>
    <link href="http://yoursite.com/2018/01/31/Ansible-playbook%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96ip/"/>
    <id>http://yoursite.com/2018/01/31/Ansible-playbook如何获取ip/</id>
    <published>2018-01-31T05:54:08.000Z</published>
    <updated>2018-01-31T06:21:34.530Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>公司的模块都新加了加密算法，现在就是需要把约100台机器的<code>/etc/hosts</code>文件里的zookeeper server的ip调整成新的ip 地址，目前在ansible控制机上已经写好了带有新的zookeeper server的ip的<code>/etc/hosts</code>文件，然后计划是把这个新文件下发到大约100台具体模块的服务器里，然后这100台机器的文件中把他们各自的ip和hostname添加到这个新的<code>/etc/hosts</code>文件上。</p><p>于是就写了一个ansible-playbook:<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: all</span><br><span class="line">  tasks:</span><br><span class="line">        - name: 将原有的hosts文件备份</span><br><span class="line">          shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">        - name: 将ansible端的hosts复制到各自机器上</span><br><span class="line">          copy: src=<span class="regexp">/root/</span>hosts dest=<span class="regexp">/etc/</span> owner=root group=root mode=<span class="number">0544</span></span><br><span class="line"></span><br><span class="line">        - name: 在新的hosts文件后面追加各自机器内网ip和hostname</span><br><span class="line">          lineinfile: dest=<span class="regexp">/etc/</span>hosts line=<span class="string">"`ansible_all_ipv4_addresses`  `ansible_hostname`"</span></span><br></pre></td></tr></table></figure></p><p>但是写完之后执行出来，却是这样的效果：<br><img src="/images/ansibleip.png" alt="akb48"></p><p>而我想要的是这样的效果：<br><img src="/images/ansibleip2.png" alt="akb48"></p><p>遇到这种情况怎么办？</p><p>后来调整了一下，变量用<code>IP</code>: ““，而不是<code>ansible_all_ipv4_addresses</code>。</p><p>修改了之后的playbook 如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">- hosts: all</span><br><span class="line">  vars:</span><br><span class="line">        IP: <span class="string">"&#123;&#123; ansible_eth0['ipv4']['address'] &#125;&#125;"</span></span><br><span class="line">  tasks:</span><br><span class="line">        - name: 将原有的hosts文件备份</span><br><span class="line">          shell: mv /etc/hosts /etc/hosts_bak</span><br><span class="line"></span><br><span class="line">       - name: 将ansible端的hosts复制到各自机器上</span><br><span class="line">         copy: src=<span class="regexp">/root/</span>hosts dest=<span class="regexp">/etc/</span> owner=root group=root mode=<span class="number">0644</span></span><br><span class="line"></span><br><span class="line">        - name: 在新的hosts文件后面追加各自机器内网ip和hostname</span><br><span class="line">          lineinfile: dest=<span class="regexp">/etc/</span>hosts line=<span class="string">"`IP`  `ansible_hostname`"</span></span><br></pre></td></tr></table></figure></p><p>这样就达到目的了。</p>]]></content>
    
    <summary type="html">
    
      把每一项累手的任务都转换成累心
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>mysql查看实时语句和慢sql</title>
    <link href="http://yoursite.com/2018/01/30/mysql%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%85%A2sql/"/>
    <id>http://yoursite.com/2018/01/30/mysql查看实时语句和慢sql/</id>
    <published>2018-01-30T12:50:14.000Z</published>
    <updated>2018-01-30T13:40:03.228Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="查看实时语句">查看实时语句</span></h2><p>Mysql除了手动执行的语句，还有很多在后台由其他模块执行的语句，按理来说，那些由其他模块执行的语句是不能实时查看的，因为这个资源消耗特别的大，但是当我们实在需要查看实时sql语句的时候也不是做不到，需要手动开启一个日志开关<code>general_log</code>。</p><p>首先登陆mysql，然后执行<code>show variables like &quot;general_log%&quot;;</code>，看一下反馈的结果，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"general_log%"</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| general_log      | OFF   |</span><br><span class="line">| general_log_file |       |</span><br><span class="line">+------------------+-------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure></p><p>发现这个Value是<code>off</code>，那么就说明实时记录<code>general_log</code>没有开启，如果我们要开启它很简单，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global log_output = file;</span><br><span class="line">mysql&gt; set global general_log = <span class="string">'ON'</span>;</span><br><span class="line">mysql&gt; set global general_log_file = <span class="string">'/tmp/mysql/general_log.log'</span>;</span><br></pre></td></tr></table></figure></p><p>可见我们不仅打开了<code>general_log</code>的开关，而且设置日志输出方式为文件（如果设置<code>log_output=table</code>的话，则日志结果会记录到名为<code>gengera_log</code>的表中，这表的默认引擎都是<code>CSV</code>）。同时规定它的保存位置是<code>/tmp/mysql/general_log.log</code>。</p><p>但是这个是临时方法，如果mysql重启了那么就会失效，如果想要永久有效的话，就要编辑<code>my.cnf</code>，添加下面两句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">general_log = <span class="number">1</span></span><br><span class="line">general_log_file = <span class="regexp">/tmp/my</span>sql/general_sql.log</span><br></pre></td></tr></table></figure></p><p>这里要注意！<font color="red">开启general_log会影响性能，谨慎使用!正式系统用完要关闭!!!</font>关闭的语句<code>SET GLOBAL general_log = &#39;OFF&#39;;</code>。</p><h2><span id="查看慢sql">查看慢sql</span></h2><p>慢sql的意思就是那些执行很慢的sql，这些sql拖慢进程的执行效率而且有很大的优化空间。默认的来说，执行时间超过1秒就算慢sql了，在mysql里输入<code>show variables like &#39;long%&#39;</code>，就会看到如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'long%'</span>;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | <span class="number">1.000000</span> |</span><br><span class="line">+-----------------+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>这个<code>long_query_time</code>是可以更改的，这里是1，那就是代表查询时间大于(不是大于等于)1秒的都是记录到日志，最大值是10。如果写的是0，那么就是输出所有的语句。</p><p>这里多说一句，使用命令<code>set global long_query_time=4</code>修改慢查询阈值为4秒后，需要重新连接或新开一个会话才能看到修改值。你用<code>show variables like &#39;long_query_time&#39;</code>查看是当前会话的变量值，你也可以不用重新连接会话，而是用<code>show global variables like &#39;long_query_time&#39;;</code>。</p><p>那么记录这些慢日志的地方在哪呢？使用<code>show variables  like &#39;%slow_query_log%&#39;;</code>看看：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like <span class="string">'%slow_query_log%'</span>;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                           |</span><br><span class="line">| slow_query_log_file | <span class="regexp">/tmp/my</span>sql/DB-Server-slow.log   |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>这里说明慢日志的地址是<code>/tmp/mysql/DB-Server-slow.log</code>，但是慢日志记录的功能没有启动。如果要启动，语句是：<code>set global slow_query_log=1;</code>，跟上面开启实时日志<code>general_log</code>一样，这个方法仅仅是一个临时方法，重启了mysql就会失效，如果要长期生效，还是在<code>my.cnf</code>文件里添加如下两句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log =<span class="number">1</span></span><br><span class="line">slow_query_log_file=<span class="regexp">/tmp/my</span>sql/DB-Server-slow.log</span><br></pre></td></tr></table></figure></p><p>慢日志还有一个系统变量叫<code>log-queries-not-using-indexes</code>，它的意思是未使用索引的查询也被记录到慢查询日志中，哪怕他可能执行的非常快（可选项）。如果调优的话，建议开启这个选项。另外，开启了这个参数，其实使用<code>full index scan</code>的sql也会被记录到慢查询日志。如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'log_queries_not_using_indexes'</span>;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| log_queries_not_using_indexes | OFF   |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global log_queries_not_using_indexes=<span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>如果你想自己试试慢sql是否被记录，那么可以使用<code>select sleep(5);</code>这样的语句，执行效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(<span class="number">5</span>) ;</span><br><span class="line">+----------+</span><br><span class="line">| sleep(<span class="number">5</span>) |</span><br><span class="line">+----------+</span><br><span class="line">|        <span class="number">0</span> |</span><br><span class="line">+----------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">5.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> mysql.slow_log;</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| start_time          | user_host                 | query_time | lock_time | rows_sent | rows_examined | db | last_insert_id | insert_id | server_id | sql_text        | thread_id |</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| <span class="number">2018</span><span class="number">-01</span><span class="number">-30</span> <span class="number">21</span>:<span class="number">45</span>:<span class="number">23</span> | root[root] @ localhost [] | <span class="number">00</span>:<span class="number">00</span>:<span class="number">05</span>   | <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  |         <span class="number">1</span> |             <span class="number">0</span> |    |              <span class="number">0</span> |         <span class="number">0</span> |         <span class="number">1</span> | select sleep(<span class="number">5</span>) |         <span class="number">2</span> |</span><br><span class="line">+---------------------+---------------------------+------------+-----------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line"><span class="number">1</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.cnblogs.com/kerrycode/p/5593204.html" target="_blank" rel="noopener">http://www.cnblogs.com/kerrycode/p/5593204.html</a><br><a href="https://www.cnblogs.com/qmfsun/p/4844472.html" target="_blank" rel="noopener">https://www.cnblogs.com/qmfsun/p/4844472.html</a><br><a href="http://www.cnblogs.com/jasondan/p/3491258.html" target="_blank" rel="noopener">http://www.cnblogs.com/jasondan/p/3491258.html</a></p><p><img src="/images/curry3p.gif" alt="库里三分" title="神射手萌库"></p>]]></content>
    
    <summary type="html">
    
      这些都是在自己的mysql上使用的，云厂家的数据库就不要想了，需要在控制台查看。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Goaccess---良心nginx日志分析工具</title>
    <link href="http://yoursite.com/2018/01/30/Goaccess-%E8%89%AF%E5%BF%83nginx%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/01/30/Goaccess-良心nginx日志分析工具/</id>
    <published>2018-01-30T07:42:33.000Z</published>
    <updated>2018-01-30T07:53:27.531Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Goaccess是一个非常良心的开源软件，它的良心之处体现在如下方面：</p><ul><li>安装简单；</li><li>操作容易；</li><li>界面酷炫；</li></ul><h2><span id="安装">安装</span></h2><p>安装<code>Goaccess</code>十分的简单，在centos里直接<code>yum install goaccess</code>，如果yum源里没有<code>goaccess</code>，可以先安装<code>epel</code>。安装<code>epel</code>的方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></span><br><span class="line">wget http:<span class="comment">//rpms.famillecollet.com/enterprise/remi-release-6.rpm</span></span><br><span class="line">rpm -Uvh remi-release<span class="number">-6</span>*.rpm epel-release<span class="number">-6</span>*.rpm</span><br></pre></td></tr></table></figure></p><h2><span id="配置和使用">配置和使用</span></h2><p>安装完<code>goaccess</code>之后，我们需要在<code>/etc/goaccess.conf</code>里添加如下几句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time-format %T</span><br><span class="line">date-format %d/%b/%Y</span><br><span class="line">log-format %h %^[%d:%t %^] “%r” %s %b “%R” “%u”</span><br></pre></td></tr></table></figure></p><p>保存退出之后，我们就可以通过<code>goaccess</code>来分析<code>nginx</code>日志了，语句格式也很简单：<code>goaccess -f nginx日志的绝对路径</code>。比如我的nginx日志是<code>access-chen.log</code>，查看一下里面的内容：<br><img src="/images/goaccess1.png" alt="goaccess"></p><p>虽然有规律，但是看上去很乱，需要在分析日志之前喝两瓶静心口服液。</p><p>然后我就<code>goaccess -f access-chen.log</code>，就会看到如下的界面：<br><img src="/images/goaccess2.png" alt="goaccess"></p><p>这一下，整个日志看起来更加友好，更加直白，更加高大上。足以吸引周围人的羡慕目光。</p><p>但是这里面还是有一个注意点：<code>goaccess</code>默认支持的日志格式是<code>nginx</code>默认的日志格式，也就是nginx.conf里的如下格式：<br><img src="/images/goaccess3.png" alt="goaccess"></p><p>如果你的日志格式是有过更改的，而且还不想改回来，那么就需要去<code>/etc/goaccess.conf</code>里对应的<code>log-format</code>进行更改。</p><p>这还没有完，goaccess还可以生成html，这里<code>goaccess -f access-chen.log  -a &gt; /nginx安装路径/html/chen.html</code>。然后在浏览器里登陆到这个服务器的chen.html，就会看到整个日志情况的网页排版，如图：<br><img src="/images/goaccess4.png" alt="goaccess"></p><p>这样的话，我们可以每一天都发一份当天的日志html去运维人员的信箱里，这样更加方便我们分析日志。</p><h2><span id="缺点">缺点</span></h2><p>虽然前面说了那么多goaccess的优点，但是缺点也是有的，比如<code>goaccess</code>的粒度太粗，只能按天分割，如果要按小时分割，需要先<code>grep</code>出来，这个做法比较挫我懂…</p><p>还有一个缺点，就是访问人的来源只能定位到国家，无法具体定位到省市县村屯…<br><img src="/images/goaccess5.png" alt="goaccess"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.maxhemby.se/determine-the-apache-traffic-load/#respond" target="_blank" rel="noopener">http://blog.maxhemby.se/determine-the-apache-traffic-load/#respond</a></p>]]></content>
    
    <summary type="html">
    
      面试的时候一定会被面到的问题是：给出web服务器的访问日志，请写一个脚本来统计访问前10的IP有哪些？访问前10的请求有哪些？当你领略过goaccess之后，你就明白，这些问题，除了考验你的脚本背诵记忆能力以外，唯一的作用只有装A或者装C了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="日志统计" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>处理掉积压过多的activemq持久化消息</title>
    <link href="http://yoursite.com/2018/01/29/%E5%A4%84%E7%90%86%E6%8E%89%E7%A7%AF%E5%8E%8B%E8%BF%87%E5%A4%9A%E7%9A%84activemq%E6%8C%81%E4%B9%85%E5%8C%96%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/01/29/处理掉积压过多的activemq持久化消息/</id>
    <published>2018-01-29T06:27:26.000Z</published>
    <updated>2018-01-31T06:03:32.033Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="问题描述">问题描述</span></h2><p>在项目使用<code>activemq 5.14</code>时，客户端发送消息而没有得到回复（在不考虑消费者是什么问题的情况下），导致持久化消息不断积压而得不到释放，最后造成队列堵塞而嗝屁。</p><p>一般来说遇到这样的情况，可以在配置文件中配置消息的过期时间和死信处理来防止消息的积压，配置如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">       &lt;!-- <span class="number">86</span>,<span class="number">400</span>,<span class="number">000</span>ms = <span class="number">1</span> day --&gt;</span><br><span class="line">         &lt;timeStampingBrokerPlugin ttlCeiling=<span class="string">"10000"</span> zeroExpirationOverride=<span class="string">"10000"</span>/&gt;</span><br><span class="line">     &lt;<span class="regexp">/plugins&gt;</span></span><br></pre></td></tr></table></figure></p><p>配置消息过期时间使用<code>timeStampingBrokerPlugin</code>插件,<code>ttlCeiling</code>：表示过期时间上限（模块程序写的过期时间不能超过此时间，超过则以此时间为准），<code>zeroExpirationOverride</code>：表示过期时间（给未分配过期时间的消息分配过期时间），一般来说这两个值是一样的。执行之后，message过期则客户端不能接收，那些已经过期的message将会保存在<code>data/kahadb</code>目录下。</p><p>但是最近发现了一个问题，就是<code>data/kahadb</code>这个目录最近越来越大，越积越多。但是这个topic和quere又依旧是“持续订阅”的，它的消费者还在。遇到这样的情况，如何在activemq里配置呢？</p><h2><span id="解决办法">解决办法</span></h2><ul><li><p>配置message过期自动丢弃策略</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;borker&gt;</span><br><span class="line">   &lt;destinationPolicy&gt;</span><br><span class="line">       &lt;policyMap&gt;</span><br><span class="line">           &lt;policyEntries&gt;</span><br><span class="line">               &lt;policyEntry topic=<span class="string">"&gt;"</span> expireMessagesPeriod=<span class="string">"60000"</span>&gt;</span><br><span class="line">                   &lt;deadLetterStrategy&gt;</span><br><span class="line">                        &lt;sharedDeadLetterStrategy processExpired=<span class="string">"false"</span> /&gt;</span><br><span class="line">                   &lt;<span class="regexp">/deadLetterStrategy&gt;</span></span><br><span class="line"><span class="regexp">               &lt;/</span>policyEntry&gt;</span><br><span class="line">           &lt;<span class="regexp">/policyEntries&gt;</span></span><br><span class="line"><span class="regexp">       &lt;/</span>policyMap&gt;</span><br><span class="line">   &lt;<span class="regexp">/destinationPolicy&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>borker&gt;</span><br></pre></td></tr></table></figure></li></ul><p>标签<code>processExpired=&quot;false&quot;</code>表示<font color="red">不保存过期消息到死信队列，处理手段为删除</font>，为<code>true</code>则是保留。<br>标签<code>expireMessagesPeriod=&quot;60000&quot;</code>属性表示每隔60秒钟检查message是否过期。<br><code>topic=&quot;&gt;&quot;</code>表示该策略对所有topic都生效。而<code>topic=&quot;active.&gt;&quot;</code>就表示该策略对以<code>active.</code>开头的所有<code>topic</code>生效，注意有个点号<code>.</code>。</p><ul><li>message过期时间设置<br>上面那步搞定了之后，再修改<code>timeStampingBrokerPlugin</code>标签里<code>ttlCeiling=&quot;360000&quot; zeroExpirationOverride=&quot;360000&quot;</code>表示过期时间为360000ms（1小时）。  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;borker&gt;</span><br><span class="line">   &lt;plugins&gt;</span><br><span class="line">       &lt;!-- <span class="number">86</span>,<span class="number">400</span>,<span class="number">000</span>ms = <span class="number">1</span> day --&gt;</span><br><span class="line">       &lt;timeStampingBrokerPlugin ttlCeiling=<span class="string">"360000"</span> zeroExpirationOverride=<span class="string">"360000"</span> /&gt;</span><br><span class="line">   &lt;<span class="regexp">/plugins&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>borker&gt;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="解决空队列的方法">解决“空队列”的方法</span></h2><p>如果不是那种“持续订阅”的topic，那就简单了，配置如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;broker xmlns=<span class="string">"http://activemq.apache.org/schema/core"</span> schedulePeriodForDestinationPurge=<span class="string">"10000"</span>&gt;</span><br><span class="line">   &lt;destinationPolicy&gt;</span><br><span class="line">      &lt;policyMap&gt;</span><br><span class="line">         &lt;policyEntries&gt;</span><br><span class="line">            &lt;policyEntry queue=<span class="string">"&gt;"</span> gcInactiveDestinations=<span class="string">"true"</span> inactiveTimoutBeforeGC=<span class="string">"30000"</span>/&gt;</span><br><span class="line">         &lt;<span class="regexp">/policyEntries&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>policyMap&gt;</span><br><span class="line">   &lt;<span class="regexp">/destinationPolicy&gt;     </span></span><br><span class="line"><span class="regexp"> &lt;/</span>broker&gt;</span><br></pre></td></tr></table></figure></p><p><code>schedulePeriodForDestinationPurge</code>执行清理任务的周期，<code>gcInactiveDestinations=&quot;true&quot;</code>表示启用清理功能，<code>inactiveTimoutBeforeGC=&quot;30000&quot;</code>这个是Topic或Queue超时时间,在规定的时间内，无有效订阅，没有入队记录，超时后就会被清理。<br><img src="/images/大帝扣威少.gif" alt="" title="大帝扣威少！"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://activemq.apache.org/timestampplugin.html" target="_blank" rel="noopener">http://activemq.apache.org/timestampplugin.html</a></p>]]></content>
    
    <summary type="html">
    
      “不活动的空队列”和“过期队列”可不是一个意思！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="activemq" scheme="http://yoursite.com/tags/activemq/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python里调用redis的方法</title>
    <link href="http://yoursite.com/2018/01/29/Python%E9%87%8C%E8%B0%83%E7%94%A8redis%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/29/Python里调用redis的方法/</id>
    <published>2018-01-29T04:38:39.000Z</published>
    <updated>2018-01-29T04:48:40.333Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>Python 2.7里不是自带<code>redis</code>模块的，那么在调用redis的时候自然也会报错，比如：<br><img src="/images/pyredis1.png" alt=""></p><p>遇到这种情况怎么办？</p><p>第一种方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure></p><p>第二种方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install redis</span><br></pre></td></tr></table></figure></p><p>第三种方法：<br>去登录<code>https://github.com/andymccurdy/redis-py</code>，下载包上传到linux里之后，<code>python setup.py install</code>。<br><img src="/images/pyredis2.png" alt=""></p><p>flask模块的安装也是同理。</p><p>注意！这里只有<code>Redis</code>，如果使用<code>StrictRedis</code>会报错：<code>AttributeError: &#39;Redis&#39; object has no attribute &#39;StrictRedis&#39;</code>。这个是版本的问题。见<br><a href="https://github.com/andymccurdy/redis-py/issues/188" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py/issues/188</a></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://debugo.com/python-redis/" target="_blank" rel="noopener">http://debugo.com/python-redis/</a></p><p><img src="/images/欧文骚脚步.gif" alt="" title="这脚步把我看高潮了..."></p>]]></content>
    
    <summary type="html">
    
      本文的写作来源于《第一本 docker书》的第189页。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Ssh连接port 22: Connection refused</title>
    <link href="http://yoursite.com/2018/01/29/Ssh%E8%BF%9E%E6%8E%A5port-22-Connection-refused/"/>
    <id>http://yoursite.com/2018/01/29/Ssh连接port-22-Connection-refused/</id>
    <published>2018-01-29T03:30:18.000Z</published>
    <updated>2018-01-29T03:38:54.116Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>金山云有一个服务器需要连接到数据库但是总是失败，检查之后发现它的VPC配错了，更改VPC之后，这台服务器也会更换一个新的内网IP地址，但是问题来了，更换了内网IP之后，从跳板机连接，提示<code>port 22: Connection refused</code>。</p><p><code>ssh -v 新的ip地址</code>发现根本没有到<code>Connection established</code>。直接就提示<code>port 22: Connection refused</code>。这基本可以断定不是跳板机的问题了，那么就需要在远程机器里看配置。</p><p>但是远程机器是无法连接的啊，怎么办？从金山控制台“连接实例”。<br><img src="/images/ksssh1.png" alt=""></p><p>然后键盘随便按一下，就会看到linux界面，输入账号名和密码，这里密码不支持复制粘贴，需要手动输入。然后就会看到如下界面。<br><img src="/images/ksssh2.png" alt=""></p><p>这样，我们就可以登陆这台机器了，然后<code>vim /etc/ssh/sshd_config</code>，看到最上面有这样的内容。<br><img src="/images/ksssh3.png" alt=""></p><p>这个<code>listenaddress</code>后面就是跳板机ssh的地址，但是这个地址还是老的，而不是更改过后的内网ip地址，所以ssh的连接自然就是<code>refuse</code>。所以我们只需要手动更改成新的内网ip地址就好了。</p><p>更改完之后，重启一下服务器或者<code>/etc/init.d/sshd restart</code>就可以从跳板机上正常连接了。</p><p>如果在<code>/etc/init.d/sshd restart</code>的时候爆出“address family must be specified before ListenAddress”的错误，那么就把<code>AddressFamily</code>移到<code>ListenAddress</code>上面就可以了，如图：<br><img src="/images/ksssh4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      调换了内网IP之后，来了这么一出
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>SFTP不能连接服务器怎么办？</title>
    <link href="http://yoursite.com/2018/01/27/SFTP%E4%B8%8D%E8%83%BD%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/01/27/SFTP不能连接服务器怎么办？/</id>
    <published>2018-01-27T08:19:55.000Z</published>
    <updated>2018-01-29T04:35:52.647Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在跳板机上传送文件，发现使用<code>SFTP</code>连接的时候，出现了这样的一个拒绝情况：<br><img src="/images/sftp1.png" alt=""></p><p>登陆到这个跳板机里，使用<code>tail /var/log/secure</code>，看到了拒绝的具体信息，如下：<br><img src="/images/sftp2.png" alt=""></p><p>这个时候，我就需要<code>locate sftp-server</code>，用<code>locate</code>定位一下<code>sftp</code>文件，但是发现服务器竟然回答我<code>-bash: locate: command not found</code>。</p><p>于是就<code>yum -y install mlocate</code>，安装<code>mlocate</code>之后执行<code>updatedb</code>，需要等待一小会，然后再次执行<code>locate sftp-server</code>，就可以得到sftp-server的文件路径了，如下图：<br><img src="/images/sftp3.png" alt=""></p><p>打开sshd的配置文件，<code>vi /etc/ssh/sshd_config</code>，把<code>Subsystem</code>这一行前面的<code>#</code>去掉：<br><img src="/images/sftp4.png" alt=""></p><p>然后重启启动ssh服务，语句是<code>/etc/init.d/sshd reload</code>，重新连接一下，发现就恢复正常了。</p>]]></content>
    
    <summary type="html">
    
      总有意向不到的插曲
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="sftp" scheme="http://yoursite.com/tags/sftp/"/>
    
  </entry>
  
  <entry>
    <title>Ansible部署模块的时候出现中文乱码的问题</title>
    <link href="http://yoursite.com/2018/01/27/Ansible%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/27/Ansible部署模块的时候出现中文乱码的问题/</id>
    <published>2018-01-27T05:58:49.000Z</published>
    <updated>2018-01-27T06:02:16.658Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在部署服务的时候遇到了一个很罕见的现象，线上有15台服务器是手机推送消息的服务，新来的小运维使用ansible批量跑部署脚本的时候，发现手机端接收到来的消息全是乱码，然后登陆到服务器，查看日志发现，日志里面就是乱码，如图：<br><img src="/images/luanma1.png" alt=""></p><p>由于这个问题用户是有感知的，所以属于“事故”级别了，于是小boss大怒，叫运维赶快回滚，然后让开发赶紧重新检查代码，然后开骂测试都是吃屎的么这么大的一个问题都看不出来真是一群猪伤不起啊。</p><p>开发看了半天自己的代码，发现没有任何问题，战战兢兢跑来跟新来的小运维窃窃私语，结果我发现这个模块用手动单独部署，日志却是正常的，中文显示十分OK。<br><img src="/images/luanma2.png" alt=""></p><p>这一下开发就腰杆硬了，说这不是我的锅啊我是无辜的啊老子天天辛苦加班没有功劳也有苦劳没有苦劳也有疲劳老子的代码经得住考验这一切就是部署的问题。</p><p>于是我就查看了一下ansible的配置文件，<code>vim /etc/ansible/ansible.cfg</code>，发现了问题所在：<br><img src="/images/luanma3.png" alt=""></p><p>这里最后三行需要改成下面的样子，这样就解决了乱码问题。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#module_lang    = C</span><br><span class="line">#module_set_locale = False</span><br><span class="line">module_lang    = zh_CN.UTF<span class="number">-8</span></span><br><span class="line">module_set_locale = True</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这个情况纯属意外...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
      <category term="自动化部署" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6.x安装php 5.6和redis扩展的全过程</title>
    <link href="http://yoursite.com/2018/01/26/CentOS-6-x%E5%AE%89%E8%A3%85php-5-6%E5%92%8Credis%E6%89%A9%E5%B1%95%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/26/CentOS-6-x安装php-5-6和redis扩展的全过程/</id>
    <published>2018-01-26T10:00:08.000Z</published>
    <updated>2018-01-26T10:03:53.515Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装php-56">安装PHP 5.6</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum update    整体升级一下yum包</span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum list installed | grep php    检查时候安装过PHP</span><br><span class="line">rpm -Uvh http:<span class="comment">//mirror.webtatic.com/yum/el6/latest.rpm </span></span><br><span class="line">yum -y install php56w.x86_64</span><br><span class="line">yum -y --enablerepo=webtatic install php56w-devel</span><br><span class="line">yum -y install php56w-xml.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 php56w-opcache.x86_64</span><br><span class="line">yum -y install php56w-fpm</span><br><span class="line">chkconfig php-fpm on    开机自启动</span><br><span class="line">/etc/init.d/php-fpm start    启动进程</span><br><span class="line">php -v    查看是否安装成功</span><br></pre></td></tr></table></figure></code></pre><p><img src="/images/php1.png" alt=""><br>注1：如果想更换到php5.5或5.4版本, 直接把上面的56w换成55w或者54w就可以了；<br>注2：php-opcache和php-xcache会有效的提高php执行速度；</p><p>装php的扩展其实不是很麻烦，主要的步骤如下：<br>1）在扩展模块的客户端文件夹里面使用phpize，这样会生成一个configure文件；<br>2）执行configure文件，后面要加上php的路径；<br>3）将“模块.so”文件名添加到php.ini文件里，重启php-fpm进程；<br>4）通过so文件去调用扩展模块的客户端，实现连接对应的模块；</p><h2><span id="安装redis扩展">安装redis扩展</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -v    检查是否安装了redis</span><br><span class="line">redis-server -v</span><br><span class="line">wget http:<span class="comment">//pecl.php.net/get/redis-2.2.8.tgz </span></span><br><span class="line">tar -zxvf redis<span class="number">-2.2</span><span class="number">.8</span>.tgz</span><br><span class="line">cd redis<span class="number">-2.2</span><span class="number">.8</span>    </span><br><span class="line">phpize    一个专门挂接php扩展的工具，该命令一定要使用在php的模块文件夹主目录下，这里报错Cannot find config.m4。因为phpize要根据模块生成模块的配置文件放在模块文件夹下面</span><br></pre></td></tr></table></figure></code></pre><p><img src="/images/php2.png" alt=""><br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="keyword">with</span>-php-config=<span class="regexp">/usr/</span>bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">make test</span><br><span class="line">vim /etc/php.ini      在php.ini里添加一句“extension=<span class="string">"redis.so"</span>”</span><br><span class="line">service php-fpm restart</span><br></pre></td></tr></table></figure></p><p><img src="/images/php3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      《世界第一等》---伍佰         听闽南语歌，就有一个感觉：我虽卑微平凡，但是不甘平庸，最穷不过要饭，不死总会出头！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>一个连接两个文件的python脚本</title>
    <link href="http://yoursite.com/2018/01/26/%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84python%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/01/26/一个连接两个文件的python脚本/</id>
    <published>2018-01-26T07:13:26.000Z</published>
    <updated>2018-01-26T10:15:18.813Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1><span id="背景交代">背景交代</span></h1><p>公司在阿里云上有一个模块叫mrs，一共120台，它是跟云录像有关的，这个服务一直都是云服务器里没有公网但是购买了公网SLB，然后20个为一组配置到一个SLB里，这个SLB是按流量收费的。但是最近到了年末，各种账目审核，领导发现这个SLB的费用太惊人了，这么搞不够挣的。但是实在没办法，因为云录像嘛，肯定流量很大，如图：<br><img src="/images/mrs1.png" alt=""></p><p>纵然流量大，但是开源节流也是必须的，于是领导就责令开发赶快想出一个办法，减少SLB的费用。于是开发们拉上运维就吭哧吭哧的开始算经济账，最后确定每一个云服务器买7M带宽，然后流量全部走公网，把SLB的架构舍弃掉。</p><p>但是开发在这个模块V2.0里有一个变化，就是Zookeeper需要读取到每一台设备的外网IP，同时这个外网IP必须跟机器是一一对应的，这样模块才能正常工作。</p><p>原来的zookeeper在servermap是长这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">剩下略</span><br></pre></td></tr></table></figure></p><p>而现在开发要求改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"对应的外网IP"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"对应的外网IP"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"内网IP"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"对应的外网IP"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">剩下略</span><br></pre></td></tr></table></figure></p><p>那么这就要把两个文件合并起来了，而且是在合并后做到一对一，不能把IP搭配串了。</p><h1><span id="准备工作">准备工作</span></h1><p>首先，阿里云的网页控制台是无法做到“包年包月的服务器批量永久升级基础带宽”的，只能通过API实现。那么开启了外网IP之后，服务器就会有一个对应的外网IP地址，然后在控制台里，点击“导出资源列表”，只选择<code>服务器名称</code>、<code>内网IP</code>和<code>外网IP</code>。<br><img src="/images/mrs2.png" alt=""></p><p>然后在生成的excel表格里，剪除掉不需要的服务器以及服务器名称，然后保证“内网IP”在前，“外网IP”在后的样式，而且不要服务器名只保留IP,然后把这个文件复制到linux里，起个名，比如叫<code>IP.txt</code>,如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 tmp]# cat IP.txt</span><br><span class="line"><span class="number">10.161</span><span class="number">.236</span><span class="number">.231</span><span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br><span class="line"><span class="number">10.161</span><span class="number">.235</span><span class="number">.150</span>  <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line"><span class="number">10.51</span><span class="number">.10</span><span class="number">.182</span><span class="number">4.4</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line"><span class="number">10.117</span><span class="number">.219</span><span class="number">.72</span>   <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p><p>再把已经使用的zookeeper复制一下，放到一个叫<code>mingdan.txt</code>的文件里，如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 tmp]# cat mingdan.txt</span><br><span class="line">[<span class="string">"10.117.219.72"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.161.235.150"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.161.236.231"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.51.10.182"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br></pre></td></tr></table></figure></p><h1><span id="脚本思路">脚本思路</span></h1><p>我最开始打算用<code>awk</code>的<code>NR</code>、<code>FNR</code>去写，但是发现由于我这个文本的结构太过复杂。<code>awk</code>对付这样的力不从心，稍不好就把人搞得无法自拔，于是就考虑使用python的字典。</p><p>各位都知道，字典里key是不能重复的，而我又不想把这个脚本搞得太复杂，就想在<code>mingdan.txt</code>里的每一行加上序号，用这个序号去当key，而后面的内网IP就作为value，这样保证一一对应。加序号的方法很多，你可以在<code>vim</code>状态下<code>:set number</code>，然后手动复制粘贴。不过我是用的是如下两个命令：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i 's/^[ \t]*//g' mingdan.txt#这一步是添加每一行序号</span><br><span class="line">sed -i 's/\t/ /g'  mingdan.txt#添加序号之后，会生成一个ta</span><br></pre></td></tr></table></figure></p><p>然后<code>mingdan.txt</code>就成了这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 tmp]# cat mingdan.txt </span><br><span class="line"><span class="number">1</span> [<span class="string">"10.117.219.72"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">2</span> [<span class="string">"10.161.235.150"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">3</span> [<span class="string">"10.161.236.231"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br><span class="line"><span class="number">4</span> [<span class="string">"10.51.10.182"</span>] = &#123;app = <span class="string">"mrs"</span>, weight = <span class="number">100</span>&#125;,</span><br></pre></td></tr></table></figure></p><p>万事俱备，现在就要把<code>IP.txt</code>和<code>mingdan.txt</code>按照相同的内网IP整合成一个文件！</p><h1><span id="脚本正文">脚本正文</span></h1><p>这个脚本是不怕<code>mingdan.txt</code>和<code>IP.txt</code>的IP顺序的。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">fd = &#123;&#125;#先设置一个新的空字典叫fd</span><br><span class="line">#以下都是最后拼字符串用的</span><br><span class="line">aaa = <span class="string">'["'</span></span><br><span class="line">bbb = <span class="string">'"] = &#123;app = "mrs",mrsReportIp = "'</span></span><br><span class="line">ccc = <span class="string">'",weight = 100&#125;,'</span></span><br><span class="line"> </span><br><span class="line">#首先先判断mingdan.txt里是否存在</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> open(<span class="string">'mingdan.txt'</span>, <span class="string">'r'</span>):</span><br><span class="line">        ar = re.split(r'[ ""]',l)#做分割，把内网IP切出来</span><br><span class="line">        print "ip is :" + ar[2]#确认是否分割出来的是内网IP地址</span><br><span class="line">        fd[ar[0]] = ar[2]#把这个内网IP地址当作value，前面的序号就是key</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'out.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> open(<span class="string">'IP.txt'</span>, <span class="string">'r'</span>):</span><br><span class="line">                ar = l.split()</span><br><span class="line">                if ar[0] in fd.values():#如果IP.txt里面的内网IP与字典fd里的value相符合</span><br><span class="line">                       fw.write(aaa + ar[0] + bbb + ar[1] + ccc)#拼成一个完整的字符串</span><br><span class="line">                       fw.write('\n')#保存文件</span><br><span class="line">print(<span class="string">'文件整合完毕，请查看out.txt的结果！'</span>)</span><br></pre></td></tr></table></figure></p><h1><span id="执行结果">执行结果</span></h1><pre><code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 tmp]# cat out.txt </span><br><span class="line">[<span class="string">"10.117.219.72"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"1.1.1.1"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.161.235.150"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"2.2.2.2"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.161.236.231"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"3.3.3.3"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[<span class="string">"10.51.10.182"</span>] = &#123;app = <span class="string">"mrs"</span>,mrsReportIp = <span class="string">"4.4.4.4"</span>,weight = <span class="number">100</span>&#125;,</span><br><span class="line">[root@paas-online-crs-001 tmp]#</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      看了今年的阿里云账单，大领导眉头一皱，发现事情不是那么简单
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix-proxy的搭建和配置全过程</title>
    <link href="http://yoursite.com/2018/01/26/Zabbix-proxy%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/26/Zabbix-proxy的搭建和配置全过程/</id>
    <published>2018-01-26T06:27:04.000Z</published>
    <updated>2018-01-26T07:06:37.849Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1><span id="zabbix-proxy的用途和构建图">Zabbix-proxy的用途和构建图</span></h1><p>Zabbix-server是建立在金山云的，现在需要监控阿里云的redis，但是阿里云跟金山云之间通信是无法走内网的，如果直接让zabbix-server与redis直接联系，一旦公网的信息被截获的话，整个金山区的zabbix可能都会遭殃，那么既然有这种“远程监控+当监控的位置通信不便”的需求，就搭建一个zabbix-proxy来解决问题。</p><p>Zabbix-proxy是一个监控代理服务器，它收集监控到的数据，先存放在缓冲区，保存的时间可以通过配置文件设定，然后再传送到zabbix-server，这样也大大减缓了zabbix-server的压力，<font color="red">注意！监控代理需要一个单独的数据库，因为它的数据库表名与zabbix-server的数据库表名是一样的，如果不单独分开，后果就是数据错乱。</font></p><p>有人看到这里可能问了，说来说去你的zabbix-proxy跟阿里的redis依旧是走公网的啊！虽然这样也是走公网，我现在只需要配置一个防火墙规则来让他俩保证通信即可，通过防火墙来提升安全系数。架构如图：<br><img src="/images/proxy1.png" alt=""></p><h1><span id="安装mysql-55">安装Mysql 5.5</span></h1><p>Zabbix-proxy机器情况：金山云<code>centos 6.5</code>，安装zabbix版本：<code>3.0.8</code><br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@js-online-cjhmq-002 opt]yum list installed | grep mysql    #列出已经安装过的mysql情况</span><br><span class="line">[root@js-online-cjhmq-002 opt]yum -y remove mysql-libs.x86_64      #把之前的mysql连根拔起</span><br><span class="line">[root@js-online-cjhmq-002 opt]# rpm -ivh http://repo.mysql.com/yum/mysql-5.5-community/el/6/x86_64/mysql-community-release-el6-5.noarch.rpm</span><br><span class="line">Retrieving http:<span class="comment">//repo.mysql.com/yum/mysql-5.5-community/el/6/x86_64/mysql-community-release-el6-5.noarch.rpm</span></span><br><span class="line">Preparing...                ########################################### [100%]</span><br><span class="line">  1:mysql-community-release########################################### [100%]</span><br><span class="line">[root@js-online-cjhmq-002 opt]groupadd zabbix                       #新建用户组zabbix</span><br><span class="line">[root@js-online-cjhmq<span class="number">-002</span> opt]useradd -g zabbix -u <span class="number">808</span> -m zabbix</span><br><span class="line">#-g：指定用户所属的群组；</span><br><span class="line">#-u：指定用户id。</span><br><span class="line">#-m：自动建立用户的登入目录；</span><br></pre></td></tr></table></figure></p><p>现在要修改一下<code>/etc/yum.repos.d/mysql-community.repo</code>这个文件，将5.5的enabled改为1,5.6的enabled改为0：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Enable to use MySQL 5.5</span><br><span class="line">[mysql55-community]</span><br><span class="line">name=MySQL <span class="number">5.5</span> Community Server</span><br><span class="line">baseurl=http:<span class="comment">//repo.mysql.com/yum/mysql-5.5-community/el/6/$basearch/</span></span><br><span class="line">enabled=1    #这里改成1</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">gpgkey=file:<span class="regexp">/etc/</span>pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br><span class="line"># Enable to use MySQL 5.6</span><br><span class="line">[mysql56-community]</span><br><span class="line">name=MySQL <span class="number">5.6</span> Community Server</span><br><span class="line">baseurl=http:<span class="comment">//repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/</span></span><br><span class="line">enabled=0    #这里改成0</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=file:<span class="regexp">/etc/</span>pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure></p><p>然后执行<code>yum install mysql-community-client mysql-community-devel mysql-community-server php-mysql</code>， 安装服务端和客户端，安装完毕之后可以<code>mysql -h127.0.0.1</code>看一下。<br><img src="/images/proxy2.png" alt=""></p><p>安装完毕之后，修改一下<code>/etc/my.cnf</code>，如图：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size = 512M        #这个根据服务器性能填写，这个机器是2核2G的，所以我拿出半个G给mysql</span><br><span class="line">innodb_file_per_table=1               #这个是新增的字段，设置InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据目录</span><br></pre></td></tr></table></figure></p><p>mysql安装完毕之后，我们还要导表进去，如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br><span class="line">mysqladmin -uroot password <span class="string">'123456'</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">'create database zabbix_proxy character set utf8;'</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">"grant all privileges on zabbix_proxy.* to zabbix@localhost identified by 'zabbix';"</span></span><br><span class="line">mysql -uroot -p123456 -e <span class="string">"flush privileges;"</span></span><br><span class="line">mysql -uzabbix -pzabbix zabbix_proxy &lt;<span class="regexp">/解压路径/</span>zabbix<span class="number">-3.0</span><span class="number">.8</span>/database/mysql/schema.sql</span><br></pre></td></tr></table></figure></p><p>至此，mysql部分已经全部搞定。</p><h1><span id="安装zabbix-proxy">安装Zabbix-proxy</span></h1><p>先去<code>https://sourceforge.net/projects/zabbix/files/ZABBIX%20Latest%20Stable/3.0.8/</code>下载<code>zabbix-3.0.8.tar.gz</code>，上传到proxy服务器里。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zabbix<span class="number">-3.0</span><span class="number">.8</span>.tar.gz</span><br><span class="line">./configure --prefix=<span class="regexp">/usr/</span>local/zabbix<span class="number">-3.0</span><span class="number">.8</span>  --sysconfdir=<span class="regexp">/etc/</span>zabbix  --enable-proxy  --enable-agent  --enable-ipv6  --<span class="keyword">with</span>-mysql=<span class="regexp">/usr/</span>bin/mysql_config  --<span class="keyword">with</span>-net-snmp  --<span class="keyword">with</span>-libcurl  --<span class="keyword">with</span>-openipmi  --<span class="keyword">with</span>-unixodbc  --<span class="keyword">with</span>-ldap  --<span class="keyword">with</span>-ssh2  --enable-java</span><br></pre></td></tr></table></figure></p><p>如果出现了<code>configure: error: Invalid LDAP directory - unable to find ldap.h</code>，解决方法就是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install openldap*</span><br></pre></td></tr></table></figure></p><h1><span id="zabbix-proxy的配置">Zabbix-proxy的配置</span></h1><p>打开<code>/etc/zabbix/zabbix_proxy.conf</code>，需要修改几个地方：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ProxyMode=0                                   #0是主动模式，1是被动模式</span><br><span class="line">Server=A.B.C.D                #这里填写zabbix-server的内网IP</span><br><span class="line">Hostname=J.Q.K.A              #这里要与/etc/hosts下的名字一模一样</span><br><span class="line">LogFile=<span class="regexp">/tmp/</span>zabbix_proxy.log</span><br><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbix_proxy</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix</span><br><span class="line">ConfigFrequency=120              #主动去server端去拉去配置更新的频率120秒一次</span><br><span class="line">DataSenderFrequency=60              #发送采集的监控数据到服务器端，默认是1秒，我们一分钟发送一次</span><br><span class="line">#ProxyLocalBuffer=0                #ProxyLocalBuffer表示数据传递给server之后还要在proxy里保存多久（单位为小时）。如果注释就是代表不删除。</span><br><span class="line">#ProxyOfflineBuffer=1               #ProxyOfflineBuffer表示数据没有传递给server的话还要在proxy里保存多久（单位为小时）。如果注释就是代表不删除。</span><br></pre></td></tr></table></figure></p><p>然后就是启动proxy:<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/zabbix_proxy/sbin/zabbix_proxy</span><br></pre></td></tr></table></figure></p><p>用netstat查看一下端口和进程是否都OK：<br><img src="/images/proxy3.png" alt=""></p><h1><span id="zabbix-server端的配置">Zabbix-server端的配置</span></h1><p>登入zabbix-server的网页，如图添加proxy：<br><img src="/images/proxy4.png" alt=""></p><p>点击“create proxy”之后，就对应填写资料吧：<br><img src="/images/proxy5.png" alt=""></p><p><img src="/images/proxy6.png" alt=""></p><p>这里对上面的几个选项多说几句：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connections to proxy：服务器如何连接到被动代理：无加密（默认），使用PSK（预共享密钥）或证书。</span><br><span class="line">Connections <span class="keyword">from</span> proxy：从活动代理中选择允许的连接类型。 可以同时选择几种连接类型（用于测试和切换到其他连接类型）。 默认为“无加密”。</span><br><span class="line">#点击Certificate之后又两个参数：</span><br><span class="line">Issuer：允许颁发证书。 证书首先通过CA（认证机构）验证。 如果CA有效，则由CA签名，则可以使用Issuer字段来进一步限制允许的CA。 该字段是可选的，如果您的Zabbix安装使用多个CA的证书，则使用该字段。</span><br><span class="line">Subject：允许的证书。 证书首先通过CA验证。 如果它有效，由CA签名，则主题字段可用于仅允许Subject字符串的一个值。 如果此字段为空，则接受由配置的CA签名的任何有效证书。</span><br><span class="line">#点击PSK之后又两个参数：</span><br><span class="line">PSK identity：预共享密钥身份字符串。</span><br><span class="line">PSK ： 预共享密钥（hex-string）。 如果Zabbix使用mbed TLS（PolarSSL）库，Zabbix将使用GnuTLS或OpenSSL库，<span class="number">64</span>位十六进制（<span class="number">32</span>字节PSK），最大长度为<span class="number">512</span>位十六进制数（<span class="number">256</span>字节PSK）。 示例：<span class="number">1</span>f87b595725ac58dd977beef14b97461a7c1045b9a1c963065002c5473194952</span><br></pre></td></tr></table></figure></p><p>保存之后，就在zabbix-server用<code>zabbix-get</code>去ping一下proxy，看看返回值是否是1，如果是<code>zabbix_get [18290]: Check access restrictions in Zabbix agent configuration</code>，就检查一下刚才的hostname等值是否正确。<br><img src="/images/proxy7.png" alt=""></p><h1><span id="被监控机器的配置">被监控机器的配置</span></h1><p>在被监控的阿里云redis里安装<code>zabbix-agent</code>，在<code>agentd.conf</code>里把<code>hostname</code>写成自己在<code>/etc/hosts</code>里的<code>hostname</code>，<code>Server</code>地址和<code>ServerActive</code>的地址都要写成proxy的外网IP地址。保存之后启动agent进程，这个时候在proxy端是可以通过<code>zabbix_get</code>得到这台被监控机器的值，如图：<br><img src="/images/proxy8.png" alt=""></p><p>在Zabbix-Server的WEB界面里，为阿里云的redis新建一个host，<code>Agent interface</code>那里填写被监控的机器IP，端口是10050，<code>Monitored by proxy</code>的地方要写成刚刚添加的proxy。如图：<br><img src="/images/proxy9.png" alt=""></p><p>上面已经提到过，用proxy模式并且zabbix的客户端也是主动模式提交数据，这样能大大提高采集效率，降低zabbix服务器端和proxy端的压力。现在我们希望添加的还是使用zabbix_agent的方式，新加到zabbix_proxy里面的主机使用<code>zabbix_agent（active）</code>的方式。注意在模板的克隆要选择<code>full clone</code>，不要选“clone”，那样的话就仅仅是把iterm的名字克隆过去而已，如图：<br><img src="/images/proxy10.png" alt=""></p><p>然后在items选择具体的类型，根据需要，想改那个改哪个，如图，注意！我图里写的是<code>Zabbix agent</code>，但是type这里选择<code>Zabbix agent (active)</code>。<br><img src="/images/proxy11.png" alt=""></p><p>改完之后，保存一下，就会看到type都是<code>zabbix agent（active）</code>了。<br><img src="/images/proxy12.png" alt=""></p><p>最后在host里把这个机器添加到proxy的模板里，如图：<br><img src="/images/proxy13.png" alt=""></p><p>在Administration的Proxies也看到效果了，如果server与proxy没有正确连接的话，last seen的地方会是<code>--</code>，如果连接的话就会显示具体时间，如图:<br><img src="/images/proxy15.png" alt=""></p><p>返回到hosts里，查看那个被监控的redis机器也成功被监控到了，<code>ZBX</code>已经变绿。如图：<br><img src="/images/proxy14.png" alt=""></p><p>因为我们线上环境基本都是用的zabbix_proxy方式是active方式，然后客户端也是active方式，既然都是active方式，那么zabbix_agent的Hostname就很重要，打个比方如果再zabbix_server端把一个主机的Hostname改了，然后客户端那边也改了，服务端和客户端的Hostname是统一的，但是proxy那里还记录的是旧Hostname，然后就会在proxy日志里面看到下面一条：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot send list <span class="keyword">of</span> active checks to <span class="string">"proxy内网IP地址"</span>: host [virt_proxy内网IP地址] not found</span><br></pre></td></tr></table></figure></p><p>proxy主动模式下，<code>ConfigFrequency</code>默认的是3600秒一小时，显然有点大了，可以适当的调低一下，如10分钟或者几分钟什么的。然后出现问题多看看zabbix服务端和proxy的日志，对症下药。</p><h1><span id="参考资料">参考资料</span></h1><p><a href="http://www.51niux.com/?id=156" target="_blank" rel="noopener">http://www.51niux.com/?id=156</a><br><a href="http://www.cnblogs.com/wangxiaoqiangs/p/5336630.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangxiaoqiangs/p/5336630.html</a></p>]]></content>
    
    <summary type="html">
    
      把监控的手伸的再长一点...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="监控技术" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器更改时区为utc</title>
    <link href="http://yoursite.com/2018/01/25/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E6%94%B9%E6%97%B6%E5%8C%BA%E4%B8%BAutc/"/>
    <id>http://yoursite.com/2018/01/25/阿里云服务器更改时区为utc/</id>
    <published>2018-01-25T14:31:16.000Z</published>
    <updated>2018-01-26T06:55:58.895Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>开发提出需求说，某个模块是给洋人使用，于是把服务器里的时间改成UTC时间。我登陆到服务器里使用<code>date</code>查看了一下，发现目前使用的是东八区时间，如图：<br><img src="/images/time1.png" alt="goodbye,Kobe"></p><p>首先先开启UTC，方法就是在<code>/etc/sysconfig/clock</code>的文件里修改这样一处：<code>UTC=true</code>。这样即使机器重启，UTC时间依旧会“<code>BIOS ▶ UTC时区转换 ▶ 系统时间</code>”的顺序正常使用。</p><p>在Centos 6.5里，各时区的时间是在一个叫<code>/usr/share/zoneinfo/</code>的文件夹下，在里面我们发现了我们的目标—-<code>UTC</code>，如图：<br><img src="/images/time2.png" alt="goodbye,Kobe"></p><p>然后就是修改，方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/localtime /etc/localtime-bak</span><br><span class="line">ln -s /usr/share/zoneinfo/UTC /etc/localtime</span><br></pre></td></tr></table></figure></p><p>先把老的时间文件备份，然后把UTC文件做一个软连接过来即可。我们所熟悉的<code>date</code>命令就是<code>/etc/localtime</code>的输出结果。</p><p>现在去<code>date</code>一下，看看结果，果然改成了<code>UTC</code>：<br><img src="/images/time3.png" alt="goodbye,Kobe"></p><p>这个时候，如果你服务器里装的是nginx的话，就会发现nginx日志里的时间也会变成<code>UTC</code>而不会再是<code>CST</code>了。</p>]]></content>
    
    <summary type="html">
    
      为美国人服务的模块就要改成美国时间
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>阿里云购买、启动、停止ecs等等操作的python脚本</title>
    <link href="http://yoursite.com/2018/01/24/%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%AD%E4%B9%B0%E3%80%81%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2ecs%E7%9A%84python%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/01/24/阿里云购买、启动、停止ecs的python脚本/</id>
    <published>2018-01-24T14:52:41.000Z</published>
    <updated>2018-01-25T04:47:44.335Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>以下所有脚本都是在python 2.7的环境亲自测试的。<br>阿里云的ak/sk是没有地域概念的，在任何地域都可以使用。</p><h2><span id="购买服务器">购买服务器</span></h2><p>以在新加坡购买服务器为例子：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#注意！服务器创建完毕之后，状态是关机的。</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> CreateInstanceRequest</span><br><span class="line"># 创建 Client 实例</span><br><span class="line">clt = client.AcsClient('阿里云ak','阿里云sk','新加坡的地域')#各地域的缩写请看：https://help.aliyun.com/document_detail/40654.html?spm=5176.doc25499.2.14.yh6n8c</span><br><span class="line"></span><br><span class="line"># 创建 request，并设置参数</span><br><span class="line">request = CreateInstanceRequest.CreateInstanceRequest()</span><br><span class="line"></span><br><span class="line"># 设置ECS细节</span><br><span class="line">request.set_ImageId("centos_7_04_64_20G_alibase_201701015.vhd")#这里是镜像</span><br><span class="line">request.set_InstanceName("xjp-test-001")#这里写名称</span><br><span class="line">request.set_SecurityGroupId("sg-23t6c6mjw")#这里是安全组</span><br><span class="line">request.set_Password("W2.bi7FX1dyb)T3Wh^,[")#这里是密码，推荐使用https传输，安全</span><br><span class="line">request.set_InstanceChargeType("PrePaid")#确定是包年包月</span><br><span class="line">request.set_Period("2")#先买两个月的</span><br><span class="line">request.set_SystemDiskCategory("cloud_efficiency")#注意，如果是海外的机器的话，要额外说明，海外的机器只有高速云盘和SSD盘</span><br><span class="line"></span><br><span class="line"># 设置实例规格</span><br><span class="line">request.set_InstanceType(<span class="string">"ecs.s2.large"</span>)</span><br><span class="line"></span><br><span class="line"># 发起 API 请求并打印返回</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></p><h2><span id="服务器停机">服务器停机</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> StopInstanceRequest</span><br><span class="line">list1 = [<span class="string">'要停机的ecs id1'</span>,<span class="string">'要停机的ecs id2'</span>,<span class="string">'要停机的ecs id3'</span>...]</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云ak'</span>,<span class="string">'阿里云sk'</span>,<span class="string">'地域名'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">       shutdown = StopInstanceRequest.StopInstanceRequest()</span><br><span class="line">       shutdown.set_InstanceId(i)</span><br><span class="line">       action = clt.do_action_with_exception(shutdown)</span><br><span class="line">       print <span class="string">"现在停机:"</span> + i</span><br><span class="line">       print action</span><br></pre></td></tr></table></figure></code></pre><h2><span id="服务器启动">服务器启动</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> StartInstanceRequest</span><br><span class="line">list = [<span class="string">'要停机的ecs id1'</span>,<span class="string">'要停机的ecs id2'</span>,<span class="string">'要停机的ecs id3'</span>...]</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云ak'</span>,<span class="string">'阿里云sk'</span>,<span class="string">'地域名'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">       start = StartInstanceRequest.StartInstanceRequest()</span><br><span class="line">       start.set_InstanceId(i)</span><br><span class="line">       action = clt.do_action_with_exception(start)</span><br><span class="line">       print <span class="string">"现在启动:"</span> + i</span><br><span class="line">       print action</span><br></pre></td></tr></table></figure></code></pre><h2><span id="查询阿里云镜像">查询阿里云镜像</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> DescribeImagesRequest</span><br><span class="line"><span class="keyword">import</span> aliyunsdkcore.request</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云ak'</span>,<span class="string">'阿里云sk'</span>,<span class="string">'地域名'</span>)</span><br><span class="line"></span><br><span class="line">request = DescribeImagesRequest.DescribeImagesRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></code></pre><h2><span id="查询服务器规格">查询服务器规格</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> DescribeInstanceTypesRequest</span><br><span class="line"><span class="keyword">import</span> aliyunsdkcore.request</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云ak'</span>,<span class="string">'阿里云sk'</span>,<span class="string">'地域名'</span>)</span><br><span class="line"></span><br><span class="line">request = DescribeInstanceTypesRequest.DescribeInstanceTypesRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br></pre></td></tr></table></figure></code></pre><h2><span id="参考资料">参考资料</span></h2><p><a href="https://help.aliyun.com/document_detail/25499.html?spm=5176.doc25501.6.857.wR0MHP" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/25499.html?spm=5176.doc25501.6.857.wR0MHP</a></p><p><img src="/images/xiaomage.jpg" alt="小马哥" title="GOOD LUCK AND THANK U,Masche."></p>]]></content>
    
    <summary type="html">
    
      有了这些脚本，七拼八凑的就可以写出来一个批量购买服务器的脚本了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="阿里云api" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91api/"/>
    
  </entry>
  
  <entry>
    <title>Crontab里解决脚本时间重叠的问题</title>
    <link href="http://yoursite.com/2018/01/24/Crontab%E9%87%8C%E8%A7%A3%E5%86%B3%E8%84%9A%E6%9C%AC%E6%97%B6%E9%97%B4%E9%87%8D%E5%8F%A0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/24/Crontab里解决脚本时间重叠的问题/</id>
    <published>2018-01-24T06:17:32.000Z</published>
    <updated>2018-01-24T06:26:57.148Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>Linux里的Crontab是一个好东西，但是它的默认最小执行频率是1分钟，但是我们在实际生产环境里有的时候遇到的脚本执行时间是大于1分钟的，这样就会出现一个很尴尬的情况，就是在1分钟过后，系统进程会出现多个脚本，neck and neck式的在后台运行，比如这样：<br><img src="/images/log499.png" alt="akb48"></p><p>从上面的图可以看到，10点36分<code>log499.sh</code>没有执行完毕，10点37又开始了执行了一个新的<code>log499.sh</code>脚本。这种脚本冲突肯定不是我们所希望的，那么如何才能保证后台只是在一段时间里只执行一个脚本呢？</p><p>这个时候我们就要使用文件锁，<code>flock</code>，这种方法要比判断pid高大上的多。</p><p>首先假设我们的脚本名字叫abc.sh，这个脚本文件的执行时间是要大于1分钟的，同时我们再设定一个锁文件，位置就叫<code>/tmp/abc.lock</code>,这个文件可以是空的，然后<code>crontab -e</code>，添加一句命令如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * flock -xn /tmp/abc.lock -c <span class="string">'sh /路径/abc.sh &gt;&gt; /记录日志的路径 2&gt;&amp;1'</span></span><br></pre></td></tr></table></figure></p><p>这个时候静候crontab启动abc.sh，通过<code>ps -ef|grep abc</code>，发现在后台始终只有一个abc进程。</p><p>但是有的时候会有这样的一个问题，就是abc执行一次之后，在下一次该执行的时候却没有执行，好像crontab失效了一样，对于这样的情况，就需要添加下面的语句到abc.sh末尾：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/abc.lock      #删除掉原有的锁文件</span><br><span class="line">sleep n                      #睡n秒</span><br><span class="line">touch /tmp/abc.lock     #再新建一个锁文件</span><br></pre></td></tr></table></figure></p><p>这样不断地更新lock锁文件，就会保证crontab每次都会按期执行。</p><p>这里要注意一下，里面我加了一句<code>sleep n</code>，这里的n是为了跨分钟的存在，这是为了防止没有走到下一个分钟又会生成一个新的lock锁文件，这样还是会出现重复启动脚本的情况。</p><p>这里就涉及到flock的一个原理：<strong>在每一次执行任务的时候都会先去尝试取到锁文件，如果取到了锁文件，那么就会下一步，反之就会放弃执行</strong>。A任务在运行的时候已经占据了lock文件，那么B任务来了，发现没有lock了，就不会执行任务。</p><p>这里我们使用了flock的三个参数：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-x, --exclusive: 获得一个独占锁</span><br><span class="line">-n, --nonblock:  如果没有立即获得锁，直接失败而不是等待</span><br><span class="line">-c, --command:   在shell中运行一个单独的命令</span><br></pre></td></tr></table></figure></p><p>当然，flock还是有很多丰富的参数可以供各位使用，大家就各自去google一下吧。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.csdn.net/fdipzone/article/details/38284009" target="_blank" rel="noopener">http://blog.csdn.net/fdipzone/article/details/38284009</a><br><a href="http://chuansong.me/n/285635151949" target="_blank" rel="noopener">http://chuansong.me/n/285635151949</a><br><a href="https://segmentfault.com/q/1010000008039907" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008039907</a></p>]]></content>
    
    <summary type="html">
    
      话说那是一个年久失修的模块，现在只能靠这种每分钟监控的脚本来残喘续命了...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="crontab" scheme="http://yoursite.com/tags/crontab/"/>
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>yum提示Error: rpmdb open failed</title>
    <link href="http://yoursite.com/2018/01/24/yum%E6%8F%90%E7%A4%BAError-rpmdb-open-failed/"/>
    <id>http://yoursite.com/2018/01/24/yum提示Error-rpmdb-open-failed/</id>
    <published>2018-01-24T06:09:35.000Z</published>
    <updated>2018-01-25T09:35:20.166Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在一台机器里，使用<code>yum</code>安装的时候，出现了如下的故障：<br><img src="/images/yum1.png" alt="akb48"></p><p>这种情况就是RPM数据库被破坏了，这个时候就需要我们重建数据库，于是就输入如下的命令：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd / <span class="keyword">var</span> / lib / rpm /</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">` ls | grep 'db.' `</span> ; <span class="keyword">do</span> mv $i $i .bak ; done</span><br><span class="line">rpm -- rebuilddb</span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure></p><p>重新<code>cleanup</code>就正常了。</p>]]></content>
    
    <summary type="html">
    
      解决yum的小故障
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="yum" scheme="http://yoursite.com/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>由一个实例浅析sed用法</title>
    <link href="http://yoursite.com/2018/01/23/%E7%94%B1%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E6%B5%85%E6%9E%90sed%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/23/由一个实例浅析sed用法/</id>
    <published>2018-01-23T14:27:54.000Z</published>
    <updated>2018-01-24T05:56:59.068Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>首先，假设我们有一个文件，叫123.txt，<code>cat</code>一下看到里面的内容是这样的：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@func-lms-001 ~]# cat 123.txt </span><br><span class="line">james</span><br><span class="line">curry</span><br><span class="line">  durant</span><br><span class="line">wade</span><br><span class="line">yaoming</span><br><span class="line">    messi</span><br><span class="line">[root@func-lms-001 ~]#</span><br></pre></td></tr></table></figure></p><p>如果我们想在james前面加上lebron，那么采用的sed语句就是：<code>sed -i &#39;/^james/s/^/lebron /&#39; 123.txt</code>，如果要在curry后面加上champion，那么采用的语句就是：<code>sed -i &#39;/^curry/s/$/ champion!/&#39; 123.txt</code>。</p><p>使用完上面两句话之后，再#cat一下，看下效果：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@func-lms-001 ~]# cat 123.txt </span><br><span class="line">lebron james</span><br><span class="line">curry champion!</span><br><span class="line">  durant</span><br><span class="line">wade</span><br><span class="line">yaoming</span><br><span class="line">     messi</span><br><span class="line">[root@func-lms-001 ~]#</span><br></pre></td></tr></table></figure></p><p>现在我们要把durant前面加上FMVP这几个字母，按照上面的语句找葫芦画瓢的话，应该是：<code>sed -i &#39;/^durant/s/^/FMVP /&#39; 123.txt</code>。但是很抱歉，这个语句是错误的！因为<code>^</code>是匹配开头durant的意思，而我们再看一下durant那一行的开头是空格。</p><p>那么就要用liunx的正则来匹配空格，于是这句话就变成了：<code>sed -i &#39;/^\s\+durant/s/^/FMVP/&#39; 123.txt</code>，<code>^\s\+</code>这个就是正则里匹配空格的意思 。</p><p><code>cat</code>一下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@func-lms-001 ~]# cat 123.txt </span><br><span class="line">lebron james</span><br><span class="line">curry champion!</span><br><span class="line">FMVP   durant</span><br><span class="line">wade</span><br><span class="line">yaoming</span><br><span class="line">     messi</span><br><span class="line">[root@func-lms-001 ~]#</span><br></pre></td></tr></table></figure></p><p>那么现在要在messi后面加上”GOAL !!!”，就很简单了。语句是：<code>sed -i &#39;/^\s\+messi/s/$/ GOAL !!!/&#39; 123.txt</code>。</p><p>以上我们把有/无空格情况下的首尾添加字符都练习了一遍，下面我们要看看如果要在中间添加怎么办？</p><p>比如说，有一天苦逼的运维接到开发PL的邮件，说”由于安全基线要求，现在需要监听内网端口“，具体的需求就是把所有含tomcat的模块里的server.xml的文件里添加上内网IP。</p><p>原有的server.xml的节选如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Service name=<span class="string">"LMS"</span>&gt;</span><br><span class="line">        &lt;Connector port=<span class="string">"8080"</span> connectionTimeout=<span class="string">"20000"</span> protocol=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> redirectPort=<span class="string">"8443"</span>  enableLookups=<span class="string">"false"</span> disableUploadTimeout=<span class="string">"true"</span> maxThreads=<span class="string">"500"</span> minSpareThreads=<span class="string">"20"</span> acceptCount=<span class="string">"100"</span>/&gt;</span><br><span class="line"></span><br><span class="line">         &lt;Connector port=<span class="string">"8088"</span> connectionTimeout=<span class="string">"20000"</span> protocol=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> redirectPort=<span class="string">"8443"</span>  enableLookups=<span class="string">"false"</span> disableUploadTimeout=<span class="string">"true"</span> maxThreads=<span class="string">"500"</span> minSpareThreads=<span class="string">"20"</span> acceptCount=<span class="string">"100"</span>/&gt;</span><br><span class="line">                </span><br><span class="line">        &lt;Connector port=<span class="string">"8099"</span> protocol=<span class="string">"AJP/1.3"</span> redirectPort=<span class="string">"8443"</span> /&gt;</span><br><span class="line">        &lt;Engine defaultHost=<span class="string">"localhost"</span> name=<span class="string">"Catalina"</span>&gt;</span><br><span class="line">                 &lt;Realm className=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span><br><span class="line">                                &lt;Realm className=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> resourceName=<span class="string">"UserDatabase"</span> /&gt;</span><br><span class="line">                 &lt;<span class="regexp">/Realm&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在要把<code>&lt;Connector port=&quot;8099&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>这一句里面加上内网IP:<code>1.2.3.4</code>，改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Service name=<span class="string">"LMS"</span>&gt;</span><br><span class="line">               &lt;Connector port=<span class="string">"8080"</span> connectionTimeout=<span class="string">"20000"</span> protocol=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> redirectPort=<span class="string">"8443"</span>  enableLookups=<span class="string">"false"</span> disableUploadTimeout=<span class="string">"true"</span> maxThreads=<span class="string">"500"</span> minSpareThreads=<span class="string">"20"</span> acceptCount=<span class="string">"100"</span>/&gt;</span><br><span class="line"></span><br><span class="line">                &lt;Connector port=<span class="string">"8088"</span> connectionTimeout=<span class="string">"20000"</span> protocol=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> redirectPort=<span class="string">"8443"</span>  enableLookups=<span class="string">"false"</span> disableUploadTimeout=<span class="string">"true"</span> maxThreads=<span class="string">"500"</span> minSpareThreads=<span class="string">"20"</span> acceptCount=<span class="string">"100"</span>/&gt;</span><br><span class="line">                       </span><br><span class="line">               &lt;Connector port=<span class="string">"8099"</span> address=<span class="string">"1.2.3.4"</span> protocol=<span class="string">"AJP/1.3"</span> redirectPort=<span class="string">"8443"</span> /&gt;</span><br><span class="line">               &lt;Engine defaultHost=<span class="string">"localhost"</span> name=<span class="string">"Catalina"</span>&gt;</span><br><span class="line">                        &lt;Realm className=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span><br><span class="line">                                       &lt;Realm className=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> resourceName=<span class="string">"UserDatabase"</span> /&gt;</span><br><span class="line">                        &lt;<span class="regexp">/Realm&gt;</span></span><br></pre></td></tr></table></figure></p><p>请问怎么做？</p><p>答案1：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'/&lt;Connector port="8099"/s/port="8099"/port="8099" address="1.2.3.4"/g'</span> server.xml</span><br></pre></td></tr></table></figure></p><p>答案2：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s@Connector port="8099"@&amp; address="1.2.3.4"@'</span> server.xml</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      sed是一个装逼利器！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix添加网卡内外流量监控</title>
    <link href="http://yoursite.com/2018/01/23/Zabbix%E6%B7%BB%E5%8A%A0%E7%BD%91%E5%8D%A1%E5%86%85%E5%A4%96%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2018/01/23/Zabbix添加网卡内外流量监控/</id>
    <published>2018-01-23T13:41:12.000Z</published>
    <updated>2018-01-23T13:51:44.231Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>现在笔者想对host名单里面的<code>zabbix_server</code>进行网卡的内外流量情况的一个监控，首先登录zabbix之后，<code>configuration</code>—<code>hosts</code>，出现如下的菜单：<br><img src="/images/zabbixnet1.png" alt="akb48"></p><p>现在可以看到这个zabbix_server后面link了很多个模板，正是因为link了很多的模板，所以导致它的items非常多，42个。现在是要在zabbix_server里添加两个新的监控项，这一步跟模板其实没有什么关系，只需要在items里直接添加items即可。</p><p>我们先添加网卡外流量的items，整个配置如图所示：<br><img src="/images/zabbixnet2.png" alt="akb48"></p><p>里面具体的数值可以自己更换，比如<code>Applications</code>什么的，<code>key\units\Use custom multiplier</code>这些是固定的，全部写完之后就可以save。</p><p>找葫芦画瓢，我们可以再添加一个网卡的内流量监控，也是一样的套路，如图所示：<br><img src="/images/zabbixnet3.png" alt="akb48"></p><p>有了<code>items</code>，就要有<code>trigger</code>，有了items里的<code>key</code>，那么<code>trigger</code>也很简单，这里的<code>expression</code>多时候各位都是从网上ctrl+c下来，却不能ctrl+v，因为会红字报错—-<code>Incorrect item key &quot;net.if.in[eth0,bytes]&quot; provided for trigger expression on &quot;服务器名称&quot;</code>，于是就有很多不明真相的吃瓜群众就走“add”路线，然后发现要走add路线还要先把服务器添加到对应的模板上去。其实大可不必，这个expression是可以自己写的，但是一定要确定trigger跟items是配对的。以外网流量所示：<br><img src="/images/zabbixnet4.png" alt="akb48"></p><p>在这里我添加成了1K，这样是为了方便监控，具体数值因情况而异，而且重要性我选择了无。</p><p>最后就是要形成图表来糊弄领导，让领导感受一下什么叫做高大上，在graph的界面里选择<code>create graph</code>，然后就如图所示的填写：<br><img src="/images/zabbixnet5.png" alt="akb48"></p><p>一个是红色线，一个是绿色线，双龙戏珠，<code>save</code>。</p><p>最后来到<code>Monitoring</code>—<code>Graphs</code>里，找到正确的host,group和graph，就会看到激动人心的图表了：<br><img src="/images/zabbixnet6.png" alt="akb48"></p><p>这里要注意几点，有时候zabbix反应较慢，可能写好的key会出现<code>not support</code>的情况，这个时候可以先登录zabbix_server去<code>zabbix_get</code>一下，<code>zabbix_get</code>的方法之前有讲过，请见<a href="http://chenx1242.blog.51cto.com/10430133/1738820" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1738820</a> ，如果<code>zabbix_get</code>是成功返回值的，先检查对应的单位（结果是浮点值，但是units设定是一个整数值肯定会<code>not support</code>）,如果单位检查正确，就修改zabbix重新check的时间，实在不行就重新建立一个items。</p>]]></content>
    
    <summary type="html">
    
      zabbix讲究一气呵成，从头到尾没人打扰然后布置。但是干运维难免有人来打扰，这个过来要求布环境，那个要求来买服务器。所以zabbix之路难免走的坑坑洼洼。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="服务器监控" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>使用Nessus进行漏洞扫描的过程</title>
    <link href="http://yoursite.com/2018/01/23/%E4%BD%BF%E7%94%A8Nessus%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/23/使用Nessus进行漏洞扫描的过程/</id>
    <published>2018-01-23T04:53:51.000Z</published>
    <updated>2018-01-23T06:04:53.571Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>对于一个服务器运维工作者，掌握和运用一门漏洞扫描的工具也是行走江湖的必备项，Nessus就是漏洞扫描的强力武器。Nessus为一款当下比较流行的系统弱点扫描与分析软件，他的优点是操作简单（配置几乎全web化），而且页面精美、扫描项广泛；缺点就是目前不支持中文…</p><h2><span id="下载与安装">下载与安装</span></h2><p>要安装Nessus，需要登陆<code>https://www.tenable.com/products/nessus/select-your-operating-system</code>,选择对应的系统，我这个服务器是centos 7，那么就选择下图里红色的那个rpm包：<br><img src="/images/nessus1.png" alt="paradin"></p><p>点击之后，出来一个同意条款，同意之后就开始自动下载。但是要安装nessus仅仅有程序是不够的，还需要一个对应的验证码，在上面那个界面里，下拉一点有一个<code>get an activation code</code>的check，点击之后跳转到<code>https://www.tenable.com/products/nessus/nessus-plugins/obtain-an-activation-code</code>，里选择家用free版，点击下面的<code>register now</code>：<br><img src="/images/nessus2.png" alt="paradin"></p><p>注册是很简单的，填写名称和电邮就可以了。不久后就会在电子邮件里面获得一个校验码。</p><p>把下载的那个Nessus-6.11.1-es7.x86_64.rpm包上传到centos之后，<code>rpm -ivh Nessus-6.11.1-es7.x86_64.rpm</code>进行安装，安装完成之后，<code>service nessusd start</code>启动进程，启动完毕之后，使用<code>netstat -lnpt|grep 8834</code>，来检查一下8834端口是否被监听，如图：<br><img src="/images/nessus3.png" alt="paradin"></p><p>端口监听OK，那么在浏览器里输入<code>https://服务器外网IP地址:8834</code>打开控制web界面，如果有提示当前连接不安全，无视掉就可以。nessus的欢迎界面如下：<br><img src="/images/nessus4.png" alt="paradin"></p><p>注册一个账号之后，在这个界面里面选择home那一条，输入邮箱里面获得的那个注册码：<br><img src="/images/nessus5.png" alt="paradin"></p><p>整个的配置就完事了，继而就是nessus自动安装的过程，大约需要几分钟：<br><img src="/images/nessus6.png" alt="paradin"></p><p>整个安装完毕之后，就会看到nessus的主界面，简单明了的风格：<br><img src="/images/nessus7.png" alt="paradin"></p><p>至此整个nessus的安装过程结束。</p><h2><span id="配置扫描策略以及启动扫描任务">配置扫描策略以及启动扫描任务</span></h2><p>nessus扫描漏洞的流程很简单：需要先”制定策略”，然后在这个策略的基础上建立”扫描任务”，然后执行任务。首先，我们先建立一个<code>policy</code>，如图：<br><img src="/images/nessus8.png" alt="paradin"></p><p>点击<code>New Policy</code>之后，就会出现很多种扫描策略，这里我们选择<code>Advanced Scan</code>(高级扫描)：<br><img src="/images/nessus9.png" alt="paradin"> </p><p>我给这个测试的扫描策略，起名叫”chenchenchen”，如图：<br><img src="/images/nessus10.png" alt="paradin"> </p><p>对于上面这个图，<code>Permissions</code>是权限管理，是否可以准许其他的nessus用户来使用你这个策略；<code>Discovery</code>里面有主机发现、端口扫描和服务发现等功能；<code>assessment</code>里面有对于暴力攻击的一些设定；<code>Report</code>里面是报告的一些设定；Advanced里面是一些超时、每秒扫描多少项等基础设定，一般来说这里默认就好。我们主要来看看那个<code>plugins</code>。</p><p><code>Plugins</code>里面就是具体的策略，里面有父策略，具体的父策略下面还有子策略，把这些策略制定得体的话，使用者可以更加有针对性的进行扫描。比如我这个策略是针对于centos系统的扫描策略，那么一些冗余的项目大可以完全不要，举个例子：<br><img src="/images/nessus11.png" alt="paradin"> </p><p>在上面这个图里面，我不需要<code>amazon linux local security checks</code>这个“亚马逊linux本地安全检查”父策略，那就把它disabled掉，而对于<code>centos local security checks</code>这个父策略呢，我又不需要那几个关于bind的子策略，那我就单独把那些子策略disabled掉，这样等等操作，就搭配成为了一个用时不长但是又包含了所有制定的检查项的策略，然后点击<code>save</code>保存。</p><p>保存完后，我们就发现policy里多了一条<code>chenchenchen</code>的记录：<br><img src="/images/nessus12.png" alt="paradin"> </p><p>既然策略有了，现在我们就来制定一个任务。在主界面里选择<code>My Scans</code>,点击<code>New Scans</code>,这个时候还是有很多个图标，但是我们选择后面的<code>User defined</code>，如图：<br><img src="/images/nessus13.png" alt="paradin"> </p><p>这里我们就看到了我们已经制定好的那个chenchenchen策略，点击这个chenchenchen之后，就要给这个依赖chenchenchen策略的任务起名字以及需要扫描的网络段，由于我这个测试机的内网ip段是10.132.27.0，于是我就写了“10.132.27.0/24”，任务名字叫chentest：<br><img src="/images/nessus14.png" alt="paradin"> </p><h2><span id="启动扫描任务">启动扫描任务</span></h2><p>点击save保存之后，就会看到My Scans里多了这个chentest的任务，点击三角播放箭头，那么这个任务就开始执行了！如图：<br><img src="/images/nessus15.png" alt="paradin"> </p><p>从该界面可以看到扫描任务的状态为Running（正在运行），表示chentest扫描任务添加成功。如果想要停止扫描，可以单击方块（停止一下）按钮。如果暂停扫描任务，单击暂停按钮。</p><p>扫描完毕之后，我们就会看到一个结果反馈，如图：<br><img src="/images/nessus16.png" alt="paradin"> </p><p>具体的颜色代表，在旁边有描述，例子里这些蓝色的info代表没有重大漏洞，点击一下蓝色，还会出现更加详细的信息，包括IP地址、操作系统类型、扫描的起始时间和结束时间：<br><img src="/images/nessus17.png" alt="paradin"> </p><p><img src="/images/nessus18.png" alt="paradin"> </p><p>同时，nessus还支持pdf、web、csv等多种方式汇报扫描结果，至此，整个nessus漏洞扫描的全过程就结束了。</p><h2><span id="nessus配置smtp">Nessus配置smtp</span></h2><p>Nessus漏洞扫描是提供邮件服务，可以将扫描的结果发送给指定的邮箱。配置它的方法很简单，先登陆Nessus的界面，点击左上角的<code>settings</code>，然后选择左侧菜单栏里的<code>Smtp server</code>，如图：<br><img src="/images/nessus19.png" alt="paradin"></p><p>再就是填写对应的项目，我这里发送邮件的地址是：<code>chenx3314@sina.com</code>，接受的地址是<code>124208739@qq.com</code>，由于发送邮件使用的是新浪的邮箱，那么host就填写新浪的smtp服务器，即smtp.sina.com，如果是要SSL加密的话，端口写465，同时在Encryption那里选择<code>Force SSL</code>，在Auth Method那里选择<code>login</code>的鉴权方式，然后输入chenx3314@sina.com的账号密码，如图：<br><img src="/images/nessus20.png" alt="paradin"></p><p>点击<code>Send Test Email</code>，然后输入接收的邮箱，如果是多个邮箱那么就用英文逗号隔开。看到成功的提示就是OK了：<br><img src="/images/nessus21.png" alt="paradin"></p><p>然后就可以到邮箱里面看到那个测试的邮件内容：<br><img src="/images/nessus22.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      传说中最流行的漏洞扫描程序...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="nessus" scheme="http://yoursite.com/tags/nessus/"/>
    
  </entry>
  
  <entry>
    <title>mysql清除磁盘碎片</title>
    <link href="http://yoursite.com/2018/01/23/mysql%E6%B8%85%E9%99%A4%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87/"/>
    <id>http://yoursite.com/2018/01/23/mysql清除磁盘碎片/</id>
    <published>2018-01-23T02:44:23.000Z</published>
    <updated>2018-01-23T06:47:49.775Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="任务背景">任务背景</span></h2><p>接到金山云报警短信，说某数据库的容量已经达到了90%的水位线，于是登陆控制台查看详细情况。</p><p>在控制台首先发现，每一天的磁盘容量的确有所波动，那么就证明开发人员写的“资源回收”模块是在正常运行的，如图：<br><img src="/images/suipian3.png" alt="paradin"></p><p>那么就说明没有什么数据是可以删的，既然删不掉多余的数据又不想多掏钱扩磁盘容量，只能从“磁盘碎片”下手了。而<code>InnoDB</code>引擎清理磁盘碎片的命令就是<code>OPTIMIZE</code>。</p><h2><span id="具体操作">具体操作</span></h2><p>首先我先查询一下所有的“磁盘碎片情况”，使用语句如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select CONCAT(TABLE_SCHEMA,<span class="string">'.'</span>,TABLE_NAME) <span class="keyword">as</span> 数据表名,concat(truncate(sum(DATA_LENGTH+DATA_FREE+INDEX_LENGTH)/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>),<span class="string">' MB'</span>) <span class="keyword">as</span> total_size, concat(truncate(sum(DATA_LENGTH)/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>),<span class="string">' MB'</span>) <span class="keyword">as</span> data_size,concat(truncate(sum(DATA_FREE)/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>),<span class="string">' MB'</span>) <span class="keyword">as</span> data_free, concat(truncate(sum(INDEX_LENGTH)/<span class="number">1024</span>/<span class="number">1024</span>,<span class="number">2</span>),<span class="string">'MB'</span>) <span class="keyword">as</span> index_size <span class="keyword">from</span> information_schema.tables group by TABLE_NAME order by data_length desc;</span><br></pre></td></tr></table></figure></p><p>或者使用<code>select table_schema, table_name, data_free, engine from information_schema.tables where table_schema not in (&#39;information_schema&#39;, &#39;mysql&#39;) and data_free &gt; 0;</code>也可以，这个是查询<code>data_free</code>大于0的所有表。</p><p>然后看到我这个叫<code>history_device_flow_day</code>的表里情况如下：<br><img src="/images/suipian1.png" alt="paradin"></p><p>表里的<code>data_free</code>就是磁盘碎片的量，比如我现在要干掉<code>history_device_flow_day</code>里所有的磁盘碎片，是975MB，于是先查询一下这个<code>history_device_flow_day</code>的存储引擎，使用语句如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show table status <span class="keyword">from</span> jsonlinefssrds where name=<span class="string">'history_device_flow_day'</span>;</span><br></pre></td></tr></table></figure></p><p>上面语句里的<code>jsonlinefssrds</code>是对应的数据库，看到的效果如下：<br><img src="/images/suipian4.png" alt="paradin"></p><p>存储引擎是<code>InnoDB</code>，那么就可以启动清除碎片的语句了：<code>OPTIMIZE TABLE 数据表表名;</code>，因为<code>OPTIMIZE TABLE</code>只对<code>MyISAM</code>、<code>BDB</code>和<code>InnoDB</code>表起作用。</p><p>再执行了<code>OPTIMIZE TABLE history_device_flow_day;</code>之后，大约9分钟，就会看到“OK”的字样：<br><img src="/images/suipian5.png" alt="paradin"></p><p>估计有的朋友会问，那上面不是明明写了“Table does not support optimize, doing recreate + analyze instead”吗？这个其实无妨，实际上磁盘碎片已经被清除掉了。我们可以再用一次查询磁盘碎片的命令看一下，如图：<br><img src="/images/suipian2.png" alt="paradin"></p><p>的确释放了900多M。</p><p>或者使用<code>ALTER TABLE 表名 ENGINE = Innodb;</code>（只是<code>InnoDB</code>的表可以这么做，而且据说这么做更友好）来达到清理磁盘碎片的目的，这个命令表面上看什么也不做,实际上是重新整理碎片了。当执行优化操作时,实际执行的是一个空的<code>ALTER</code>命令,但是这个命令也会起到优化的作用,它会重建整个表,删掉未使用的空白空间。</p><h2><span id="补充">补充</span></h2><p>为什么会产生磁盘碎片？那是因为某一个表如果经常插入数据和删除数据，必然会产生很多未使用的空白空间，这些空白空间就是不连续的碎片，这样久而久之，这个表就会占用很大空间，但实际上表里面的记录数却很少，这样不但会浪费空间，并且查询速度也更慢。</p><p><font color="red">注意！<code>OPTIMIZE</code>操作会暂时锁住表,而且数据量越大,耗费的时间也越长,它毕竟不是简单查询操作。</font>所以把<code>OPTIMIZE</code>命令放在程序中是不妥当的,不管设置的命中率多低,当访问量增大的时候,整体命中率也会上升,这样肯定会对程序的运行效率造成很大影响。比较好的方式就是做个shell,定期检查mysql中 <code>information_schema</code>.<code>TABLES</code>字段,查看<code>DATA_FREE</code>字段,大于0的话,就表示有碎片，然后启动脚本。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://pengbotao.cn/mysql-suipian-youhua.html" target="_blank" rel="noopener">http://pengbotao.cn/mysql-suipian-youhua.html</a><br><a href="http://irfen.me/mysql-data-fragmentation-appear-and-optimization/" target="_blank" rel="noopener">http://irfen.me/mysql-data-fragmentation-appear-and-optimization/</a></p>]]></content>
    
    <summary type="html">
    
      InnoDB使用的Clustered Index,索引和数据绑定在一起,重排序是不现实的。所以不支持MyISAM式的OPTIMIZE,而是绑定到了ALTER TABLE命令上面。可以通过执行以下语句来整理碎片,提高索引速度
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>

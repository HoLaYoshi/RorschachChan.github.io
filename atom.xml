<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-31T06:53:56.820Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jenkins自动构建镜像并且发送钉钉通知</title>
    <link href="http://yoursite.com/2018/08/30/Jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E5%B9%B6%E4%B8%94%E5%8F%91%E9%80%81%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/"/>
    <id>http://yoursite.com/2018/08/30/Jenkins自动构建镜像并且发送钉钉通知/</id>
    <published>2018-08-30T03:39:27.000Z</published>
    <updated>2018-08-31T06:53:56.820Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="部署流程图">部署流程图</span></h2><p>把k8s引入到整个部署的自动化流程如下图：<br><img src="/images/jenkinsdingding2.png" alt="akb48" title="这是宋净超大神的图，侵权则删"></p><p>上图已经说的很明白了，但是结合到我公司的内部情况，再加一点文字的解释：</p><ol><li>运维做一个前端页面，上面提供一些关键词作为变量传入;</li><li>开发将代码上传到svn或者gitlab，进行jira通知，如果是svn的话，jenkins将新代码打包成zip文件，启动jenkins把windows的zip包上传到阿里云云存储上；如果是到gitlab，就不用打包成zip了，直接就把包传到云存储上；</li><li>Gitlab/Svn通过webhook通知jenkins去挂载云存储bucket的文件夹里，并且根据对应的dockerfile进行build成镜像，然后再把镜像推送到云镜像仓库里，推送成功后，Jenkins发送一个钉钉成功的通知；</li><li>Jinkens针对本次镜像和实际部署内容再搭配上之前传递进来的变量，构建一个yaml文件；</li><li>通过create这个yaml文件，启动对应的services来达到用户访问的目的，此时Jenkins再发一条钉钉通知，整个部署流程结束。</li></ol><h2><span id="环境说明">环境说明</span></h2><p>Jenkins:<code>2.124</code>,jenkins与docker在同一台云服务器上，并且确定这个机器上可以顺利login到阿里云的私有仓库<br>云存储:阿里云OSS<br>Gitlab:<code>10.7.3</code><br>镜像仓库:阿里云容器镜像仓库<br>钉钉:<code>4.5.5</code></p><h2><span id="jinkens安装钉钉插件">Jinkens安装钉钉插件</span></h2><p>既然要让jenkins调用钉钉发送成功消息，那么就需要把jenkins跟钉钉结合在一起。至于怎么配自定义钉钉机器人，请看钉钉的官方文档：<a href="https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.karFPe&amp;treeId=257&amp;articleId=105735&amp;docType=1" target="_blank" rel="noopener">https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.karFPe&amp;treeId=257&amp;articleId=105735&amp;docType=1</a> 。而jenkins里也是有官方的钉钉插件，界面<code>系统管理</code>–<code>管理插件</code>，然后搜索“dingding”，安装即可，如图：<br><img src="/images/jenkinsdingding1.png" alt="akb48"></p><p>插件安装完毕之后，重启jenkins即可。</p><h2><span id="挂载阿里云存储">挂载阿里云存储</span></h2><p>阿里云官方挂载云存储的方法是<code>ossfs</code>，登陆到jenkins所在的服务器(centos 7.4)里，步骤如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//github.com/aliyun/ossfs/releases/download/v1.80.5/ossfs_1.80.5_centos7.0_x86_64.rpm</span></span><br><span class="line">yum localinstall ossfs_1.80.5_centos7.0_x86_64.rpm #这一步安装可能会比较慢</span><br><span class="line">echo 需要挂载的bucket名:云存储对应ak:云存储对应sk &gt; /etc/passwd-ossfs#将云存储的ak,sk写入到文件里</span><br><span class="line">chmod <span class="number">640</span> /etc/passwd-ossfs</span><br><span class="line">mkdir /tmp/ossfs#创建挂载文件</span><br><span class="line">ossfs 需要挂载的bucket名 /tmp/ossfs -ourl=http:<span class="comment">//oss-cn-hangzhou-internal.aliyuncs.com#如果不是阿里云就要用外网的endpoint</span></span><br></pre></td></tr></table></figure></p><p>操作的效果如下，我挂载的bucket叫<code>ligentest</code>，毕竟代码是高度机密，bucket属性设置是<code>私有</code>，256T的容量爽爽的：<br><img src="/images/jenkinsdingding3.png" alt="akb48"></p><h2><span id="配置任务">配置任务</span></h2><p>在jenkins里创建一个新的工程，取名叫“构建镜像并且上传到云仓库”。“gitlab更新就触发jenkins”的配置内容可以参考 <a href="https://rorschachchan.github.io/2018/05/25/Gitlab-Jenkins搭建持续集成系统/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/05/25/Gitlab-Jenkins搭建持续集成系统/</a> 一文进行操作。</p><p>配置正确jenkins与gitlab各自的webhook，测试提交能返回200之后。就要配置<code>构建</code>和<code>构建后操作</code>。</p><p><code>构建</code>选择<code>执行shell</code>，里面填写这样一个命令：<code>sudo sh /docker/pushimage.sh</code>，也就是运行一个脚本，脚本内容如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#这个脚本用来推送最新的镜像去阿里云镜像仓库</span><br><span class="line"></span><br><span class="line">version=$(date +20%y%m%d)#用当前日期作为version</span><br><span class="line">image_id=$(docker images | awk '&#123;print $3&#125;' | sed -n '2p')#获取image的id号</span><br><span class="line">docker build -f /docker/chenpyfile -t chentest/python:$version .#先本地构建镜像</span><br><span class="line">docker tag $image_id registry.cn-hangzhou.aliyuncs.com/lechangetest/chentest:$version#给本地的镜像打一个tag</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/lechangetest/chentest:$version#推送到阿里云对应的仓库去</span><br></pre></td></tr></table></figure></p><p><code>构建后操作</code>选择<code>钉钉通知器配置</code>，<code>jenkins URL</code>一栏应该默认填好的，即jenkins的网址；<code>钉钉access token</code>这一栏就是直接填机器人的那个<code>access token</code>，然后选择根据什么情景机器人触发通知，如图：<br><img src="/images/jenkinsdingding4.png" alt="akb48"></p><h2><span id="触发验证">触发验证</span></h2><p>首先要确认jenkins用户能否正常使用docker命令，方法就是修改一下<code>/etc/sudoers</code>添加<code>jenkins</code>这个用户即可。</p><p>这次测试，我们就不搞nginx那种静态页面了，换一个python在后台运行的例子。首先，准备一个叫<code>time.py</code>的脚本，这个脚本很简单，就是不断的输出当前时间的脚本：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">def get_time():</span><br><span class="line">       localtime = time.asctime( time.localtime(time.time()) )</span><br><span class="line">       print ("本地时间为 :", localtime)#python的dockerfile用的是latest，python3是要求有括号的</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">       <span class="keyword">while</span> True:</span><br><span class="line">          get_time()</span><br><span class="line">          time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>对应的dockerfile叫<code>chenpyfile</code>，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">############################################################</span><br><span class="line"># Dockerfile to build A python container images   #</span><br><span class="line"># Based on Python   #</span><br><span class="line">############################################################</span><br><span class="line">FROM    python:latest</span><br><span class="line">MAINTAINER      ChrisChan <span class="string">"Chris@jjfjj.com"</span></span><br><span class="line">RUN     apt-get update &amp;&amp; \</span><br><span class="line">        apt-get install -y vim &amp;&amp; \</span><br><span class="line">        apt-get install -y procps</span><br><span class="line">RUN     mkdir -p /root/app</span><br><span class="line">COPY    /script/ /root/script#把上面那个脚本拷贝到容器里，当然挂载也可以</span><br><span class="line">CMD     ["python", "/root/script/time.py"]#这里不要写“python /root/script/time.py”，注意前后台问题</span><br></pre></td></tr></table></figure></p><p>这个dockerfile在本地测试构建镜像是完全没问题的，然后触发一下<code>git push</code>，就会看到钉钉机器人启动了：<br><img src="/images/jenkinsdingding5.png" alt="akb48"></p><p>构建完毕之后，机器人也会给一个成功的标志，然后去阿里云的云仓库一看，嗯，果然已经推送过来了！如图：<br><img src="/images/jenkinsdingding6.png" alt="akb48"></p><p>至此整个“Jenkins自动构建镜像并且发送钉钉通知”部分就结束了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://jimmysong.io/posts/kubernetes-jenkins-ci-cd/" target="_blank" rel="noopener">https://jimmysong.io/posts/kubernetes-jenkins-ci-cd/</a><br><a href="https://help.aliyun.com/document_detail/32196.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/32196.html</a><br><a href="http://www.cnblogs.com/jianxuanbing/p/7211006.html" target="_blank" rel="noopener">http://www.cnblogs.com/jianxuanbing/p/7211006.html</a></p>]]></content>
    
    <summary type="html">
    
      使用Jenkins进行持续构建与发布应用到kubernetes集群中
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
      <category term="钉钉" scheme="http://yoursite.com/tags/%E9%92%89%E9%92%89/"/>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>K8s的基础操作</title>
    <link href="http://yoursite.com/2018/08/27/K8s%E4%BB%8E%E9%83%A8%E7%BD%B2%E5%88%B0%E6%89%A9%E5%AE%B9/"/>
    <id>http://yoursite.com/2018/08/27/K8s从部署到扩容/</id>
    <published>2018-08-27T06:25:03.000Z</published>
    <updated>2018-08-29T07:14:22.810Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="环境说明">环境说明</span></h2><p>kubenetes:阿里云服务，版本<code>v1.10.4</code>，三个master，一个node，我也不知道为啥阿里云设定master最少是3个，而node最少可以是1个…<br>服务器:阿里云<code>Centos 7.4</code></p><h2><span id="部署服务">部署服务</span></h2><p>首先，我们先部署一个以dockhub最新nginx镜像为底的nginx。命令如下：<code>kubectl run nginx-test --image=nginx:latest --port=80</code>。同理，再部署一个最新版redis的话，就是找葫芦画瓢：<code>kubectl run redis-test --image=redis:latest --port=6379</code>。</p><p>两个命令敲完，这就给k8s下达了一个deployment（部署任务），可用<code>kubectl get deployments</code>和<code>kubectl get pods</code>命令查看：<br><img src="/images/k8s10.png" alt="paradin"></p><p>可以看到现在已经生成了对应的pod，而pod里就是容器了，容器里就是对应的服务。如果想爬进这个容器看一下里面的文件等情况，命令是：<code>kubectl exec -it nginx-test-bb95c4645-7qpbj bash</code>。</p><p>这里插播一下<code>kubectl get deployment</code>里各参数的含义：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DESIRED：对应.spec.replicas，用户设定的期望副本数</span><br><span class="line">CURRENT：对应.status.replicas，目前运行的副本数</span><br><span class="line">UP-TO-DATE:对应.status.updatedReplicas，包含最新的pod template的副本数</span><br><span class="line">AVAILABLE：对应.status.availableReplicas，进入正常状态的副本数</span><br></pre></td></tr></table></figure></p><p>但是现在这个服务是外网无法访问的，因为宿主机还没有一个端口与这个nginx容器的80端口相对应。所以要暴露一个端口给外部用于访问。命令是：<code>kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 80</code>，然后用<code>kubectl get services</code>查看一下效果：<br><img src="/images/k8s11.png" alt="paradin"></p><p>然后在对应的master和node里就看到宿主机随机分配的那个30497端口已经启动了，如图：<br><img src="/images/k8s12.png" alt="paradin"></p><p>在浏览器上访问一下30497端口，果然可以访问到nginx服务：<br><img src="/images/k8s13.png" alt="paradin"></p><h2><span id="扩容服务">扩容服务</span></h2><p>服务嘛，总有高峰低谷。比如微博，突然爆出来哪个娱乐明星的新闻，肯定就会有大量的流量涌入，此时就需要扩容，那么k8s的扩容很简单，就是pod的复制，如果要把上面那个nginx-test的部署任务进行扩展，命令就是<code>kubectl scale deployments/nginx-test  --replicas=4</code>，如图：<br><img src="/images/k8s14.png" alt="paradin"></p><p>可见nginx-test又生成了三个pod，与原来的组成了4个pod，而另一个redis的部署任务是没有变化的。</p><p>用<code>kubectl get pods -o wide</code>可见，每一个pod分配到了不同的虚拟IP上，而且node都是阿里云的那台node服务器。<br><img src="/images/k8s15.png" alt="paradin"></p><p>在阿里云控制台也能看到里面的情况：<br><img src="/images/k8s16.png" alt="paradin"></p><p>此时进入到node节点，<code>docker ps -a</code>就会看到新的nginx景象生成，同时也生成了三个<code>/pause</code>的容器：<br><img src="/images/k8s17.png" alt="paradin"></p><p>kubernetes中的pause容器主要为每个业务容器提供以下功能：</p><ol><li>在pod中担任Linux命名空间共享的基础；</li><li>启用pid命名空间，开启init进程。</li></ol><p><font color="red">注意！目前kubernetes似乎仅仅支持共享网络，还不支持进程体系、文件系统之间的共享。</font>如果此时在访问，就会看到访问会相对均匀的落到这四个pod中的每一个，起到一个负载均衡的作用。如果高峰期过了，不需要那么多pod了，就<code>kubectl scale deployments/nginx-test  --replicas=1</code>，pod就会恢复成1个，据我几次试验，每次都是保留最老的那一个pod。</p><h2><span id="yaml文件创建一个pod">yaml文件创建一个pod</span></h2><p>K8s的yaml文件的文法和规矩，官方社区就有教程：<a href="https://www.kubernetes.org.cn/1414.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/1414.html</a> 。但是如果要搭配阿里云的私有镜像，需要先参考一下阿里云文档：<a href="https://help.aliyun.com/document_detail/86562.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/86562.html</a> 。<font color="red">注意，这个方法不能在命令行里使用，只能在yaml或者json里用。</font>这里先写一个简单的nginx配置文件<code>pod-nginx.yaml</code>做例子，全文如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: aliyun-nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Always         #表明该容器一直运行，默认k8s的策略，在此容器退出后，会立即创建一个相同的容器</span><br><span class="line">  nodeSelector:  </span><br><span class="line">   zone: node1#节点选择</span><br><span class="line">  containers:</span><br><span class="line">  - name: aliyun-test-nginx</span><br><span class="line">    image: registry-vpc.cn-hangzhou.aliyuncs.com/lechangetest/chentest:<span class="number">1.1</span></span><br><span class="line">    imagePullPolicy: IfNotPresent      #可选择Always、Never、IfNotPresent，即每次启动时检查和更新images的策略，IfNotPresent是节点上没有此nginx镜像时才执行pull操作</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80       #容器开发对外的端口</span><br><span class="line">      hostPort: 33664            #映射到主机的端口/对外映射的端口（一般可以不写）</span><br><span class="line">  imagePullSecrets:</span><br><span class="line">    - name: regsecret#这句话为了通过阿里云似有仓库的鉴权</span><br></pre></td></tr></table></figure></p><p>保存退出，再<code>kubectl create -f pod-redis.yaml</code>把这个文件执行一下。然后<code>kubectl get pod</code>看一下效果：<br><img src="/images/k8s18.png" alt="paradin"></p><p>发现我们创建那个redis-pod状态是<code>Pending</code>（等待中），那就是不成功啊。于是就<code>kubectl describe pod/pod-redis</code>查看一下原因，反馈如下：<br><img src="/images/k8s19.png" alt="paradin"></p><p>这个错误的意思是“如果指定的label在所有node上都无法匹配，则创建Pod失败”。原来是我没有配置<code>kubectl label nodes</code>，那先把<code>pod-redis</code>删除，再把<code>nodeSelector</code>那一段去掉，改成<code>nodeName: cn-hangzhou.i-bp1978gmunq3oalfcqlx</code>，去掉再重新create一下。<code>kubectl get pod</code>检查：<br><img src="/images/k8s20.png" alt="paradin"></p><p>然后就是给这个pod增加一个对外的端口。<code>kubectl expose pod/aliyun-nginx --type=&quot;NodePort&quot; --port 80</code>，效果如下：<br><img src="/images/k8s21.png" alt="paradin"></p><p>再去浏览器里，输入<code>node的外网网址：31829</code>看看效果：<br><img src="/images/k8s22.png" alt="paradin"></p><p>配置成功，当然这整个过程也可以在阿里云的控制台操作，更简单更直观，而且阿里云还会自动把对外端口配置到SLB里，具体步骤可以看阿里云的官方文档。</p><h2><span id="升级与回滚">升级与回滚</span></h2><p>假设我们把<code>nginx-test</code>这个deployment的镜像升级成阿里云私有仓库的1.1版本，那么命令是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployments/nginx-test nginx-test=registry.cn-hangzhou.aliyuncs.com/lechangetest/chentest:<span class="number">1.1</span></span><br></pre></td></tr></table></figure></p><p>升级之后，<code>kubectl get pod</code>发现有几个节点不正常，如图：<br><img src="/images/k8s23.png" alt="paradin"></p><p>那么这种情况下需要紧急回滚，回滚命令：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-test</span><br></pre></td></tr></table></figure></p><p>一会就看到回滚成功了。如图：<br><img src="/images/k8s24.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://jimmysong.io/posts/what-is-a-pause-container/" target="_blank" rel="noopener">https://jimmysong.io/posts/what-is-a-pause-container/</a><br><a href="https://blog.csdn.net/mailjoin/article/details/79686937" target="_blank" rel="noopener">https://blog.csdn.net/mailjoin/article/details/79686937</a><br><a href="http://pipul.org/2016/05/why-we-need-the-pod-and-service-of-kubernetes/" target="_blank" rel="noopener">http://pipul.org/2016/05/why-we-need-the-pod-and-service-of-kubernetes/</a><br><a href="https://www.imooc.com/article/30473" target="_blank" rel="noopener">https://www.imooc.com/article/30473</a></p>]]></content>
    
    <summary type="html">
    
      基础笔记，基础笔记而已...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="kubenetes" scheme="http://yoursite.com/tags/kubenetes/"/>
    
  </entry>
  
  <entry>
    <title>Centos6.5升级最新内核4.18的坑</title>
    <link href="http://yoursite.com/2018/08/25/centos6-5%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%E5%86%85%E6%A0%B84-18%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2018/08/25/centos6-5升级最新内核4-18的坑/</id>
    <published>2018-08-25T03:34:59.000Z</published>
    <updated>2018-08-25T06:28:36.794Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="升级流程">升级流程</span></h2><p>开发童鞋要搞BBR，然后让我在他的阿里云服务器上升级一下内核。我登进去一看，centos 6.5，内核还是2.6的。</p><p>之前我曾经搞过centos 7升级内核到最新版，文章在此：<a href="https://rorschachchan.github.io/2018/06/11/阿里云centos7升级内核过程/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/06/11/阿里云centos7升级内核过程/</a> 。centos6升级内核有几个地方不太一样，但是过程差不多。整个升级内核步骤如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先备份镜像，很重要！！！  而且备份镜像成功之前，云服务器不可以重启。</span><br><span class="line">yum uodate -y</span><br><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org #导入ELRepo GPG key</span><br><span class="line">rpm -Uvh https://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm #安装 6版本的ELRepo</span><br><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml -y#截至本文，最新的是4.18，lt版本是4.4</span><br></pre></td></tr></table></figure></p><p>如果yum的时候有提示<code>Warning: RPMDB altered outside of yum</code>，只需要删除一下yum的历史记录即可：<code>rm -rf /var/lib/yum/history/*.sqlite</code> 。 </p><p>安装完毕之后，<code>vim /etc/grub.conf</code>，把default改成0，即指定使用第一个内核启动，如图：<br><img src="/images/centos6updatecore1.png" alt="akb48"></p><p>然后在阿里云控制台重启一下这个服务器即可。</p><h2><span id="无法启动">无法启动？</span></h2><p>可能有的人直接就启动成功了，因为网络上很多文章到此就结束了。但是我这台服务器，很不幸，出现了问题。在控制台上看服务器是“运行中”，但是无法ssh连接，而且ping也是失败。不一会，控制台的服务器就显示“已停止”，可见是内核出了问题。</p><p>联系了阿里的后台，他们反馈这个机器现在的状态是<code>Module scsi_wait_scan not found</code>，那知道了原因就对症下药吧，这个问题解决方法不止一个，我亲测以下的方法好使。</p><p>首先先用刚刚做的那个磁盘快照回滚到之前正常的状态，重新执行上面整个安装4.18的内核的所有操作，然后还要补充如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'add_drivers+="virtio_blk"'</span> &gt;<span class="regexp">/etc/</span>dracut.conf.d/force-vitio_blk-to-ensure-boot.conf</span><br><span class="line">cp /boot/initramfs-4.18.5-1.el6.elrepo.x86_64.img /boot/initramfs-4.18.5-1.el6.elrepo.x86_64.img-bak#把新下载的4.18的img文件备份</span><br><span class="line">dracut -f initramfs-4.18.5-1.el6.elrepo.x86_64.img 4.18.5-1.el6.elrepo.x86_64#编译生成新的img，4.18.5-1.el6.elrepo.x86_64这个文件在/lib/modules/下</span><br></pre></td></tr></table></figure></p><p>重新在阿里云控制台重启一下这个服务器，这一次就OK了。<br><img src="/images/centos6updatecore2.png" alt="akb48"></p><p>发生异常的原因是：更新内核后,在写dracut程序时无法检测<code>KVM&#39;s virtual disk driver &quot;virtio_blk&quot;</code>，此驱动被用于访问KVM虚拟磁盘,dracut没有正常添加新的<code>initramfs module</code>,导致系统没有磁盘访问驱动无法正常启动。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://bugzilla.kernel.org/show_bug.cgi?id=60758" target="_blank" rel="noopener">https://bugzilla.kernel.org/show_bug.cgi?id=60758</a><br><a href="https://opengers.github.io/linux/linux-source-code-compile-kernel-rpm/" target="_blank" rel="noopener">https://opengers.github.io/linux/linux-source-code-compile-kernel-rpm/</a></p>]]></content>
    
    <summary type="html">
    
      修改/usr/share/dracut/modules.d/90kernel-modules/installkernel把blk_init_queue修改为blk_mq_init_queue，然后重新rpm -ivh也可以
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="内核" scheme="http://yoursite.com/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="BBR" scheme="http://yoursite.com/tags/BBR/"/>
    
  </entry>
  
  <entry>
    <title>Kubectl使用的简单举例</title>
    <link href="http://yoursite.com/2018/08/22/%E5%AE%89%E8%A3%85%E5%B9%B6%E4%B8%94%E9%85%8D%E7%BD%AEkubectl/"/>
    <id>http://yoursite.com/2018/08/22/安装并且配置kubectl/</id>
    <published>2018-08-22T08:39:41.000Z</published>
    <updated>2018-08-24T07:59:33.360Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装kubectl">安装kubectl</span></h2><p>在阿里云的Kubernetes界面生成一个新的集群，如图：<br><img src="/images/k8s1.png" alt="akb48"></p><p>但是这个集群是无法通过ssh登陆云服务器那样登录的，这个时候要操作k8s就有两个招数，第一个招数就是用<code>kubectl</code>这个工具去连接到集群。但是<code>kubectl</code>很难搞，因为它所在的<code>storage.googleapis.com</code>在大陆是无法访问的，如果效仿<a href="https://www.kubernetes.org.cn/installkubectl" target="_blank" rel="noopener">https://www.kubernetes.org.cn/installkubectl</a> 里面的方式去下载<code>kubectl</code>是无法成功的，如图：<br><img src="/images/k8s2.png" alt="akb48"></p><p>为了应付这个办法，就要去kubernete的github界面里下载代码包，然后手动上传到云服务器里安装。</p><p>首先到<a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.11.md#v1112" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.11.md#v1112</a> 里的<code>Client Binaries</code>下载1.11版本的kubectl的包，如图：<br><img src="/images/k8s3.png" alt="akb48"></p><p>将这个包上传到云服务器之后解压缩，然后把kubernetes安装包里的<code>/client/bin/kubectl</code>做一个<code>/usr/local/bin/kubectl</code>的软连接，如图：<br><img src="/images/k8s4.png" alt="akb48"></p><p>如果所在的网络也无法打开github，那么只好用国内的源<a href="https://mirrors.ustc.edu.cn/kubernetes/apt/pool/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/kubernetes/apt/pool/</a> ，下载相应的包之后手动上传到云服务器里也能达到一样的效果，缺点就是国内源没有github更新的那么快。</p><h2><span id="配置kubectl">配置kubectl</span></h2><p>阿里云在生成kubernetes集群后，点击<code>管理</code>，最下面会有一个配置文件，将整个文件内容写入<code>/root/.kube/config</code>，然后再一次使用<code>kubectl cluster-info</code>就能看到配置成功了，如图：<br><img src="/images/k8s5.png" alt="akb48"></p><p>再用<code>kubectl config view</code>能进一步看到细节：<br><img src="/images/k8s6.png" alt="akb48"></p><p>这样就证明可以通过kubectl连接到kubenetes集群了。</p><h2><span id="kubectl基本操作">kubectl基本操作</span></h2><ol><li><p><code>kubectl get nodes</code>：查看master和worker的基本情况，如图：<br><img src="/images/k8s7.png" alt="akb48" title="这里面有各个节点的角色、命名、版本和状态"></p></li><li><p><code>kubectl run ngx-test --image=nginx:latest --port=8080 --restart=Never</code>：部署一个以nginx最新镜像为底的叫<code>ngx-test</code>的部署，并且开放下面容器的8080端口，每个部署的名称不能重复。部署会自动生成pod，如果加上了<code>--restart=Never</code>，那么pod生成一次失败就不再生成；</p></li><li><p><code>kubectl delete deployment chen-test</code>:删除一个叫<code>chen-test</code>的部署，注意，使用kubectl命令，要删除拥有该pod的Deployment。如果我们直接删除pod，Deployment将会重新创建该pod；</p></li><li><p><code>kubectl get deployments</code>：查看部署情况，如图：<br><img src="/images/k8s8.png" alt="akb48"></p></li><li><p><code>kubectl proxy</code>: 每个pod在kuber集群里都是一个封闭的网络环境里，可以通过这个命令使API server监听在本地的8001端口上；</p></li><li><p><code>kubectl get pods</code>：获取每一个pods的基本情况，如图:<br><img src="/images/k8s9.png" alt="akb48"></p></li><li><p><code>kubectl describe pods</code>:查看每一个pods的运行细节，可以出来为什么pods没有正常的运行，如果要特别制定具体的pod，那就是<code>kubectl describe pods pod的名称</code>；</p></li><li><p><code>kubectl exec -it POD_NAME bash</code>:连接到对应的pod里；</p></li></ol><h2><span id="参考资料">参考资料</span></h2><p><a href="https://help.aliyun.com/document_detail/64940.html?spm=a2c4g.11186623.4.1.2c4652f3qdpMed" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/64940.html?spm=a2c4g.11186623.4.1.2c4652f3qdpMed</a> （这个是通过ssh访问k8s负载均衡的方法）<br><a href="https://kubernetes.io/cn/docs/tutorials/kubernetes-basics/" target="_blank" rel="noopener">https://kubernetes.io/cn/docs/tutorials/kubernetes-basics/</a></p>]]></content>
    
    <summary type="html">
    
      k8s集群有多个部署，每个部署里有多个pod，而每个pod里有多个容器。当我们在Kubernetes上创建一个部署时，该部署将在其中创建包含容器的Pod(而不是直接创建容器)。Pod 总是运行在Node上。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>使用gitlab搭配阿里云容器镜像服务构建镜像</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BD%BF%E7%94%A8gitlab%E6%90%AD%E9%85%8D%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
    <id>http://yoursite.com/2018/08/15/使用gitlab搭配阿里云容器镜像服务构建镜像/</id>
    <published>2018-08-15T02:15:44.000Z</published>
    <updated>2018-08-23T06:42:54.142Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="工作思路">工作思路</span></h2><p>本次北京AWS技术峰会里看到了很多公司在运维上使用容器部署和扩容的实例，一天下来感受良多。现在比较流行部署办法就是“云镜像”：<strong>即开发把新的代码提交到gitlab上，然后gitlab与云厂家的镜像服务相关联，然后每一次commit提交都会触发一次镜像的构建，然后再根据这个镜像部署到实际的服务器里，同时将此服务器作一个快照，同时再搭配上容器监控，如果服务吃紧，就用此快照购买实例扩容；如果服务闲余，那么也会自动将最老的服务器实例关机，进而释放退款。</strong></p><p>用图像来说就是这个意思：<br><img src="/images/aliyungitlab7.png" alt="paradin" title="也可以gitlab触发jenkins，用jenkins构建镜像并且把镜像推送到阿里云容器仓库去"></p><h2><span id="勾连gitlab与云镜像">勾连gitlab与云镜像</span></h2><p>本文使用的镜像厂家是阿里云，gitlab版本是<code>10.7.3</code>。</p><p>进入阿里云的“容器镜像”页面，如果你是第一次使用这个产品需要先建立一个仓库密码，然后点击左侧的代码源，如图：<br><img src="/images/aliyungitlab1.png" alt="paradin"></p><p>在gitlab地方选择“绑定账号”，就需要填写对应的栏目：<br><img src="/images/aliyungitlab2.png" alt="paradin"></p><p>前两项很好写，最后一个token需要在gitlab里创建：在gitlab的页面，点击个人的头像，然后<code>settings</code>—<code>Access Tokens</code>，填写好名字（生产环境一般都是填运维的账号）然后在<code>api</code>处打勾，生成的那个东东就是token，直接复制填写到阿里云的页面即可。如图：<br><img src="/images/aliyungitlab3.png" alt="paradin"></p><h2><span id="配置镜像仓库">配置镜像仓库</span></h2><p>在阿里云容器镜像界面点击“创建镜像仓库”，填写好名字摘要仓库类型之后，在代码源里选择gitlab，由于刚刚填写了token所以是可以看得到gitlab用户下所有的project名的，如图：<br><img src="/images/aliyungitlab4.png" alt="paradin"></p><p>然后点击新创建的那个仓库，在构建一栏默认已经选择好了“代码变更时自动构建镜像”，点击“添加规则”，如图：<br><img src="/images/aliyungitlab5.png" alt="paradin"></p><p>这里我选择了master分支，然后指明了dockerfile文件名和路径，最后版本号就先写一个version，这个可以通过gitlab在commit时特殊指定。</p><p>右侧栏里的Webhook是用来发送提示的，可以在钉钉里创建一个机器人，在创建机器人时会生成webhook，然后把机器人的webhook添加到这个webhook即可。如果在添加的时候提示“当前请求失败，请重试”，这个情况是因为Webhook的名称里有中文，要全英文才可以。<br><img src="/images/aliyungitlab8.png" alt="paradin"></p><h2><span id="编写dockerfile">编写dockerfile</span></h2><p>如果没有dockerfile是无法构建镜像的，于是就在上面“规则”的目录里创建对应的dockerfile文件，<font color="red">注意!“规则”里的根目录就是代码文件夹的顶目录，而不是整个服务器的根目录</font>。写dockerfile的基础知识和语法这里不多说了，网络上有的是，我就随便写一个nginx dockerfile，内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">############################################################</span><br><span class="line"># Dockerfile to build Nginx container images</span><br><span class="line"># Based on Debian</span><br><span class="line">############################################################</span><br><span class="line">FROM    debian:latest</span><br><span class="line">MAINTAINER      ChrisChan <span class="string">"Chris@jjfjj.com"</span></span><br><span class="line">RUN     apt-get update</span><br><span class="line">RUN     apt-get install -y nginx</span><br><span class="line">RUN     apt-get install -y vim</span><br><span class="line">RUN     apt-get install -y procps#安装ps命令</span><br><span class="line">RUN     echo <span class="string">'HI!WARRIOR is the champion!!!'</span> &gt; <span class="regexp">/var/</span>www/html/index.nginx-debian.html</span><br><span class="line">EXPOSE  8080#开放8080端口</span><br><span class="line">COPY    /file/kubernetes.tar.gz /mnt/</span><br><span class="line">#CMD    service nginx start &amp;&amp; nginx -g "daemon off;"</span><br><span class="line">ENTRYPOINT [ <span class="string">"/usr/sbin/nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span> ]</span><br></pre></td></tr></table></figure></p><p><font color="red">注意！使用上面注释的CMD语句作为结尾的话，那么这个镜像docker run的时候就会马上退出，这是因为把command做为容器内部命令，那么nginx程序将后台运行，这个时候nginx并不是pid为1的程序，而是执行的bash，这个bash执行了nginx指令后就挂了，所以容器也就退出了。</font>简而言之，Docker容器后台运行,就必须有一个前台进程。因为Docker容器仅在它的1号进程（PID为1）运行时，会保持运行。如果1号进程退出了，Docker容器也就退出了。</p><p>在gitlab触发之后，阿里云就自动把这个dockerfile build成了镜像保存在阿里云的容器仓库里，如图：<br><img src="/images/aliyungitlab6.png" alt="paradin"></p><p>想用这个镜像就可以直接去阿里云的仓库里下载并启动，这样就节省了本地的硬盘容量。最后就是把这个镜像部署到对应的kubernetes集群里，这样就完成了“gitlab代码提交触发阿里云构建镜像”的过程，而如何使用kubernetes的内容将在以后细说。</p>]]></content>
    
    <summary type="html">
    
      出去参加交流才发现，我们的运维简直就是手工作坊...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="docker镜像" scheme="http://yoursite.com/tags/docker%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>阿里云Centos7开启swap虚拟内存</title>
    <link href="http://yoursite.com/2018/08/13/%E9%98%BF%E9%87%8C%E4%BA%91Centos7%E5%BC%80%E5%90%AFswap%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2018/08/13/阿里云Centos7开启swap虚拟内存/</id>
    <published>2018-08-13T03:21:27.000Z</published>
    <updated>2018-08-13T06:27:39.627Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>出差归来，几个开发反馈说gitlab网页卡的不行，上传代码也非常吃力。我登入服务器一看，原来是内存已经耗尽了。</p><h2><span id="修改配置文件">修改配置文件</span></h2><p>gitlab本身就是一个特别吃内存的软件，服务器还是2核4G的配置。于是我就登陆到gitlab容器里，修改一下<code>/etc/gitlab/gitlab.rb</code>，把<code>unicorn[&#39;worker_processes&#39;]</code>手动改成了3，也就是比CPU大一个，这样可以少开一点进程。但是注意，这个参数最小值是2，如果设置成1，那么gitlab就会崩坏。</p><p>保存文件之后，<code>gitlab-ctl reconfigure</code>，看一下内存的情况，嗯，比刚才好一点点。如图：<br><img src="/images/swap1.png" alt="paradin"></p><h2><span id="开启虚拟内存">开启虚拟内存</span></h2><p>上面那个方法毕竟效果有限，时间长了还是会把内存一点点蚕食光，于是就要使用Swap分区，但是阿里云虚拟服务器默认是不带swap分区的，如何手动创建swap分区才是本文的要点。</p><p>这里我用了一个非生产环境的机器做实验。</p><p>创建swap分区主要的中心思想就是“创建一个文件，然后将这块文件格式化为swap格式”，首先先看一下当前的磁盘容量：<br><img src="/images/swap2.png" alt="paradin"></p><p>当前已用磁盘容量是16G，使用<code>cat /proc/swaps</code>看一下当前虚拟内存的情况：<br><img src="/images/swap3.png" alt="paradin"></p><p>这个情况说明没开启swap，于是就手动建立一个文件夹，比如叫/swaps，在/swaps这个路径下执行<code>dd if=/dev/zero of=swaps bs=512 count=8388616</code>，在这里创建swap大小为bs*count=4294971392(4G)，这个过程需要一点时间，稍等片刻：<br><img src="/images/swap4.png" alt="paradin"></p><p>通过<code>mkswap swaps</code>命令将上面新建出的swaps文件做成swap分区：<br><img src="/images/swap5.png" alt="paradin"></p><p>此时使用<code>cat /proc/sys/vm/swappiness</code>查看数值应该是0，需要<code>sysctl -w vm.swappiness=60</code>把它改成60，这里60的含义是：100%-60%=40%，即物理内存剩下40%的时候时启用虚拟内存。若想永久修改，则编辑<code>/etc/sysctl.conf</code>文件，改文件中有<code>vm.swappiness</code>变量配置。</p><p>再<code>swapon /swaps/swaps</code>：<br><img src="/images/swap6.png" alt="paradin"></p><p>最后就是添加开机自动挂载，即在<code>/etc/fstab</code>文件添加如下一句：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swaps/swaps  swap      swap    defaults   <span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>再用<code>cat /proc/swaps</code>命令检查一下swap分区是否启动：<br><img src="/images/swap7.png" alt="paradin"></p><p>最后，重启一下服务器，看一下开机是否正常挂载上这个虚拟分区了：<br><img src="/images/swap8.png" alt="paradin"></p><p>可见原来使用了16G容量，现在用了20G，这中间差的4G就是拿来做了swap，于是内存就这样多了4个G…</p>]]></content>
    
    <summary type="html">
    
      不想掏内存钱，那就把磁盘改造成内存吧...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
      <category term="虚拟内存" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="阿里云服务器" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>爬取当前IP并且修改阿里云安全组的脚本</title>
    <link href="http://yoursite.com/2018/08/07/%E7%88%AC%E5%8F%96%E5%BD%93%E5%89%8DIP%E5%B9%B6%E4%B8%94%E4%BF%AE%E6%94%B9%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E5%85%A8%E7%BB%84%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/08/07/爬取当前IP并且修改阿里云安全组的脚本/</id>
    <published>2018-08-07T07:01:07.000Z</published>
    <updated>2018-08-07T09:20:23.200Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="动机与脚本">动机与脚本</span></h2><p>我工位所用的网络是公司特批的海外专线，速度OK还能翻墙出去看看，自从有了这条线爽的飞起，但缺陷就是每周IP地址都会变，IP一变很多的阿里云ecs安全组就要重新配置，因为有一些公网端口比如grafana或者跳板机是只能公司运维人员访问的。这样每周都要手动改一次IP地址太烦了，于是乎，写了下面这个脚本，一劳永逸的解决这个问题：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本在python3.6下自验通过，用途是去爬当前的IP地址然后给阿里云安全组添加新的IP，并且删除掉老的IP</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> AuthorizeSecurityGroupRequest</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> RevokeSecurityGroupRequest</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.profile <span class="keyword">import</span> region_provider</span><br><span class="line"><span class="keyword">import</span> requests,sys,re,os</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient('这里是AK', '这里是SK', 'cn-hangzhou')#鉴权</span><br><span class="line">file = <span class="string">"F:\\ip.txt"</span></span><br><span class="line"></span><br><span class="line">def checkDIR():</span><br><span class="line">    global file</span><br><span class="line">    if os.path.exists(file) == True:#先判断文件是否存在</span><br><span class="line">        <span class="keyword">with</span> open(file, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            old_ip = f.read()</span><br><span class="line">            return (old_ip)#获取旧ip</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"ip.txt文件不存在，请手动生成！"</span>)</span><br><span class="line">        sys.exit()#文件不存在直接退出</span><br><span class="line"></span><br><span class="line">def getIP():</span><br><span class="line">    global file</span><br><span class="line">    r = requests.get('http://www.ip111.cn/')        #这里输入要爬的网站域名</span><br><span class="line">    soup = BeautifulSoup(r.text, <span class="string">"lxml"</span>)</span><br><span class="line">    context = []</span><br><span class="line">    for link in soup.find_all('td'):    #获取所有td标签内容</span><br><span class="line">        context.append(link.get_text())     #添加一个列里</span><br><span class="line">    str = context[<span class="number">4</span>]</span><br><span class="line">    ip = re.split(r'[\n\s]\s*', str)[1]#多符号分割字符串</span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(ip)</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line">def addnewRULE(func):</span><br><span class="line">    global clt</span><br><span class="line">    # 设置参数</span><br><span class="line">    for port in ['3000/3000', '34872/34872']:#这里是端口</span><br><span class="line">        request = AuthorizeSecurityGroupRequest.AuthorizeSecurityGroupRequest()</span><br><span class="line">        request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line">        request.add_query_param(<span class="string">'RegionId'</span>, <span class="string">'cn-hangzhou'</span>)</span><br><span class="line">        request.add_query_param(<span class="string">'SecurityGroupId'</span>, <span class="string">'目标安全组ID'</span>)</span><br><span class="line">        request.add_query_param(<span class="string">'IpProtocol'</span>, <span class="string">'tcp'</span>)</span><br><span class="line">        request.add_query_param(<span class="string">'PortRange'</span>, port)</span><br><span class="line">        request.add_query_param(<span class="string">'SourceCidrIp'</span>,func())</span><br><span class="line">        request.add_query_param('NicType', 'intranet')      #如果不加这句话就是公网添加</span><br><span class="line">        <span class="keyword">if</span> port == <span class="string">'3000/3000'</span>:</span><br><span class="line">            request.add_query_param(<span class="string">'Description'</span>, <span class="string">'Grafana使用端口'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            request.add_query_param(<span class="string">'Description'</span>, <span class="string">'Zabbix和堡垒机使用端口'</span>)</span><br><span class="line">        # 发起请求</span><br><span class="line">        response = clt.do_action(request)</span><br><span class="line">        print (response)</span><br><span class="line"></span><br><span class="line">def deloldRULE(func):</span><br><span class="line">    global clt</span><br><span class="line">    # 设置参数</span><br><span class="line">    <span class="keyword">for</span> port <span class="keyword">in</span> [<span class="string">'3000/3000'</span>,<span class="string">'34872/34872'</span>]:</span><br><span class="line">        request = RevokeSecurityGroupRequest.RevokeSecurityGroupRequest()</span><br><span class="line">        request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line">        request.add_query_param(<span class="string">'RegionId'</span>, <span class="string">'cn-hangzhou'</span>)</span><br><span class="line">        request.add_query_param(<span class="string">'SecurityGroupId'</span>, <span class="string">'目标安全组ID'</span>)</span><br><span class="line">        request.add_query_param(<span class="string">'IpProtocol'</span>, <span class="string">'tcp'</span>)</span><br><span class="line">        request.add_query_param(<span class="string">'PortRange'</span>, port)</span><br><span class="line">        request.add_query_param(<span class="string">'SourceCidrIp'</span>, func())</span><br><span class="line">        request.add_query_param('NicType', 'intranet')      #如果不加这句话就是公网删除</span><br><span class="line">        # 发起请求</span><br><span class="line">        response = clt.do_action(request)</span><br><span class="line">        print (response)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    checkDIR()</span><br><span class="line">    deloldRULE(checkDIR)</span><br><span class="line">    getIP()</span><br><span class="line">    addnewRULE(getIP)</span><br></pre></td></tr></table></figure></p><p>整个脚本的逻辑就是先在F盘下有<code>ip.txt</code>里面就保存当前IP地址，然后执行脚本的时候就会先在目标安全组里删除掉这个IP相关的3000端口和34872端口，然后去<code>www.ip111.cn</code>里爬取当前的网址，把新IP写入到<code>ip.txt</code>的同时，再去目标安全组里添加这个新IP相关的3000端口和34872端口。</p><h2><span id="新的知识点">新的知识点</span></h2><ol><li><p>把上一个函数结果当作参数在下一个函数里执行的方法：<br><img src="/images/func1.png" alt="akb48"></p></li><li><p>python的退出有两个：<code>os._exit()</code>和<code>sys.exit()</code>：<code>os._exit()</code>会直接将python程序终止，之后的所有代码都不会执行；<code>sys.exit()</code>会抛出一个异常: <code>SystemExit</code>，如果这个异常没有被捕获，那么python解释器将会退出。如果有捕获该异常的代码，那么这些代码还是会执行。使用<code>sys.exit()</code>来退出程序比较优雅，一般情况下也用这个，<code>os._exit()</code>可以在<code>os.fork()</code>产生的子进程里使用。</p></li><li>在windows里定时执行python脚本的方法：<br>打开<code>控制面板</code>—&gt;<code>系统和安全</code>—&gt;<code>计划任务。</code>如图：<br><img src="/images/func2.png" alt="akb48"></li></ol><p>点击右侧的<code>创建基本任务</code>，输入任务名称和可选的描述。点击<code>下一步</code>，设置任务的开始时间，可以选择每日执行、每周执行或每月执行。点击<code>下一步</code>，<code>操作</code>选择<code>启动程序</code>，点击下一步输入参数。如图：<br><img src="/images/func3.png" alt="akb48"><br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序或脚本：python.exe  </span><br><span class="line">添加参数：输入要执行的python脚本路径（包括文件名）</span><br><span class="line">起始于：输入python.exe的目录（不包括文件名）</span><br></pre></td></tr></table></figure></p><p>最后点击<code>下一步</code>，整个过程搞定。</p>]]></content>
    
    <summary type="html">
    
      AWS北京技术峰会，我来啦！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="python3.6" scheme="http://yoursite.com/tags/python3-6/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>获取网站title的脚本</title>
    <link href="http://yoursite.com/2018/07/31/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%AB%99title%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/07/31/获取网站title的脚本/</id>
    <published>2018-07-31T07:48:40.000Z</published>
    <updated>2018-08-13T07:13:24.623Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="脚本在此">脚本在此</span></h2><p>公司的商城需要添加一个脚本，这个脚本就是观察首页页面是否正常，虽然已经配置了zabbix监控网站是否200，但是有一些特殊的情况，比如网页可以打开但是页面是“file not found”，类似这样就需要被运维第一时间监控到然后通知开发。</p><p>原本我打算直接爬取整个首页然后与服务器里的<code>index.html</code>对比一下，如果不符合就报警，但是跟前端同事说了这个思路之后，前端说服务器上是没有<code>index.html</code>的，因为这个<code>index.html</code>是结合其他的php拼接的。前端说“只要能检测title正常就OK，一般来说title能获取到就证明系统是OK的，如果titleOK但是html内容获取不到就是前段代码的问题，跟系统无关”。于是我就写了这么一个爬虫脚本来获取网站title，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本的用途是用来爬取商城首页title，然后判断是否正常</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests,sys</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding('utf-8')#不然就会UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-4: ordinal not in range(128)</span><br><span class="line">r = requests.get('https://www.lechange.com')#这里输入要爬的网站域名</span><br><span class="line">r.encoding = requests.utils.get_encodings_from_content(r.content)[<span class="number">0</span>]</span><br><span class="line">soup = BeautifulSoup(r.text,'lxml')#这一步需要事前pip install lxml</span><br><span class="line">print soup.title.string</span><br></pre></td></tr></table></figure></p><p>说一下，如果在<code>from bs4 import BeautifulSoup</code>爆出<code>ImportError: No module named &#39;bs4&#39;</code>是因为安装的库装错了，应该是<code>pip install beautifulsoup4</code>而不是<code>pip install beautifulsoup</code>。启动脚本效果如下：<br><img src="/images/spider1.png" alt="paradin"></p><h2><span id="编码问题">编码问题</span></h2><p>上面那个脚本里的<code>soup.title.string</code>的类型是<code>bs4.element.NavigableString</code>，如果不用print那么它的形式是<code>unicode</code>的，如图：<br><img src="/images/spider2.png" alt="paradin"></p><p>这种现象并不新鲜，比如<code>list</code>在python2里一直都不是正常输出中文的，如图：<br><img src="/images/spider3.png" alt="paradin"></p><p>可见只有<code>for in</code>的时候才会正常编码，那么这样的情况怎么办？</p><p>最简单的方法，改用python3。不过上面那个脚本是可以直接把中文放到<code>soup.title.string</code>进行判断的。</p><h2><span id="安装python-364">安装python 3.6.4</span></h2><p>首先要先安装相关依赖包<code>yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</code>，其中<code>readline-devel</code>这个很重要，他是管方向键的，如果python运行的时候方向键不好使，那么就要<code>yum install readline-devel</code>安装，安装完毕后重新<code>configure</code>和<code>make</code>。</p><p>然后过程如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release#运行这个命令添加epel扩展源</span><br><span class="line">#安装pip</span><br><span class="line">yum install python-pip</span><br><span class="line">pip install wget</span><br><span class="line">wget https:<span class="comment">//www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz</span></span><br><span class="line">#解压</span><br><span class="line">xz -d Python<span class="number">-3.6</span><span class="number">.4</span>.tar.xz</span><br><span class="line">tar -xf Python<span class="number">-3.6</span><span class="number">.4</span>.tar</span><br><span class="line">#进入解压后的目录，依次执行下面命令进行手动编译</span><br><span class="line">./configure prefix=<span class="regexp">/usr/</span>local/python3</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">#将原来的链接备份</span><br><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br><span class="line">#添加python3的软链接</span><br><span class="line">ln -s /usr/local/python3/bin/python3<span class="number">.6</span> /usr/bin/python</span><br><span class="line">#测试是否安装成功了</span><br><span class="line">python -V</span><br></pre></td></tr></table></figure></p><p>更改yum配置，因为其要用到python2才能执行，否则会导致yum不能正常使用，需要分别修改<code>/usr/bin/yum</code>和<code>/usr/libexec/urlgrabber-ext-down</code>这两个文件，把他们的<code>#! /usr/bin/python</code>修改为<code>#! /usr/bin/python2</code>。</p><p>然后还要给python3的pip3做一个软连接: <code>ln -s  /usr/local/python3/bin/pip3 /usr/bin/pip3</code>。</p><p>注意！如果你用了python3那么上面那个脚本就会有很大的变动。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a><br><a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/tutorial.html" target="_blank" rel="noopener">http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/tutorial.html</a></p>]]></content>
    
    <summary type="html">
    
      对线上业务要有一个敬畏之心，怎么呵护都不为过
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>云服务器的内存竟然少了500M...</title>
    <link href="http://yoursite.com/2018/07/27/%E7%AE%97%E7%AE%97%E5%86%85%E5%AD%98%E7%9A%84%E8%BF%99%E4%B8%80%E7%AC%94%E7%B3%8A%E6%B6%82%E5%B8%90/"/>
    <id>http://yoursite.com/2018/07/27/算算内存的这一笔糊涂帐/</id>
    <published>2018-07-27T07:28:35.000Z</published>
    <updated>2018-08-03T05:54:17.603Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="故障发现">故障发现</span></h2><p>今天发现有一台阿里云线上环境的服务器内存在告急，使用<code>free -m</code>一看，果然剩余的内存不多了，而且<code>buffers</code>和<code>cached</code>也都不高，如图：<br><img src="/images/memcache1.png" alt="paradin"></p><p>用<code>top</code>一看，里面的情况是这样的:<br><img src="/images/memcache2.png" alt="paradin"></p><p>很奇怪，<code>top</code>里的<code>res</code>即物理内存加起来也就2200M多一点，但是<code>free</code>命令里显示已经用掉了几乎3.4个G，那这1.2G的空头内存去哪了？要知道，<code>free</code>命令会把<code>Slab缓存</code>统计到了<code>used memory</code>里，那就看看<code>slab缓存</code>有多少吧。</p><p><code>yum install -y nmon</code>，使用<code>nmon</code>看一下，如图：<br><img src="/images/memcache3.png" alt="paradin"></p><p>发现里面有几乎650MB的slab内存，这样还是少了大约550MB，那么使用<code>slabtop</code>查看细节，如图：<br><img src="/images/memcache5.png" alt="paradin"></p><p>再用<code>cat /proc/meminfo</code>去查看一下内存详细情况，如图：<br><img src="/images/memcache4.png" alt="paradin"></p><p><a href="https://blog.famzah.net/2014/09/22/know-your-linux-memory-usage/" target="_blank" rel="noopener">https://blog.famzah.net/2014/09/22/know-your-linux-memory-usage/</a> 这里提到内存的计算公式：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MemTotal = MemFree + (Buffers + Cached + SwapCached) + AnonPages + (Slab + PageTables + KernelStack)</span><br><span class="line">MemTotal = MemFree + (Active + Inactive) + (Slab + PageTables + KernelStack)</span><br><span class="line">MemTotal = MemFree + (Buffers + Cached + SwapCached) + AnonPages + ((SReclaimable + SUnreclaim) + PageTables + KernelStack)</span><br><span class="line">MemTotal = MemFree + ((“Active(anon)” + “Active(file)”) + (“Inactive(anon)” + “Inactive(file)”)) + ((SReclaimable + SUnreclaim) + PageTables + KernelStack)</span><br></pre></td></tr></table></figure></p><p>虽然作者说他测试的机器内核是3.2的，但是这几个公式对我这个服务器（内核2.6）都可以用，虽然肯定不能严丝合缝但是相差值并不大，我用前两个公式算了一下我这个机器的情况：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MemTotal（<span class="number">3495620</span>） = MemFree（<span class="number">251396</span>） + Buffers（<span class="number">11456</span>） + Cached（<span class="number">292324</span>） + SwapCached（<span class="number">0</span>） + AnonPages（<span class="number">2302484</span>） + Slab（<span class="number">627068</span>） + PageTables（<span class="number">8972</span>） + KernelStack（<span class="number">1920</span>） </span><br><span class="line">MemTotal（<span class="number">3495592</span>） = MemFree（<span class="number">251396</span>） + Active（<span class="number">2450960</span>） + Inactive（<span class="number">155276</span>） + Slab（<span class="number">627068</span>） + PageTables（<span class="number">8972</span>） + KernelStack（<span class="number">1920</span>）</span><br></pre></td></tr></table></figure></p><h2><span id="猜测一下">猜测一下</span></h2><p>我特么的法克，这个memtotal跟3921112差距很远啊！相差了412MB！为什么会少了这么多？会不会这412MB就是那<code>used memory</code>减去slap内存的那部分神秘内存？他为什么没有统计在<code>/proc/meminfo</code>里？</p><p>于是果断给阿里云提工单，截图发锤，让他们给一个完美的解释。</p><p>等待阿里云回复的时间里，我又找了几个其他的机器，各种型号的都算了一下，发现一个现象：凡是装了这个模块的服务器都出现了<code>MemTotal</code>不相符的问题，大约误差值都是400M~500M，而除了这个模块，<code>MemTotal</code>的误差值基本就是50M以内。</p><p>呃…这好像不能怪阿里云了…不过的确<code>MemTotal</code>是有误差的啊！</p><p>找开发了解了一下，这个服务器里用了大量的tcp长连接，而且是https的，使用<code>netstat -na|grep ESTABLISHED|wc -l</code>一看，有95000个左右。</p><p>而在开发环境的机器里查看，<code>MemTotal</code>的相差率很小，而tcp连接数则不到20个。那用排除法可以确定是TCP长连接的锅，于是我猜测<strong>TCP长连接占用掉了一部分内存，而这部分内存又没有在meminfo（SLAB）里体现出来，进而导致free命令与top命令相差过大</strong>。</p><h2><span id="小心求证">小心求证</span></h2><p><strong>未完待续…</strong></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://farll.com/2016/10/high-memory-usage-alarm/#comment-9881" target="_blank" rel="noopener">http://farll.com/2016/10/high-memory-usage-alarm/#comment-9881</a><br><a href="http://lday.me/2017/09/02/0012_a_memory_leak_detection_procedure/" target="_blank" rel="noopener">http://lday.me/2017/09/02/0012_a_memory_leak_detection_procedure/</a> （虽然跟本文没啥关系，但是强力推荐）<br><a href="http://blog.yufeng.info/archives/2456" target="_blank" rel="noopener">http://blog.yufeng.info/archives/2456</a><br><a href="http://lovestblog.cn/blog/2015/08/21/rssxmx/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2015/08/21/rssxmx/</a><br><a href="https://www.mawenbao.com/research/linux-ate-my-memory.html" target="_blank" rel="noopener">https://www.mawenbao.com/research/linux-ate-my-memory.html</a></p>]]></content>
    
    <summary type="html">
    
      拿着计算器算内存，我觉得我成了一个会计...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="内存泄漏" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用tqdm制作下载进度条</title>
    <link href="http://yoursite.com/2018/07/24/%E4%BD%BF%E7%94%A8tqdm%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>http://yoursite.com/2018/07/24/使用tqdm添加下载的进度条/</id>
    <published>2018-07-24T13:04:48.000Z</published>
    <updated>2018-07-26T05:55:08.481Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="制作进度条">制作进度条</span></h2><p>既然接手了国内专有云，就要写一个“自动化部署脚本”。于是我就把整个部署的安装包放到阿里云的bucket，用脚本去<code>wget</code>这个部署包，然后进行脚本部署。但是由于这个安装包比较大，`于是就打算在脚本里添加一个“下载进度条”，这样就能了解到当前的下载情况。</p><p>google了一下，就发现了<code>tqdm</code>这个库，它声称比老版的progressbar库的单次响应时间提高了10倍以上，安装的方法很简单：<code>pip install tqdm</code>。</p><p>具体的用途和参数可以去看<a href="https://lorexxar.cn/2016/07/21/python-tqdm/" target="_blank" rel="noopener">https://lorexxar.cn/2016/07/21/python-tqdm/</a> 这篇文章。</p><p>从tqdm的几个参数可见要使用tqdm做下载进度条首先需要整个文件的大小。整个文件的大小可以用<code>requests.get</code>方法获取，获取到<code>header</code>里就有目标的大小。在使用<code>requests</code>模块下载大文件/数据时，建议使用使用<code>stream</code>模式。如果是<code>stream=False</code>，它会立即开始下载文件并放到内存中，如果文件过大，有可能导致内存不足。然后就是把目标文件拆成一个一个的小块，逐步的写入一个文件，这样达到了下载文件的目的。整个脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">def downloadFILE(url,name):</span><br><span class="line">    resp = requests.get(url=url,stream=True)</span><br><span class="line">#stream=True的作用是仅让响应头被下载，连接保持打开状态，</span><br><span class="line">    content_size = int(resp.headers['Content-Length'])/1024#确定整个安装包的大小</span><br><span class="line">    <span class="keyword">with</span> open(name, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print <span class="string">"安装包整个大小是："</span>,content_size,<span class="string">'k，开始下载...'</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> tqdm(iterable=resp.iter_content(<span class="number">1024</span>),total=content_size,unit=<span class="string">'k'</span>,desc=name):</span><br><span class="line">#调用iter_content，一块一块的遍历要下载的内容，搭配stream=True，此时才开始真正的下载</span><br><span class="line">#iterable：可迭代的进度条 total：总的迭代次数 desc：进度条的前缀</span><br><span class="line">            f.write(data)</span><br><span class="line">        print name + <span class="string">"已经下载完毕！"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">"需要下载的文件的地址"</span></span><br><span class="line">    name = url.split('/')[-1]#截取整个url最后一段即文件名</span><br><span class="line">    downloadFILE(url,name)</span><br></pre></td></tr></table></figure></p><p><img src="/images/bpython1.png" alt="paradin" title="脚本执行效果"><br>注意！下载文件所在的bucket要设置成“公有读”而不能是“私有”。</p><h2><span id="补充">补充</span></h2><ol><li>解压缩的脚本： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line">filename = <span class="string">'要解压包的路径'</span></span><br><span class="line">fz = zipfile.ZipFile(filename, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> fz.namelist():</span><br><span class="line">    fz.extract(file, path)</span><br></pre></td></tr></table></figure></li></ol><p>这个脚本即使没有unzip命令也可以执行的。</p><ol><li><p>获取本地IP地址的脚本：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def get_local_ip(ifname = <span class="string">'eth0'</span>):</span><br><span class="line">    <span class="keyword">import</span> socket, fcntl, struct</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    inet = fcntl.ioctl(s.fileno(), <span class="number">0x8915</span>, struct.pack(<span class="string">'256s'</span>, ifname[:<span class="number">15</span>]))</span><br><span class="line">    ret = socket.inet_ntoa(inet[<span class="number">20</span>:<span class="number">24</span>])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">print get_local_ip()</span><br></pre></td></tr></table></figure></li><li><p><code>bpython</code>，这是一个好东西，可以在linux环境下实现类似<code>pycharm</code>的提示功能,搭配tab键补全。安装方法就是<code>pip install bpython</code>，然后启动python的时候直接bpython即可。效果如图：<br><img src="/images/bpython.gif" alt="paradin"></p></li></ol><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/qq_40666028/article/details/79335961" target="_blank" rel="noopener">https://blog.csdn.net/qq_40666028/article/details/79335961</a><br><a href="http://blog.topspeedsnail.com/archives/9075" target="_blank" rel="noopener">http://blog.topspeedsnail.com/archives/9075</a><br><a href="https://www.168seo.cn/python/24286.html" target="_blank" rel="noopener">https://www.168seo.cn/python/24286.html</a></p>]]></content>
    
    <summary type="html">
    
      当下载大文件的时候，对着一个黑漆漆的屏幕干等，这太不酷了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="可视化" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>将Redhat的yum更换成免费版本</title>
    <link href="http://yoursite.com/2018/07/20/%E5%B0%86radhat%E7%9A%84yum%E6%9B%B4%E6%8D%A2%E6%88%90%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/07/20/将radhat的yum更换成免费版本/</id>
    <published>2018-07-20T06:40:06.000Z</published>
    <updated>2018-07-24T01:38:21.096Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="redhat替换yum源">RedHat替换yum源</span></h2><p>这次给吉林移动做一个项目，他们的服务器必须要用IE浏览器登陆堡垒机进行环境部署。我登陆上去一看，是redhat，在使用yum的时候会有如下报错：<br><img src="/images/yum2.png" alt="akb48"></p><p>这句话的意思是“redhat自带的yum源是需要注册才是更新下载软件的，如果必须注册才能使用”，换而言之就是要收费。卧槽，怎么可能，我们向来是“要钱没有，要命一条”。于是就要用CentOS源来替代yum源，而CentOS源是免费的。</p><p>首先先删除掉redhat自带的yum：<code>rpm -qa | grep yum | xargs rpm -e --nodeps</code>。</p><p>然后用<code>cat /etc/redhat-release</code>命令去查看一下系统版本，我这个机器的版本是<code>Red Hat Enterprise Linux Server release 6.5 (Santiago)</code>，就去<a href="http://mirrors.163.com/centos/6/os/x86_64/Packages/" target="_blank" rel="noopener">http://mirrors.163.com/centos/6/os/x86_64/Packages/</a> 下载如下几个文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//mirrors.163.com/centos/6/os/x86_64/Packages/yum-metadata-parser-1.1.2-16.el6.x86_64.rpm</span></span><br><span class="line">http:<span class="comment">//mirrors.163.com/centos/6/os/x86_64/Packages/yum-3.2.29-81.el6.centos.noarch.rpm</span></span><br><span class="line">http:<span class="comment">//mirrors.163.com/centos/6/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-45.el7.noarch.rpm</span></span><br></pre></td></tr></table></figure></p><p>如果想下载<code>centos 7</code>的就去<a href="http://mirrors.163.com/centos/7/os/x86_64/Packages/" target="_blank" rel="noopener">http://mirrors.163.com/centos/7/os/x86_64/Packages/</a> 这个网站下，文件名字是一样的就是版本号不一样，需要自己找一下。</p><p>然后就是安装这几个包：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh yum-metadata-parser<span class="number">-1.1</span><span class="number">.2</span><span class="number">-16.</span>el6.x86_64.rpm</span><br><span class="line">rpm -ivh yum<span class="number">-3.2</span><span class="number">.29</span><span class="number">-81.</span>el6.centos.noarch.rpm</span><br><span class="line">rpm -ivh yum-plugin-fastestmirror<span class="number">-1.1</span><span class="number">.31</span><span class="number">-45.</span>el7.noarch.rpm</span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">wget http:<span class="comment">//mirrors.163.com/.help/CentOS6-Base-163.repo#最好先备份旧文件</span></span><br><span class="line">sed -i <span class="string">'s#$releasever#6#g'</span> ./CentOS6-Base<span class="number">-163.</span>repo</span><br><span class="line">yum clean all#清除原有的缓存</span><br><span class="line">yum makecache#重建缓存</span><br><span class="line">yum update -y#更新系统</span><br></pre></td></tr></table></figure></p><p>大功告成！可以使用免费的yum去装装装了！</p><h2><span id="修复python-urlgrabber版本过低">修复Python-urlgrabber版本过低</span></h2><p>当执行到<code>rpm -ivh yum-3.2.29-81.el6.centos.noarch.rpm</code>这一步的时候，可能会出现一个python的错误：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python-urlgrabber &gt;= <span class="number">3.9</span><span class="number">.1</span><span class="number">-10</span> is needed by yum<span class="number">-3.2</span><span class="number">.29</span><span class="number">-73.</span>el6.centos.noarch</span><br></pre></td></tr></table></figure></p><p>要求<code>python-urlgrabber</code>版本必须大于等于3.9.1-10，而用<code>rpm -qa|grep python</code>查看当前的版本是<code>python-urlgrabber-3.9.1-9.el6.noarch</code>，于是就<code>rpm -e python-urlgrabber-3.9.1-9.el6.noarch</code>卸载掉，<code>wget http://mirrors.163.com/centos/6/os/x86_64/Packages/python-urlgrabber-3.9.1-11.el6.noarch.rpm</code>之后，执行<code>rpm -ivh python-urlgrabber-3.9.1-11.el6.noarch.rpm</code>命令安装即可。</p><p>安装完毕，再用<code>rpm -ivh --force yum-*</code>安装后面的内容。如图:<br><img src="/images/yum4.png" alt="akb48"></p><h2><span id="无法解析yum源">无法解析yum源</span></h2><p>如果在<code>yum makecache</code>的时候出现了<code>http://mirrors.163.com/centos/6/os/x86_64/repodata/repomd.xml: [Errno 14] PYCURL ERROR 6 - &quot;Couldn&#39;t resolve host &#39;mirrors.163.com&#39;&quot;</code>的错误，如图：<br><img src="/images/yum3.png" alt="akb48"></p><p>就修改一下<code>/etc/resolv.conf</code>，然后在里面添加一句<code>nameserver 8.8.8.8</code>，保存即可。</p><h2><span id="nokey">NOKEY？？？</span></h2><p>如果出现<code>Header V3 RSA/SHA1 Signature, key ID c105b9de: NOKEY</code>，可以使用如下方法解决：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/pki/rpm-gpg/ </span><br><span class="line">wget http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-6 </span><br><span class="line">rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      自从投入了专有云，就要面对各种各样的甲方爸爸，爸爸们用的系统千奇百怪。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redhat" scheme="http://yoursite.com/tags/redhat/"/>
    
      <category term="yum源" scheme="http://yoursite.com/tags/yum%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Centos7编码安装php7.2和node.js8.11</title>
    <link href="http://yoursite.com/2018/07/17/centos7%E7%BC%96%E7%A0%81%E5%AE%89%E8%A3%85php7-2-7/"/>
    <id>http://yoursite.com/2018/07/17/centos7编码安装php7-2-7/</id>
    <published>2018-07-17T07:47:18.000Z</published>
    <updated>2018-07-19T01:33:59.258Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装php72">安装php7.2</span></h2><p>首先先做准备工作：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y libpng libpng-devel</span><br><span class="line">yum install -y bzip2 bzip2-devel</span><br><span class="line">yum install -y curl curl-devel</span><br></pre></td></tr></table></figure></p><p>编译安装步骤在此：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cd /root/</span><br><span class="line">wget http:<span class="comment">//101.96.10.64/cn2.php.net/distributions/php-7.2.7.tar.gz</span></span><br><span class="line">tar -zxvf php<span class="number">-7.2</span><span class="number">.7</span>.tar.gz</span><br><span class="line">cd  php<span class="number">-7.2</span><span class="number">.7</span></span><br><span class="line">sudo ./configure /</span><br><span class="line">--prefix=/usr/local/php727 /#PHP7安装的根目录</span><br><span class="line">--with-config-file-path=/usr/local/php727/etc /#PHP7的配置目录</span><br><span class="line">--with-apxs2=/usr/bin/apxs#如果用的是nginx就不要这句话</span><br><span class="line">--with-gd /#PHP gd模块</span><br><span class="line">--with-bz2 /#包含BZip2支持</span><br><span class="line">--with-zlib /#包含ZLIB支持</span><br><span class="line">--with-curl /#包含cURL支持</span><br><span class="line">--enable-mbstring / #启用多字节字符串支持</span><br><span class="line">--enable-zip / #包含Zip读写支持</span><br><span class="line">--enable-fpm / #启用PHP-FPM进程管理</span><br><span class="line">--enable-mysqlnd /#Enable mysqlnd explicitly</span><br><span class="line">--with-mysqli / #包含mysql支持</span><br><span class="line">--with-pdo-mysql/#包含mysql支持</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>如果出现了<code>configure error xml2-config not found. please check your libxml2 installation</code>错误，要执行如下两个：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install libxml2</span><br><span class="line">yum install libxml2-devel -y</span><br></pre></td></tr></table></figure></p><p>重新去执行<code>./configure</code>那步和<code>make &amp;&amp; make install</code>，整个编译完成之后，再把原带的<code>php.ini</code>拷贝到源码安装的文件夹里：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /root/php<span class="number">-7.2</span><span class="number">.7</span>/php.ini-development /usr/local/php727/lib/php.ini</span><br></pre></td></tr></table></figure></p><p>设置环境变量，修改<code>/etc/profile</code>文件使其永久性生效，并对所有系统用户生效，在文件末尾加上如下两行代码：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH=$PATH:<span class="regexp">/usr/</span>local/php/bin</span><br><span class="line"><span class="keyword">export</span> PATH</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>设置<code>php-fpm</code>开机自动启动<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/php-fpm</span><br><span class="line">chkconfig php-fpm on</span><br><span class="line">cp /usr/local/php727/etc/php-fpm.conf.default /usr/local/php727/etc/php-fpm.conf</span><br><span class="line">service php-fpm start</span><br></pre></td></tr></table></figure></p><h2><span id="安装gcc-810">安装gcc 8.1.0</span></h2><p>安装node.js需要先安装gcc，但是这个gcc不能用<code>yum install gcc-c++</code>装，因为centos7的gcc版本太低（4.8.5）不满足，在node.js编译的时候会报错：<code>WARNING: C++ compiler too old, need g++ 4.9.4 or clang++ 3.4.2 (CXX=g++)</code>。所以要去<a href="https://ftp.gnu.org/gnu/gcc/" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/gcc/</a> 下载一个高版本的，我选择了目前最牛逼的<code>8.1.0</code>。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//ftp.gnu.org/gnu/gcc/gcc-8.1.0/gcc-8.1.0.tar.gz</span></span><br><span class="line">tar -zxvf gcc<span class="number">-8.1</span><span class="number">.0</span>.tar.gz</span><br><span class="line">cd gcc<span class="number">-8.1</span><span class="number">.0</span></span><br><span class="line">./contrib/download_prerequisites</span><br></pre></td></tr></table></figure></p><p>此时进入漫长的等待，一会就会出现如下的字样，代表成功安装了!<br><img src="/images/gcc1.png" alt="办公室"></p><p>此时进行编译安装：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib </span><br><span class="line">make &amp;&amp;　make install</span><br></pre></td></tr></table></figure></p><p>又要进行漫长的等待…这一次非常非常漫长，我当时几乎用了大约2个小时…<br><img src="/images/gcc2.png" alt="办公室"></p><p>然后使用<code>gcc -v</code>检查一下版本：<br><img src="/images/gcc3.png" alt="办公室"></p><h2><span id="安装nodejs-811">安装node.js 8.11</span></h2><p>先去<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 下载新的版本包:<br><img src="/images/gcc4.png" alt="办公室"></p><p>直接下载到linux里解压缩，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//ftp.gnu.org/gnu/gcc/gcc-8.1.0/gcc-8.1.0.tar.gz</span></span><br><span class="line">tar zxvf node-v8<span class="number">.11</span><span class="number">.3</span>.tar.gz</span><br><span class="line">cd node-v8<span class="number">.11</span><span class="number">.3</span></span><br><span class="line">./configure --prefix=<span class="regexp">/usr/</span>local/node/<span class="number">8.11</span><span class="number">.3</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>此时在make这一步可能会有这样的错误：<br><img src="/images/gcc5.png" alt="办公室"></p><p>这个原因是“升级gcc时，生成的动态库没有替换老版本gcc动态库”，所以要将gcc最新版本的动态库替换系统中老版本的动态库。</p><p>使用<code>find / -name &quot;libstdc++.so*&quot;</code>查找编译gcc时生成的最新动态库，发现最近的动态库是这个：<br><img src="/images/gcc6.png" alt="办公室"></p><p>于是就进行替换并作一个软连接:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp /root/gcc<span class="number">-8.1</span><span class="number">.0</span>/stage1-x86_64-pc-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.25</span> /usr/lib64</span><br><span class="line">cd /usr/lib64</span><br><span class="line">ll libstdc++.so<span class="number">.6</span></span><br><span class="line">lrwxrwxrwx 1 root root 19 Jul 17 09:59 libstdc++.so.6 -&gt; libstdc++.so.6.0.19#把原来的记住，防止有回滚的现象</span><br><span class="line">rm -rf  libstdc++.so<span class="number">.6</span></span><br><span class="line">ln -s libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.25</span> libstdc++.so<span class="number">.6</span></span><br></pre></td></tr></table></figure></p><p>然后重新返回到<code>node-v8.11.3</code>文件夹里去<code>make</code>就OK了！</p><p>设定环境变量，<code>vim /etc/profile</code>，在<code>export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</code>一行的上面添加如下内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#set for nodejs</span><br><span class="line"><span class="keyword">export</span> NODE_HOME=<span class="regexp">/usr/</span>local/node/<span class="number">8.11</span><span class="number">.3</span></span><br><span class="line"><span class="keyword">export</span> PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>保存退出之后，<code>source /etc/profile</code>，再<code>node --version</code>看一下版本是<code>v8.11.3</code>就是OK了！</p>]]></content>
    
    <summary type="html">
    
      久闻php7的速度以及性能那可是比php5系列的任何一版本都要快，今天来试试
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="gc++" scheme="http://yoursite.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>世界杯的一些感悟</title>
    <link href="http://yoursite.com/2018/07/12/%E4%B8%96%E7%95%8C%E6%9D%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%84%9F%E6%82%9F/"/>
    <id>http://yoursite.com/2018/07/12/世界杯的一些新感悟/</id>
    <published>2018-07-12T02:21:00.000Z</published>
    <updated>2018-07-16T05:53:43.496Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="传控已死">传控已死？</span></h2><p>今早英格兰加时赛输给了克罗地亚，至此就剩下一名曼城球员还在本届世界杯继续前进了，那就是法国队的边后卫门迪。再加上之前小组出局的德国和1/8赛输球的西班牙，不得让人怀疑是否“传控已死”？</p><p>传控被瓜迪奥拉发扬光大已经10年了，2008年的西班牙也是靠着传控和巴萨的班底拿下两次欧洲杯和一次世界杯。传控虽然在理论上是一个完美的战术，但是战术也需要人来执行，球员水平有高低状态有起伏，裁判的尺度也不一样，这都会影响传控的比赛结果。这几年的传控逐渐被各路教练针对性研究，他们用“高压迫，快速反击，大巴防守”的套路击败传控的经典战役已经屡见不鲜。所以这几年的传控可谓是磕磕绊绊，风光不再。</p><p>传控对中场球员要求很高，一旦球员失去了往前传球的机会，那么就成了无效控球，倒脚来倒脚去时间就走光了。而传统打法对球员的要求相对简单但是对球员身体素质和纪律要求很高，所以更多球队选择了传统打法，而他们也很有针对性的对强队进行了部署，或打高空球或者摆大巴打反击。</p><p>我个人通过今年的世界杯和以往的几次欧冠来得到这样的结论：传控没有死，但是传控在杯赛的统治力已经大幅下滑，仅但在联赛和小型杯赛还有一定的优势。原因很简单，联赛是三十多场比赛，容错率要远大于杯赛，这就是传控的好处—虐菜相对来说比较稳。但是最近的足坛趋势是世界杯/欧洲杯/欧冠最大，拿不到上面几个锦标，球员就很难得到金球奖。所以在成绩的压力下，足坛也会慢慢将传控降温，改走传统打法。</p><p>即使是442也要有能一脚长传功力的中场做炮台，合适的球员搭配合适的战术才会得到胜利。任何战术本身也要自我修复漏洞，现在的传控队伍也开始慢慢放弃无用的控制，讲究定位球破门和远射破门，但是如何破密集防守还是世界教练共同面对的难题。</p><h2><span id="决赛怎么看">决赛怎么看？</span></h2><p>世界杯决赛肯定是防守为主的低比分比赛。法国那边进攻肯定还是“吉鲁吸引炮火，格里兹曼见缝插针，有反击找姆巴佩，角球任意球上大个子”的常规进攻路线。而克罗地亚也是慢节奏抓定位球的方法。我觉得克罗地亚中场并不虚法国，但是莫德里奇这几年没有跟坎特交手过，可以通过这场决赛看看双方谁更技高一筹。法国这批球员相对年轻，虽然这场比赛他们输不起，但是他们已经有了2016年欧洲杯亚军的惨痛经验，而克罗地亚虽然有些球员没有决赛经验，但是他们心态更放松，比较明显的隐患就是克罗地亚的体能是否能支持他们再一次顶得住法国的炮火。</p><p>从2006年至今，三届世界杯都踢了延长赛，所以我个人推荐买常规时间法国赢或者平。</p><p>至于季军赛，我觉得凯恩会进球，但是比利时3：2赢下英超内战。</p><p>世界杯让足彩也跟着热闹起来。我也跟着潮流买了几场比赛，但是我发现凡是“我跟别人说自己没买的”比赛，结果真中了；凡是我“下注买”的比赛都输了，且不用说德国输墨西哥，日本赢哥伦比亚的冷门战，英格兰打哥伦比亚那场的常规时间最后一分钟，米纳进了一个头球，我直接损失100块… </p><p>由此我坚信了，我就不是一个特别有好运气的人，而且也比较害怕成为赌徒，完全符合毛主席对知识分子和小资产阶级的定义，一辈子就是老婆孩子热炕头的命。</p><h2><span id="中国足球怎么办">中国足球怎么办？</span></h2><p>每到这种重大足球赛事，国足就要被当作反面典型来说嘴。前几天黄西发了微博调侃遭到国足及相关人士的狂喷，其实喷来喷去，主题就是一个“国足那些球员拿钱多，成绩却这么烂，如何能提高国足成绩？”</p><p>其实这个主题是老生常谈，每次都说改革但是也没什么进步，哪怕输给泰国1-5，全国上下一片骂，几天之后涛声依旧…</p><p>我个人认为中国足球在20年时间内是不可能强大的，因为这与中国国情有关。</p><p>第一，在中国传统教育里，中高阶级就没有那种“把孩子培养成运动员”的想法，毕竟丁俊晖父亲和张玉宁父亲才是少数，更多的父母希望孩子去当医生当公务员做生意，这不仅仅是大陆家庭，香港家庭和台湾家庭也是如此。只有贫苦家庭才会把孩子送去专门搞体育；</p><p>第二，为什么中产家庭不希望孩子只是把体育当作兴趣爱好而不是职业？首先现在独生子女太多，家长担心吃苦；其次，搞职业体育是从小开始的，万一踢不出来光阴就白白浪费了，而在发达国家，比如日本，贫富差距没有那么大，而且球员素养相对较高，即使不能大红大紫也不至于饿死，而比如南美部分贫困国家，家里不是独生子女，本来很穷上不起学，踢不出来就继续去搬砖，所以这两种国家的足球成绩不会太烂；再其次，足球青训部分教练素质不高，家长担心孩子跟着学坏；</p><p>第三，足球需要青训，而青训需要几代人的时间，但是足协更喜欢速成的方法，这与足球规律相悖，所以搞来搞去钱花了不少却始终原地转圈；</p><p>记得“诗人”贺炜在日本与比利时之战之后，发微博羡慕日本足球的同时也说“不多说了，说多了反动”。的确，如果潜规则少一点，贫富差距均衡一点，或许不止是足球，全中国体育的市场化就会有更加显著的改善了。</p>]]></content>
    
    <summary type="html">
    
      这一个月，说快真快啊！
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="足球" scheme="http://yoursite.com/tags/%E8%B6%B3%E7%90%83/"/>
    
      <category term="世界杯" scheme="http://yoursite.com/tags/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mycat读写分离测试</title>
    <link href="http://yoursite.com/2018/07/10/Mycat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/07/10/Mycat读写分离简单测试/</id>
    <published>2018-07-10T07:31:47.000Z</published>
    <updated>2018-07-10T08:47:58.913Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="配置文件解析">配置文件解析</span></h2><p>前文说了<code>schema.xml</code>文件的前两块内容，真正与读写分离有关的是第三块<code>dataHost</code>内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataHost name=<span class="string">"mycatTEST"</span> maxCon=<span class="string">"1000"</span> minCon=<span class="string">"10"</span> balance=<span class="string">"3"</span> writeType=<span class="string">"0"</span> dbType=<span class="string">"mysql"</span> dbDriver=<span class="string">"native"</span> switchType=<span class="string">"1"</span>  slaveThreshold=<span class="string">"100"</span>&gt;</span><br><span class="line">           &lt;heartbeat&gt;select user()&lt;<span class="regexp">/heartbeat&gt;</span></span><br><span class="line"><span class="regexp">           &lt;writeHost host="hostM1" url="rm-bp1099x0552q92edr.mysql.rds.aliyuncs.com:3306" user="mycat" password="这里是密码"&gt;</span></span><br><span class="line"><span class="regexp">           &lt;readHost host="hostS1" url="rr-bp1x35g0w6r767eu4.mysql.rds.aliyuncs.com:3306" user="mycat" password="这里是密码"&gt;</span></span><br><span class="line"><span class="regexp">           &lt;/</span>writeHost&gt;</span><br><span class="line">   &lt;<span class="regexp">/dataHost&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里主要描述的就是逻辑库需要映射的后端真实数据库的情况。某些选项含义如下：</p><ol><li><font color="red">maxCon</font>:指定每个读写实例连接池的最大连接。也就是说，标签内嵌套的<code>writeHost</code>、<code>readHost</code>标签都会使用这个属性的值来实例化出连接池的最大连接数;</li><li><font color="red">minCon</font>:指定每个读写实例连接池的最小连接，初始化连接池的大小;</li><li><font color="red">balance</font>:负载均衡类型，目前的取值有4种：<br> balance=“0”, 所有读操作都发送到当前可用的writeHost上。<br> balance=“1”，所有读操作都随机的发送到readHost。<br> balance=“2”，所有读操作都随机的在writeHost、readhost上分发。<br> balance=”3”，所有读请求随机的分发到wiriterHost对应的readhost执行，writerHost不负担读压力</li><li><font color="red">writeType</font>:负载均衡类型，目前的取值有3种：<br> writeType=“0”, 所有满足规则的写操作轮询的发送到可用的writeHost上。<br> writeType=“1”，所有满足规则的写操作随机的发送到readHost。<br> writeType=“2”，所有满足规则的写操作随机的在writeHost、readhost分发。（这一点我很怀疑，写操作怎么在readhost上进行）</li><li><font color="red">dbType</font>:指定后端连接的数据库类型，目前支持二进制的mysql协议，还有其他使用JDBC连接的数据库。例如：mongodb、oracle、 spark等;</li><li><font color="red">dbDriver</font>:指定连接后端数据库使用的Driver，目前可选的值有native和JDBC，当使用JDBC时则可以这么写：<code>jdbc:mysql://mycatTEST:3306/</code>;</li><li><font color="red">switchType</font>:主库切换算法，目前的取值有3种：<br> switchType=”-1”,表示不自动切换<br> switchType=”1”, 默认值，自动切换<br> switchType=”2”, 基于MySQL主从同步的状态决定是否切换,心跳语句为<code>show slave status</code><br> switchType=”3”,基于MySQL galary cluster的切换机制（适合集群）（1.4.1），心跳语句为<code>show status like &#39;wsrep%&#39;</code></li><li><font color="red">heartbeat</font>:这个标签内指明用于和后端数据库进行心跳检查的语句;</li><li><font color="red">writeHost &amp; readHost</font>:这两个标签都指定后端数据库的相关配置给mycat，用于实例化后端连接池。唯一不同的是，writeHost指定写实例、readHost指定读实例，组着这些读写实例来满足系统的要求。在一个dataHost内可以定义多个writeHost和readHost(我这里就配了一对，其实可以配很多对)。但是，如果writeHost指定的后端数据库宕机，那么这个writeHost绑定的所有readHost都将不可用。</li></ol><h2><span id="demo测试">Demo测试</span></h2><p>先登陆主库，然后<code>show slave status \G;</code>命令看一下状态，重点是<code>Slave_IO_Running</code>、<code>Slave_SQL_Running</code>和<code>Seconds_Behind_Master</code>这三个字段，如图：<br><img src="/images/mycat12.png" alt="akb48"></p><p>关注这三个字段的原因是“Mycat心跳机制通过检测他们来确定当前主从同步的状态”，如果<code>Seconds_Behind_Master</code>的数值大于<code>slaveThreshold</code>，读写分离筛选器会过滤掉此Slave机器，防止读到很久之前的旧数据，而当主节点宕机后，切换逻辑会检查Slave上的<code>Seconds_Behind_Master</code>是否为0，为0时则表示主从同步，可以安全切换，否则不会切换。</p><p>确认完之后，再去<code>log4j2.xml</code>文件把日志级别改成<code>debug</code>。如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;Loggers&gt;</span><br><span class="line">    &lt;asyncRoot level=<span class="string">"debug"</span> includeLocation=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;AppenderRef ref=<span class="string">"Console"</span> /&gt;</span><br><span class="line">        &lt;AppenderRef ref=<span class="string">"RollingFile"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/asyncRoot&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Loggers&gt;</span><br></pre></td></tr></table></figure></p><p>改完之后重启mycat。登陆到8066端口的mycat逻辑库，先创建一个库，再执行一个写的操作：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">`travelrecord`</span> (</span><br><span class="line"> <span class="string">`id`</span> int(<span class="number">11</span>) NOT NULL,</span><br><span class="line"> <span class="string">`name`</span> varchar(<span class="number">255</span>) NOT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">insert into travelrecord (id,name) values(<span class="number">5000010</span>,<span class="string">'bengbeng'</span>);</span><br></pre></td></tr></table></figure></p><p>在日志一看，发现这条记录已经被写入了dn2这个datanode里，如下：<br><img src="/images/mycat14.png" alt="akb48"></p><p>日志的意思是：逻辑库收到了insert命令，然后与真实库连接成功并且执行同步命令，<code>con need syn ,total syn cmd 1 commands</code>，之后发送查询sql，因为插入的那个数据是5000000，按照<code>auto-sharding-long</code>的规则，只会记录到db2的分片里。执行完后，会释放mycat逻辑库与真实Mysql连接也就是<code>release connection MySQLConnection</code>和<code>release channel MySQLConnection</code>。</p><p>再执行一个读的操作，比如<code>SELECT * FROM travelrecord;</code>，日志是这样记录的：<br><img src="/images/mycat13.png" alt="akb48"></p><p>与<code>schema.xml</code>里的<code>readhost</code>字段对比，的确是从hostS1上读取到的，由于balance=”3”，所以只会从读库读取，由于读的操作db1、db2、db3这3个分片都会操作（需要把他们的内容拼接在一起才是完整的内容），于是日志会打印三遍，实验结束。至于其他的更改参数情况，可以去看参考资料里的第二篇文章，说的很详尽了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://valleylord.github.io/post/201601-mycat-log-analysis/" target="_blank" rel="noopener">http://valleylord.github.io/post/201601-mycat-log-analysis/</a><br><a href="http://codingo.xyz/index.php/2018/03/08/mycat2/" target="_blank" rel="noopener">http://codingo.xyz/index.php/2018/03/08/mycat2/</a></p>]]></content>
    
    <summary type="html">
    
      Mycat本身不负责任何数据的同步，具体的数据同步还是依赖Mysql数据库自身的功能
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读写分离" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
      <category term="数据库中间件" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="mycat" scheme="http://yoursite.com/tags/mycat/"/>
    
  </entry>
  
  <entry>
    <title>博客评论改用来必力</title>
    <link href="http://yoursite.com/2018/07/09/%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E6%94%B9%E7%94%A8%E6%9D%A5%E5%BF%85%E5%8A%9B/"/>
    <id>http://yoursite.com/2018/07/09/博客评论改用来必力/</id>
    <published>2018-07-09T11:01:09.000Z</published>
    <updated>2018-07-09T11:27:22.966Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>原来我的博客评论用的是<code>hypercomments</code>，但是这几天发现评论已经不能用了，变成了<code>Close discussion</code>，如图：<br><img src="/images/pinglun1.png" alt="akb48"></p><p>去<a href="https://www.hypercomments.com/en/pricing" target="_blank" rel="noopener">https://www.hypercomments.com/en/pricing</a> 发现已经没有免费版了，或者是我这个google邮箱里的免费版<code>hypercomments</code>到期了，于是就琢磨换成来必力吧。</p><p>首先先去<code>https://livere.com</code> 注册一个账号，这个来必力是韩国的软件，但是用google翻译就不用怕了，注册很简单，找回密码也很简单。</p><p>再去<a href="https://livere.com/insight/communite" target="_blank" rel="noopener">https://livere.com/insight/communite</a> 里选择免费版，然后填写博客的地址和名称，选择<code>个人网站</code>。这个时候会得到一个<code>data-uid</code>，如图：<br><img src="/images/pinglun2.png" alt="akb48"></p><p>打开NexT主题的配置文件<code>_config.yml</code>中，搜索<code>livere_uid</code>，将<code>livere_uid</code>前面的<code>#</code>号去掉，将id填写到<code>livere_uid：</code>后面。再找到<code>Hypercomments</code>，把<code>hypercomments_id</code>这一行注释掉即可。</p>]]></content>
    
    <summary type="html">
    
      生命在于折腾
    
    </summary>
    
      <category term="博客搭建" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="博客搭建" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Mycat配置文件解析与分表存储测试</title>
    <link href="http://yoursite.com/2018/07/06/Mycat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/07/06/Mycat配置文件解析与读写分离测试/</id>
    <published>2018-07-06T11:51:18.000Z</published>
    <updated>2018-07-10T07:42:27.353Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>前文已经部署了mycat并且启动，此时登陆到mycat的8066端口，可以看到有一个database，这个database里有几个tables，如图：<br><img src="/images/mycat5.png" alt="akb48"></p><p>这些库和表根本不是我数据库里的啊，那它是从哪里来的呢？前文说了，mycat有一个虚拟库（逻辑库），它会把逻辑库上的操作映射到真实库里，现在8066这个端口就是虚拟库，里面有几个逻辑表，但是这些表其实不是真正存在的。而mycat主要有三个配置文件，分别是<code>schema.xml</code>、<code>rule.xml</code>和<code>server.xml</code>，<code>server.xml</code>就是配置虚拟数据库的账号密码的地方，很简单没什么好说的，<code>rule.xml</code>是分片规则的配置文件，没事别动它。而<code>schema.xml</code>里是主要配置逻辑库和逻辑表的配置文件。</p><h2><span id="配置文件解析">配置文件解析</span></h2><p>去除掉注释的<code>schema.xml</code>文件是这样的：<br><img src="/images/mycat4.png" alt="akb48"></p><p>可以看到整个配置文件分为三大块，第一块是<code>schema</code>，第二块是<code>dataNode</code>，第三块是<code>dataHost</code>，其中第三块是跟读写分离相关的，所以这里就说前两个部分，先说第二块<code>dataNode</code>：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataNode name=<span class="string">"dn1"</span> dataHost=<span class="string">"mycatTEST"</span> database=<span class="string">"db1"</span> /&gt;</span><br><span class="line">&lt;dataNode name=<span class="string">"dn2"</span> dataHost=<span class="string">"mycatTEST"</span> database=<span class="string">"db2"</span> /&gt;</span><br><span class="line">&lt;dataNode name=<span class="string">"dn3"</span> dataHost=<span class="string">"mycatTEST"</span> database=<span class="string">"db3"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>这一段表示该数据库有哪些数据节点，以及这些数据节点实际对应的数据服务器（这个节点跟<code>dataHost</code>的块有关）和数据库名，这里配置了3个节点dn1,dn2,dn3，都是在mycatTEST服务器上，也就是说我们需要在mycatTEST那个服务器，也就是下面writeHost的机器里先创建三个database，分别叫db1,db2,db3。我们在逻辑库上的操作都会分别下发到这三个db里，具体的下发算法在上面<code>schema</code>里有写。</p><p>再看第一块<code>schema</code>的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;schema name=<span class="string">"TESTDB"</span> checkSQLschema=<span class="string">"false"</span> sqlMaxLimit=<span class="string">"100"</span>&gt;</span><br><span class="line">        &lt;table name=<span class="string">"travelrecord"</span> dataNode=<span class="string">"dn1,dn2,dn3"</span> rule=<span class="string">"auto-sharding-long"</span> /&gt;</span><br><span class="line">        &lt;table name=<span class="string">"company"</span> primaryKey=<span class="string">"ID"</span> type=<span class="string">"global"</span> dataNode=<span class="string">"dn1,dn2,dn3"</span> /&gt;</span><br><span class="line">        &lt;table name=<span class="string">"goods"</span> primaryKey=<span class="string">"ID"</span> type=<span class="string">"global"</span> dataNode=<span class="string">"dn1,dn2"</span> /&gt;</span><br><span class="line">        &lt;table name=<span class="string">"hotnews"</span> primaryKey=<span class="string">"ID"</span> autoIncrement=<span class="string">"true"</span> dataNode=<span class="string">"dn1,dn2,dn3"</span> rule=<span class="string">"mod-long"</span> /&gt;</span><br><span class="line">        &lt;table name=<span class="string">"employee"</span> primaryKey=<span class="string">"ID"</span> dataNode=<span class="string">"dn1,dn2"</span> rule=<span class="string">"sharding-by-intfile"</span> /&gt;</span><br><span class="line">        &lt;table name=<span class="string">"customer"</span> primaryKey=<span class="string">"ID"</span> dataNode=<span class="string">"dn1,dn2"</span> rule=<span class="string">"sharding-by-intfile"</span>&gt;</span><br><span class="line">        &lt;childTable name=<span class="string">"orders"</span> primaryKey=<span class="string">"ID"</span> joinKey=<span class="string">"customer_id"</span> parentKey=<span class="string">"id"</span>&gt;</span><br><span class="line">        &lt;childTable name=<span class="string">"order_items"</span> joinKey=<span class="string">"order_id"</span> parentKey=<span class="string">"id"</span> /&gt;</span><br><span class="line">                &lt;<span class="regexp">/childTable&gt;</span></span><br><span class="line"><span class="regexp">        &lt;childTable name="customer_addr" primaryKey="ID" joinKey="customer_id"  parentKey="id" /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>schema&gt;</span><br></pre></td></tr></table></figure></p><p>这一段主要描述了虚拟数据库的schema即TESTDB中有哪些表，以及每个表分布在哪些数据节点上、分布的方法采用哪种算法。其他的选项含义如下：</p><ol><li><font color="red">checkSQLschema</font>:当该值设置为<code>true</code>时，如果我们执行语句<code>select * from TESTDB.travelrecord;</code>则MyCat会把语句修改为<code>select * from travelrecord;</code>。即把表示schema的字符去掉，避免发送到后端数据库执行时报<code>（ERROR 1146 (42S02): Table ‘testdb.travelrecord’ doesn’t exist）</code>。这里最好是采用默认的false；</li><li><font color="red">sqlMaxLimit</font>:当该值设置为某个数值时。每条执行的SQL语句，如果没有加上limit语句，MyCat也会自动的加上所对应的值。例如设置值为100，执行<code>select fromTESTDB.travelrecord;</code>的效果为和执行<code>select from TESTDB.travelrecord limit 100;</code>相同。需要注意的是，如果运行的schema为非拆分库的，那么该属性不会生效。需要手动添加limit语句；</li><li><font color="red">primaryKey</font>:该逻辑表对应真实表的主键，例如：分片的规则是使用非主键进行分片的，那么在使用主键查询的时候，就会发送查询语句到所有配置的DN上，如果使用该属性配置真实表的主键；</li><li><font color="red">type</font>:该属性定义了逻辑表的类型，目前逻辑表只有“全局表（global）”和”普通表”两种类型；</li><li><font color="red">autoIncrement</font>:mysql对非自增长主键，使用<code>last_insert_id()</code>是不会返回结果的，只会返回0。所以，只有定义了自增长主键的表才可以用<code>last_insert_id()</code>返回主键值。使用<code>autoIncrement=“true”</code>指定这个表有使用自增长主键，这样mycat才会不抛出分片键找不到的异常。这里最好是采用默认的false；</li><li><font color="red">rule</font>:该属性用于指定逻辑表要使用的规则名字，规则名字在<code>rule.xml</code>中定义，必须与tableRule标签中name属性属性值一一对应；</li><li><font color="red">joinKey</font>:插入子表的时候会使用这个列的值查找父表存储的数据节点；</li><li><font color="red">parentKey</font>: 属性指定的值一般为与父表建立关联关系的列名。程序首先获取joinkey的值，再通过parentKey属性指定的列名产生查询语句，通过执行该语句得到父表存储在哪个分片上。从而确定子表存储的位置；</li></ol><p>举个例子方便理解，<code>&lt;table name=&quot;employee&quot; primaryKey=&quot;ID&quot; dataNode=&quot;dn1,dn2&quot; rule=&quot;sharding-by-intfile&quot; /&gt;</code>，意思就是“这个employee的表，主键是ID，只在dn1和dn2以<code>sharding-by-intfile</code>的规则存储”。</p><h2><span id="举个例子">举个例子</span></h2><p>按照上面修改了配置文件之后，重启一波mycat，登陆mycat的9066管理端口，使用<code>show @@datanode;</code>和<code>show @@datasource;</code>可以查看到数据库源和datanode已经成功建立了，如图：<br><img src="/images/mycat7.png" alt="akb48"></p><p>手动在阿里云的RDS的读库上创建db1、db2、db3这三个databases，如图：<br><img src="/images/mycat6.png" alt="akb48"></p><p>由于阿里云读写同步，所以只读实例上也有了db1、db2、db3这三个databases。</p><p>此时再开一个窗口，登陆mycat的8066端口，看到里面有了TESTDB这个逻辑库以及里面的逻辑表，但是这些逻辑表实际是不存在的，如图：<br><img src="/images/mycat8.png" alt="akb48"></p><p>这时创建employee表，插入数据：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table employee (id int not <span class="literal">null</span> primary key,name varchar(<span class="number">100</span>),sharding_id int not <span class="literal">null</span>);</span><br><span class="line">insert into employee(id,name,sharding_id) values(<span class="number">1</span>,<span class="string">'leader us'</span>,<span class="number">10000</span>);</span><br><span class="line">insert into employee(id,name,sharding_id) values(<span class="number">2</span>, <span class="string">'me'</span>,<span class="number">10010</span>);</span><br><span class="line">insert into employee(id,name,sharding_id) values(<span class="number">3</span>, <span class="string">'mycat'</span>,<span class="number">10000</span>);</span><br><span class="line">insert into employee(id,name,sharding_id) values(<span class="number">4</span>, <span class="string">'mydog'</span>,<span class="number">10010</span>);</span><br></pre></td></tr></table></figure></p><p>检查一下数据已经被成功插入，并且如果使用<code>select * from</code>查看的话，会从两个datanode上去查，而且都自动加上了<code>limit 100</code>的字样，这一点符合我们在<code>schema.xml</code>里配置的<code>&lt;table name=&quot;employee&quot; primaryKey=&quot;ID&quot; dataNode=&quot;dn1,dn2&quot;/&gt;</code>和<code>sqlMaxLimit=&quot;100&quot;</code>，如图：<br><img src="/images/mycat9.png" alt="akb48"></p><p>再来到阿里云只读RDS数据库里，检查一下刚刚在虚拟数据库里操作的动作是否被正确映射过来。如图:<br><img src="/images/mycat10.png" alt="akb48" title="插入4条数据，这里轮询插入了1和3"><br><img src="/images/mycat11.png" alt="akb48" title="插入4条数据，这里轮询插入了2和4"></p><p>可见<code>writeType=“0”</code>已经成功，这就是分表存储。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/wangshuang1631/article/details/62898469" target="_blank" rel="noopener">https://blog.csdn.net/wangshuang1631/article/details/62898469</a><br><a href="https://sylvanassun.github.io/2016/07/09/2016-07-09-MyCat/" target="_blank" rel="noopener">https://sylvanassun.github.io/2016/07/09/2016-07-09-MyCat/</a><br><a href="http://codingo.xyz/index.php/2018/02/27/mycat1/" target="_blank" rel="noopener">http://codingo.xyz/index.php/2018/02/27/mycat1/</a></p>]]></content>
    
    <summary type="html">
    
      mycat是通过分库而达到的分表的目的
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读写分离" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
      <category term="数据库中间件" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="mycat" scheme="http://yoursite.com/tags/mycat/"/>
    
  </entry>
  
  <entry>
    <title>Mycat 1.6.5的部署与启动</title>
    <link href="http://yoursite.com/2018/07/05/Mycat%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/07/05/Mycat的部署与简单测试/</id>
    <published>2018-07-05T03:19:29.000Z</published>
    <updated>2018-07-10T06:17:33.392Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>先说一下硬件：</p><ol><li>mycat服务器:阿里云ECS,centos7.4,2核2G1M带宽,外网带宽主要是为了yum安装方便；</li><li>数据库主库:阿里云RDS;</li><li>数据库读库:阿里云RDS只读实例;</li></ol><p>登陆阿里云ECS之后，首先先进行如下操作：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//dl.mycat.io/1.6.5/Mycat-server-1.6.5-release-20180122220033-linux.tar.gz #下载1.6.5版本</span></span><br><span class="line">yum install java-1.8.0-openjdk* -y #安装java 1.8</span><br><span class="line">yum install -y mysql #安装mysql客户端</span><br><span class="line">useradd mycat#创建mycat用户</span><br><span class="line">passwd mycat#更改这个用户的密码</span><br><span class="line">tar -zxvf Mycat-server-1.6.5-release-20180122220033-linux.tar.gz -C /usr/local#解压缩/usr/local</span><br><span class="line">cd /usr/local/</span><br><span class="line">chown -R mycat.mycat /usr/local/mycat/#设置mycat目录的属主和属组</span><br></pre></td></tr></table></figure></p><p>然后登陆到阿里云RDS读库和写库，看一下大小写是否是“不敏感”,否则可能会发生表找不到的问题，阿里云的RDS默认是不敏感的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MySQL [(none)]&gt; show global variables like <span class="string">'%lower_case%'</span>;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| lower_case_file_system | OFF   |#这个是“当前系统文件是否大小写敏感”，只读参数，无法修改</span><br><span class="line">| lower_case_table_names | 1     |#这个是“表名是否大小写敏感”，可以修改，改完了重启生效</span><br><span class="line">+------------------------+-------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h2><span id="mycat原理和文件结构">Mycat原理和文件结构</span></h2><p>Mycat的原理跟Atlas查不多，都是用一个虚拟的数据库作为前端，后面是挂上真实的写库和读库。如图：<br><img src="/images/mycat1.png" alt="akb48"></p><p>mycat文件夹的文件结构很简单：</p><ol><li><font color="red">conf</font>：配置文件；</li><li><font color="red">lib</font>：服务依赖的一些jar文件.；</li><li><font color="red">logs</font>：日志存储文件夹；</li><li><font color="red">bin</font>：可执行命令的地方：</li></ol><p>mycat的配置文件主要在<code>/usr/local/mycat/conf</code>文件夹里，里面有很多文件，但是主要的配置文件是如下几个：</p><ol><li><code>server.xml</code>用来配置虚拟数据库的信息；</li><li><code>schema.xml</code>用来配置真实读库写库的信息；</li><li><code>rule.xml</code>是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件；<br>注意！在这个目录下，配置文件修改，需要重启Mycat或者通过9066端口reload才会生效。</li></ol><p>首先在打开<code>server.xml</code>，在如下的地方做修改:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;user name=<span class="string">"root"</span> defaultAccount=<span class="string">"true"</span>&gt;&lt;!-- 这里是给虚拟库设定一个账号叫root，并且作为默认账号 --&gt;</span><br><span class="line">        &lt;property name="password"&gt;chenx1242&lt;/property&gt;&lt;!-- 账号root的密码 --&gt;</span><br><span class="line">        &lt;property name="schemas"&gt;TESTDB&lt;/property&gt;&lt;!-- 账号root对应的虚拟库,这个库保持默认比较好 --&gt;</span><br><span class="line">&lt;/user&gt;</span><br><span class="line">&lt;user name=<span class="string">"test"</span>&gt;&lt;!-- 这里是给虚拟库设定一个账号叫test，并且作为默认账号 --&gt;</span><br><span class="line">        &lt;property name="password"&gt;26e9p69r&lt;/property&gt;&lt;!-- 账号test的密码 --&gt;</span><br><span class="line">        &lt;property name="schemas"&gt;TESTDB&lt;/property&gt;&lt;!-- 账号test对应的虚拟库,这个库保持默认比较好 --&gt;</span><br><span class="line">        &lt;property name="readOnly"&gt;true&lt;/property&gt;&lt;!-- 说明这个账号是只读账号 --&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure></p><p>然后打开<code>schema.xml</code>，编辑如下地方：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataHost name=<span class="string">"localhost1"</span> maxCon=<span class="string">"1000"</span> minCon=<span class="string">"10"</span> balance=<span class="string">"0"</span> writeType=<span class="string">"0"</span> dbType=<span class="string">"mysql"</span> dbDriver=<span class="string">"native"</span> switchType=<span class="string">"1"</span>  slaveThreshold=<span class="string">"100"</span>&gt;</span><br><span class="line">               &lt;heartbeat&gt;select user()&lt;<span class="regexp">/heartbeat&gt;</span></span><br><span class="line"><span class="regexp">               &lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line"><span class="regexp">               &lt;writeHost host="hostM1" url="阿里云RDS:3306" user="账号"   password="对应密码"&gt;</span></span><br><span class="line"><span class="regexp">                       &lt;!-- can have multi read hosts --&gt;</span></span><br><span class="line"><span class="regexp">               &lt;readHost host="hostS1" url="阿里云只读RDS:3306" user="账号"   password="对应密码"/</span>&gt;</span><br><span class="line">               &lt;<span class="regexp">/writeHost&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- &lt;writeHost host="hostS2" url="localhost:3316" user="root" password="123456"/</span>&gt; --&gt;</span><br><span class="line">               &lt;!-- &lt;writeHost host="hostM2" url="localhost:3316" user="root" password="123456"/&gt; --&gt;</span><br><span class="line">   &lt;/dataHost&gt;</span><br></pre></td></tr></table></figure></p><p>检查好格式并保存之后，就到mycat目录下的/bin/里<code>./mycat start</code>就启动mycat了。启动成功之后，8066和9066都是被监听的，如图：<br><img src="/images/mycat2.png" alt="akb48"></p><p><img src="/images/mycat3.png" alt="akb48"></p><h2><span id="启动故障排错">启动故障排错</span></h2><p>如果启动mycat失败，可以去logs文件夹里看日志，这里举例几个有代表性的错误：</p><ol><li><p><code>wrapper.log</code>日志：<code>Caused by: io.mycat.config.util.ConfigException: SelfCheck###  schema mycat refered by user test is not exist!</code><br><code>server.xml</code>里schema最好选择默认的TESTDB，而不是错误里的自己起名的mycat。</p></li><li><p><code>wrapper.log</code>日志：<code>org.xml.sax.SAXParseException; lineNumber: 23; columnNumber: 3; The content of elements must consist of well-formed character data or markup</code><br>去检查一下<code>server.xml</code>的第23行，看一下是不是多了一个’&lt;’或者’&gt;’。</p></li><li><p><code>wrapper.log</code>日志：<code>Caused by: io.mycat.config.util.ConfigException: user root duplicated!</code><br><code>server.xml</code>里普通账号root，只读账号也叫root，冲突了。</p></li><li><p><code>wrapper.log</code>日志：<code>Caused by: org.xml.sax.SAXParseException; lineNumber: 16; columnNumber: 101; Element type &quot;WriteHost&quot; must be declared.</code><br><code>schema.xml</code>配置中writeHost写成了WriteHost导致报错。</p></li><li><p><code>mycat.log</code>日志如下：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-06</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">22.894</span>  WARN [$_NIOREACTOR<span class="number">-8</span>-RW] (io.mycat.backend.mysql.nio.MySQLConnectionAuthenticator.handle(MySQLConnectionAuthenticator.java:<span class="number">91</span>)) - can<span class="string">'t connect to mysql server ,errmsg:Access denied for user '</span>数据库账号<span class="string">'@'</span>本地IP<span class="string">' (using password: YES) MySQLConnection [id=8, lastTime=1530863602566, user=数据库账号, schema=db3, old shema=db3, borrowed=false, fromSlaveDB=false, threadId=4555911, charset=utf8, txIsolation=3, autocommit=true, attachment=null, respHandler=null, host=阿里云写库地址, port=3306, statusSync=null, writeQueue=0, modifiedSQLExecuted=false]</span></span><br></pre></td></tr></table></figure></li></ol><p><code>schema.xml</code>里把真实库的配置写错了。</p><ol><li><code>mycat.log</code>日志：<code>(io.mycat.net.NIOConnector.finishConnect(NIOConnector.java:155)) - error: java.net.ConnectException: Connection refused</code><br><code>schema.xml</code>的<code>&lt;dataHost&gt;</code>字段是否写入了多余的数据库。</li></ol><h2><span id="参考资料">参考资料</span></h2><p><a href="http://valleylord.github.io/post/201601-mycat-install/" target="_blank" rel="noopener">http://valleylord.github.io/post/201601-mycat-install/</a><br><a href="https://www.jianshu.com/p/f15d64fcb2f3" target="_blank" rel="noopener">https://www.jianshu.com/p/f15d64fcb2f3</a></p>]]></content>
    
    <summary type="html">
    
      MyCAT模拟了一个虚拟Mysql数据库，并通过简单的配置文件配置，将虚拟数据库中的表映射到实际数据库中
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读写分离" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
      <category term="数据库中间件" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="mycat" scheme="http://yoursite.com/tags/mycat/"/>
    
  </entry>
  
  <entry>
    <title>写在阿根廷出局之后</title>
    <link href="http://yoursite.com/2018/07/03/%E5%86%99%E5%9C%A8%E9%98%BF%E6%A0%B9%E5%BB%B7%E5%87%BA%E5%B1%80%E4%B9%8B%E5%90%8E/"/>
    <id>http://yoursite.com/2018/07/03/写在阿根廷出局之后/</id>
    <published>2018-07-03T01:49:33.000Z</published>
    <updated>2018-07-03T02:15:20.886Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="桑保利的无奈">桑保利的无奈</span></h2><p>阿根廷在俄罗斯世界杯的征程结束了，3:4输给法国看上去好像不那么糟糕，但是在姆巴佩下半场的2球时间里，阿根廷的后防线的的确确崩溃了。</p><p>一天之后的凌晨，俄罗斯靠点球大战送西班牙回家。很多阿根廷的球迷说阿根廷应该效仿俄罗斯，跟法国摆大巴，靠着偷鸡或者点球胜利。</p><p>我个人认为，此方法不可取。虽然阿根廷2014年是靠防守进了决赛，但是这支阿根廷老人更老，新人不牛，而且整支队伍缺乏磨合，纪律性也不够。桑保利深知阿根廷无法保持90分钟的高质量大巴，最多三十分钟。而且大巴阵需要一个高点去压迫对方的后卫，比如穆里尼奥的德罗巴、科斯塔、卢卡库，至少也得有一个能跳又壮的C罗在禁区里搅合，但是伊卡尔迪这次没来，所以桑保利无论是防守还是进攻都无法选择大巴。</p><p>所以说，“攻出去”是桑保利无奈的选择，至少这样能死的还壮烈一点。当然，桑保利换上法齐奥是一个败笔，但是最根本的原因还是阿根廷人才断档造成的阵容畸形。</p><h2><span id="梅西的困局">梅西的困局</span></h2><p>梅西在国家队是不是过得不爽？这是必然的。因为他在巴萨得到的支持远大于他在国家队得到的支持，但是这种支持差以肉眼可见的速度缩小。而且阿根廷的媒体对梅西也是比较苛刻，这就吃了没有好公关团队的亏。</p><p>让梅西去踢中场是很暴殄天物的行为，但是现在中场式微，梅西不得不去后撤拿球，甚至还要在边路拿球。我曾经说过，梅西后撤拿球就是慢性自杀，首先他不靠近禁区就无法高质量的射门，其次后撤拿球会让对手更多的容错率去包夹他进而消耗他的体力。这样下来不仅场面不好看，梅西的数据更难看，难免被人黑。不过我还是不明白为什么迪巴拉与梅西无法共存，他俩是位置冲突没错，但是梅西可以踢边路，让迪巴拉去踢前腰/影锋，这个从理论上来说是可行的。</p><p>反正在俱乐部解决梅西的问题很简单，砸钱买人即可，但是在国家队，估计要费桑保利的脑细胞了（前提是他不下课），所以说足球是和平年代的战争，表面拼的是场上比分，实际拼的是场下准备。</p><p>很多球迷反应说梅西在世界杯上没什么笑容，这让我想起来中日甲午战争的时候，中国船上的洋水手回忆说“中国的海员战斗前摩拳擦掌跃跃欲试，但是中国的军官则是一脸忧虑、若有所思”。事实说明，其实军官是更了解敌我实力差距的，梅西也是如此。但是没有办法，他必须要做打一个很难打赢的战争。</p><h2><span id="梅罗之争">梅罗之争</span></h2><p>可以说这两个人在俄罗斯的表现都是他们各自在俱乐部七层左右的功力（C罗要高一点），但是这两个人都踢飞了点球，而那个点球原本都可以把他们队伍带到下半区去面对较弱对队伍从而提高晋级的概率，可以说国家队过早出局跟他们有直接关系。</p><p>梅西在淘汰赛表现还可以但是在0:3输克罗地亚那一场太过失常，但是C罗这一边也是“高开低走”，不过同样四届世界杯，梅西世界杯6球3助攻，C罗是7球1助攻，大家都没有在淘汰赛进球，的确很巧合。</p><p>不过皇马三连冠外加葡萄牙拿到了欧洲杯冠军，让C罗的生涯看起来比梅西完美了很多。明年是巴西美洲杯，现在美洲杯的竞争完全不逊于欧洲杯，小马哥离开的阿根廷想夺冠并不乐观，梅西估计注定无法作为领袖为阿根廷带来一个洲际冠军了。</p><p>这两个人都是超级射手，而且不可否认的是他们都需要优秀的中场作为火力支持，以前梅西有“哈白布”大杀四方，而C罗现在有了“克卡莫”也逆转了金球奖总数，所以作为球迷，要认识到这一点：现代足球单打一场或许可以，连续独斗五场以上就是天神下凡了。</p><p>不过客观的说，除非内马尔等人能拿到世界杯，不然今年的金球奖还是C罗的，梅西和巴萨需要尽快加油，而加油最有效的方法就是补强中场，加强控制。</p>]]></content>
    
    <summary type="html">
    
      四年之后，一个轮回
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="足球" scheme="http://yoursite.com/tags/%E8%B6%B3%E7%90%83/"/>
    
      <category term="世界杯" scheme="http://yoursite.com/tags/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
      <category term="阿根廷" scheme="http://yoursite.com/tags/%E9%98%BF%E6%A0%B9%E5%BB%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用xshell做代理查看无公网服务器的WEB界面</title>
    <link href="http://yoursite.com/2018/06/30/%E4%BD%BF%E7%94%A8xshell%E5%81%9A%E4%BB%A3%E7%90%86%E6%9F%A5%E7%9C%8B%E6%97%A0%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84WEB%E7%95%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/06/30/使用xshell做代理查看无公网服务器的WEB界面/</id>
    <published>2018-06-30T09:28:56.000Z</published>
    <updated>2018-07-02T02:17:55.474Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在工作中经常有一些服务器是高机密的，那么这样的服务器就要与外网隔离。但是没有公网的服务器如果也没有连入到局域网的话，按常理来说是无法打开程序的Web界面。这里则分享一个黑科技—使用xshell做代理然后用浏览器去查看Web界面。</p><p>首先要在Xshell顶端菜单栏选择<code>查看</code>—<code>隧道窗格</code>。如图：<br><img src="/images/xshell1.png" alt="paradin"></p><p>此时Xshell的底端就出来一个窗口，然后选择<code>转移规则</code>，如图：<br><img src="/images/xshell2.png" alt="paradin"></p><p>在<code>转移规则</code>右键，选择<code>添加</code>，在添加的窗口里，<code>类型(方向）</code>选择<code>Dynamic(SOCKS4/5)</code>，端口就用默认的1080，备注爱写不写，如图：<br><img src="/images/xshell3.png" alt="paradin"></p><p>来到windows桌面，点击<code>我的电脑</code>—<code>控制面板</code>—<code>Internet选项</code>，打开<code>连接</code>这个标签页，选择下面的<code>局域网设置</code>。如图：<br><img src="/images/xshell4.png" alt="paradin"></p><p>在<code>局域网（LAN）设置</code>里，先在<code>为LAN使用代理服务器</code>前面打勾，然后点击<code>高级</code>，在套接字那里输入<code>127.0.0.1</code>，端口就是刚刚默认的1080，点击确定保存，如图：<br><img src="/images/xshell5.png" alt="paradin"></p><p>此时在浏览器里输入内网的IP地址就能打开这个服务器里Web界面了，比如我公司内部的云存储界面：<br><img src="/images/xshell6.png" alt="paradin"></p><p>不过此时你是完全属于LAN环境，公网是无法访问的。如果要恢复访问公网，那么就要返回到<code>局域网（LAN）设置</code>里，把<code>为LAN使用代理服务器</code>前面的勾点掉就OK。<br><img src="/images/大岛优子.gif" alt="paradin" title="优叔赛高！！！"></p>]]></content>
    
    <summary type="html">
    
      这个方法可以用来登陆MQ，kafka，kibana等无公网环境的界面...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="xshell" scheme="http://yoursite.com/tags/xshell/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置防盗链</title>
    <link href="http://yoursite.com/2018/06/27/Nginx%E9%85%8D%E7%BD%AE%E9%98%B2%E7%9B%97%E9%93%BE/"/>
    <id>http://yoursite.com/2018/06/27/Nginx配置防盗链/</id>
    <published>2018-06-27T06:08:04.000Z</published>
    <updated>2018-06-27T06:43:49.662Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="为什么网站们都要限制流量">为什么网站们都要限制流量？</span></h2><p>无论是网站服务器亦或是游戏服务器还是邮件服务器，说穿了也是一台电脑，也有CPU和内存。只不过服务器的CPU功能比个人电脑的CPU功能强大，比如个人电脑的CPU一秒钟能算1亿个数，那么服务器的CPU一秒钟就能算十亿个数。毕竟个人电脑只针对个人，但是服务器是要“接客”的，有了强大的硬件做后盾，网页/游戏/邮箱才不会那么轻易的Down掉。</p><p>但是CPU不是人类大脑，人脑是越用越聪明，CPU是越用越磨损，毕竟始终在连电的环境下。于是乎，没有必要的运算能省就省，一个人省一次，十万个人就省十万次，一千万个人就省一千万次，这样达到积少成多的目的。</p><p>CPU计算的是各种数据，而这些数据也叫作流量。有用的流量、有价值的流量通过CPU计算无可厚非，但是出现了没有用的流量或者是别人盗用我们的资源，那么这种情况能避免都要避免。什么叫盗用我们的资源，比如自己网站（网站A）上的图片或者视频，被其他人直接复制网站然后粘贴到他们的主页（网站B）上，其他用户登录了B网站，然后点击了那个图片和视频，由于是网址重链接，里外里提供数据的还是我们的服务器。也就是说B网站就是一个中介，而真正提供服务的是网站A，但是广告费和点击率都要网站B赚走了，这事儿实在是叔可忍婶不可忍。</p><h2><span id="什么是盗链如何发现被盗链">什么是盗链？如何发现被盗链？</span></h2><p>什么叫盗链，上面已经说的差不多了，如果上面的文字没有看懂的话，举个例子，如果您看到了这两个图片，证明这个网站就是在盗链。<br><img src="/images/fangdaolian1.jpg" alt="paradin"></p><p><img src="/images/fangdaolian2.jpg" alt="paradin"></p><p>这两个就是一个盗取的是QQ空间的图片，另一个就是百度的图片。用其他网站的图片这事儿本身是无所谓的，只要不涉及版权问题，都希望自己的作品能广泛传播，但是请不要直接通过网址重定向，厚道一点的行为应该是：“图片另存为”，然后到目标网站上去重新上传一下。</p><p>这里再多说一点网站的基础知识。</p><ol><li><p>PV值：PV=page view，网站是有少则一个网页多则N多网页组成的一个整体，PV值就是统计用户访问网站的总页数。比如www.JQK.com这个网站，今天有100个用户登录，平均每个用户翻阅了里面5个网页。那么这个网站的PV值就是500。若一个IP地址，对一个页面刷新10000次，PV值也是1.要查询网站的PV值登陆<a href="http://www.alexa.cn就行。" target="_blank" rel="noopener">http://www.alexa.cn就行。</a></p></li><li><p>Hit值：这个就是对网页里每个元素的点击量，一个网页里的图片就是一个元素，一个flv文件也是一个元素，一首歌曲也是一个元素。这些的总量就是hit值，hit值越高就证明这个网站被人查看的情况越高，那么也证明网站的高人气，那么自然广告也会卖出去很多钱。</p></li></ol><p>因为建网站这事儿关心到了金钱利益，网站越被人关注，自然价值也越大。于是会有一个公式来评判网站的“每日贡献”：<code>总流量=访问流量+下载流量= Page view值 x 页面大小+下载文件大小 x 下载次数</code>。</p><p>作为管理者，每天观察一下自己一亩三分地儿的网站数据情况是本职工作。但是有时候也会遇到网站流量很惊人的情况，一般来说，网站流量过大（CPU运转很多）的原因如下：</p><ol><li><p>网站是一个很大的网站：比如说淘宝，京东，网易，youtube，facebook那种大网站，里面成万上亿的网页，而且每天又有那么多人登陆，自然浏览量很大。虽然这些大集团的服务器也是少则几千，多则上万，甚至在不同地区也会有不少的服务器集群，但是这几万台服务器需要提供的数据会很多也是不争的事实。这种现象是正常的。</p></li><li><p>网页内容太大：可能本身网站是一个小网站，加起来也就十页二十页的内容，但是每一天的流量依旧很惊人，那么很有可能是单页或者某几页的字节太大。比如网页里有太多的图片，太多的视频，太多的其他链接，也有可能是前端码农们给这个网页的规划不合理。导致这个网页每一次被点击都要大费周折（hit值和PV值不高，但是日流量很高），长此以往不仅会耽误用户的整体体验，对服务器也是一个重大伤害。</p></li><li><p>搜索引擎产生了大量的数据流量：网站需要推广，于是就在各种搜索引擎上打广告，也有自己网站的很多图片用于外部调用。这样的结果就是本身来观摩网站的人很少，但是“借着引擎经过”的人很多，所以就会有PV值不高，但是Hit值和日流量很高的现象出现。</p></li><li><p>图片或者其他元素被盗链：第一部分就说过了，别人拿我们的图片去吸引别人关注，然后别人想要深入了解，还要来使用我们的服务器去提供详细数据。这种“用我们的牌子住我们的房，吃我们的饭却不给我们钱”的现象实在应该被弄死。这种现象的特征也是PV值不高（没人真正点击网站），但是Hit值和日流量很大（自己服务器的数据都给别的网站提供了）。</p></li><li><p>网站被DDos攻击了：被一些恶意的IP地址频繁登陆，来回的刷流量。这样迫使CPU做出运算的行为其实就是在远程的破坏服务器的硬件CPU，遇到这种现象，之前Nginx文章里有写，要么通过access.log找到这些IP封掉，要么就在配置文件里加上限制（<code>limit-rate</code>)。</p></li></ol><h2><span id="服务器是如何知道图片是从站外而来的呢">服务器是如何知道图片是从站外而来的呢？</span></h2><p>在http协议里有一个重要的选项叫<code>refer</code>，这个选项的内容就是该元素的来源地址。如果这个元素是服务器自己提供的，那么头文件里是没有refer这个选项的。通过refer这个信息，我们也可以知道登陆网站的客户是从哪个网站点击链接而来的。这样方便进行一个统计和规划。</p><p>假如，我在QQ空间里面发现一个图，然后右键图片，选择<code>在新标签栏里打开图片</code>，这时候通过浏览器<code>审查元素</code>的功能，能查查看请求头信息和响应头信息，发现响应头信息里多了一个refer，里面的内容就是图片的源地址：<br><img src="/images/fangdaolian3.jpg" alt="paradin"></p><p>我在QQ空间里看腾讯的照片自然是可以的，但是如果我在别的网站里看腾讯的照片，加重了腾讯服务器的负担，自然腾讯公司会不满意。于是腾讯服务器发现当前要引用这个图片的地址与refer头信息不是一个来源之后，就不会把这个图片的数据传送过来，于是就看到那个<code>此图片来自QQ空间，未经准许不可饮用</code>的警告图片。</p><p>既然知道了服务器是如何判断文件是否盗链，那么只要伪装一个refer就可以欺骗服务器达到“反防盗链”的目的了。至于这部分，可以自己单独研究。</p><h2><span id="如何使用nginx反盗链">如何使用Nginx反盗链？</span></h2><p>同样的使用<code>Nginx.conf</code>，在http的大括号下面，新建一个<code>location</code>，加入如下信息：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location</span><br><span class="line"> ~ .*\.(wma|wmv|asf|mp3|mmf|zip|rar|jpg|gif|png|swf|flv)$ &#123;</span><br><span class="line">#指定对以上几种类型的文件建立防盗链</span><br><span class="line">     valid_referers</span><br><span class="line"> none blocked *.alala.com alala.com;</span><br><span class="line">#盗链的范围不包括alala.com和alala.com下的二级网站，</span><br><span class="line">     if</span><br><span class="line">($invalid_referer)</span><br><span class="line"> &#123;</span><br><span class="line">     #rewrite</span><br><span class="line"> ^/ http://www.alala.com/error.html;</span><br><span class="line">     return</span><br><span class="line">403;</span><br><span class="line">#如果发现有引用以上文件的地址与refer头信息不符的情况，直接重定向成error.html这个网页，服务器返回403，forbidden。</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者使用第三方模块<code>ngx_http_accesskey_module</code>实现Nginx防盗链。实现方法如下：</p><ol><li>下载<code>NginxHttpAccessKeyModule</code>模块文件：<a href="http://wiki.nginx.org/File:Nginx-accesskey-2.0.3.tar.gz；" target="_blank" rel="noopener">http://wiki.nginx.org/File:Nginx-accesskey-2.0.3.tar.gz；</a></li><li>解压此文件后，找到<code>nginx-accesskey-2.0.3</code>下的config文件。编辑此文件：替换其中的<code>$HTTP_ACCESSKEY_MODULE</code>为<code>ngx_http_accesskey_module</code>；</li><li>用一下参数重新编译nginx：<code>./configure --add-module=Nginx目录/to/nginx-accesskey</code>,然后执行:<code>make &amp;&amp; make install</code>;</li><li>修改<code>nginx.conf</code>文件，添加以下几行： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /download &#123;</span><br><span class="line">  accesskey on;</span><br><span class="line">  accesskey_hashmethod md5;</span><br><span class="line">  accesskey_arg &quot;key&quot;;</span><br><span class="line">  accesskey_signature &quot;mypass$remote_addr&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中：<br>accesskey为模块开关；<br>accesskey_hashmethod为加密方式MD5或者SHA-1；<br>accesskey_arg为url中的关键字参数；<br>accesskey_signature为加密值，此处为mypass和访问IP构成的字符串。</p>]]></content>
    
    <summary type="html">
    
      要是阿里云的服务，直接可以通过OSS里的“防盗链”配置即可
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="防盗链" scheme="http://yoursite.com/tags/%E9%98%B2%E7%9B%97%E9%93%BE/"/>
    
  </entry>
  
</feed>
